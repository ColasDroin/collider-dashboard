#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   The implementation is messy (issue #350): on Windows, with _MSC_VER,
   we have to define Py_LIMITED_API even before including pyconfig.h.
   In that case, we guess what pyconfig.h will do to the macros above,
   and check our guess after the #include.

   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
   version >= 16.0.0.  With older versions of either, you don't get a
   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
   running on Windows < 3.5, as an attempt at fixing it, but that's
   arguably wrong because it may not be the target version of Python.
   Still better than nothing I guess.  As another workaround, you can
   remove the definition of Py_LIMITED_API here.

   See also 'py_limited_api' in cffi/setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  ifdef _MSC_VER
#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#    include <pyconfig.h>
     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
        are also defined.  Normally, the Python file PC/pyconfig.h does not
        cause any of these to be defined, with the exception that _DEBUG
        causes Py_DEBUG.  Double-check that. */
#    ifdef Py_LIMITED_API
#      if defined(Py_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_TRACE_REFS)
#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_REF_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
#      endif
#    endif
#  else
#    include <pyconfig.h>
#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

_CFFI_UNUSED_FN static int
_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
                             char **output_data, Py_ssize_t datasize,
                             struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

_CFFI_UNUSED_FN static void
_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/

#include <stdint.h>
#define XTRACK_MULTIPOLE_NO_SYNRAD
#define XFIELDS_BB3D_NO_BEAMSTR
#define XFIELDS_BB3D_NO_BHABHA
#define XTRACK_GLOBAL_XY_LIMIT 1.0
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

#ifndef XOBJ_TYPEDEF_ArrNInt64
#define XOBJ_TYPEDEF_ArrNInt64
typedef   struct ArrNInt64_s * ArrNInt64;
 static inline ArrNInt64 ArrNInt64_getp(ArrNInt64 restrict  obj){
  int64_t offset=0;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ArrNInt64_len(ArrNInt64 restrict  obj){
  int64_t offset=0;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ArrNInt64_get(const ArrNInt64 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ArrNInt64_set(ArrNInt64 restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ArrNInt64_getp1(ArrNInt64 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_ArrNFloat64
#define XOBJ_TYPEDEF_ArrNFloat64
typedef   struct ArrNFloat64_s * ArrNFloat64;
 static inline ArrNFloat64 ArrNFloat64_getp(ArrNFloat64 restrict  obj){
  int64_t offset=0;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ArrNFloat64_len(ArrNFloat64 restrict  obj){
  int64_t offset=0;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ArrNFloat64_get(const ArrNFloat64 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ArrNFloat64_set(ArrNFloat64 restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ArrNFloat64_getp1(ArrNFloat64 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_ArrNString
#define XOBJ_TYPEDEF_ArrNString
typedef   struct ArrNString_s * ArrNString;
 static inline ArrNString ArrNString_getp(ArrNString restrict  obj){
  int64_t offset=0;
  return (ArrNString)(( char*) obj+offset);
}
 static inline int64_t ArrNString_len(ArrNString restrict  obj){
  int64_t offset=0;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline  char* ArrNString_getp1(ArrNString restrict  obj, int64_t i0){
  int64_t offset=0;
  offset=*( int64_t*)(( char*) obj+offset+16+i0*8);
  return ( char*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_ArrNUint32
#define XOBJ_TYPEDEF_ArrNUint32
typedef   struct ArrNUint32_s * ArrNUint32;
 static inline ArrNUint32 ArrNUint32_getp(ArrNUint32 restrict  obj){
  int64_t offset=0;
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ArrNUint32_len(ArrNUint32 restrict  obj){
  int64_t offset=0;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ArrNUint32_get(const ArrNUint32 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ArrNUint32_set(ArrNUint32 restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ArrNUint32_getp1(ArrNUint32 restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_RecordIndex
#define XOBJ_TYPEDEF_RecordIndex
typedef   struct RecordIndex_s * RecordIndex;
 static inline RecordIndex RecordIndex_getp(RecordIndex restrict  obj){
  int64_t offset=0;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t RecordIndex_get_capacity(const RecordIndex restrict  obj){
  int64_t offset=0;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void RecordIndex_set_capacity(RecordIndex restrict  obj, int64_t value){
  int64_t offset=0;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* RecordIndex_getp_capacity(RecordIndex restrict  obj){
  int64_t offset=0;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t RecordIndex_get_num_recorded(const RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void RecordIndex_set_num_recorded(RecordIndex restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=8;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* RecordIndex_getp_num_recorded(RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t RecordIndex_get__dummy(const RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void RecordIndex_set__dummy(RecordIndex restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* RecordIndex_getp__dummy(RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t RecordIndex_get_buffer_id(const RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void RecordIndex_set_buffer_id(RecordIndex restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=24;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* RecordIndex_getp_buffer_id(RecordIndex restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( int64_t*)(( char*) obj+offset);
}
#endif


 static inline
int64_t RecordIndex_get_slot(RecordIndex record_index){

    if (record_index == NULL){
        return -2;
    }
    int64_t capacity = RecordIndex_get_capacity(record_index);
      uint32_t* num_recorded = RecordIndex_getp_num_recorded(record_index);

    if(*num_recorded >= capacity){
        return -1;
    }

    uint32_t slot;

//    slot = atomic_add(num_recorded, 1);   //only_for_context opencl
//    slot = atomicAdd(num_recorded, 1);    //only_for_context cuda

//    #pragma omp atomic capture            //only_for_context cpu_openmp
    slot = (*num_recorded)++;             //only_for_context cpu_serial cpu_openmp

    if (slot >= capacity){
        *num_recorded = capacity;
        return -1;
    }
    return (int64_t)slot;
}

#ifndef XOBJ_TYPEDEF_ParticlesData
#define XOBJ_TYPEDEF_ParticlesData
typedef   struct ParticlesData_s * ParticlesData;
 static inline ParticlesData ParticlesData_getp(ParticlesData restrict  obj){
  int64_t offset=0;
  return (ParticlesData)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_get__capacity(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__capacity(ParticlesData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp__capacity(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_get__num_active_particles(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__num_active_particles(ParticlesData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=16;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp__num_active_particles(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_get__num_lost_particles(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__num_lost_particles(ParticlesData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=24;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp__num_lost_particles(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_get_start_tracking_at_element(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_start_tracking_at_element(ParticlesData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp_start_tracking_at_element(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double ParticlesData_get_q0(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_q0(ParticlesData restrict  obj, double value){
  int64_t offset=0;
  offset+=40;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp_q0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( double*)(( char*) obj+offset);
}
 static inline double ParticlesData_get_mass0(const ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_mass0(ParticlesData restrict  obj, double value){
  int64_t offset=0;
  offset+=48;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp_mass0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_p0c(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=256;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_p0c(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=256;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_p0c(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=256;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_p0c(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=256;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_p0c(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=256;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_gamma0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_gamma0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_gamma0(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_gamma0(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_gamma0(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_beta0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_beta0(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_beta0(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_beta0(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_beta0(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_s(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_s(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_s(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_s(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_s(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_zeta(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_zeta(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_zeta(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_zeta(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_zeta(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_ptau(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_ptau(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_ptau(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_ptau(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_ptau(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_delta(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_delta(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_delta(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_delta(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_delta(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_rpp(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_rpp(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_rpp(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_rpp(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_rpp(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_rvv(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_rvv(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_rvv(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_rvv(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_rvv(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_chi(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_chi(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+120);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_chi(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_chi(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_chi(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_charge_ratio(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_charge_ratio(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+128);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_charge_ratio(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_charge_ratio(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_charge_ratio(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_weight(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_weight(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+136);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_weight(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_weight(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_weight(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_pdg_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_pdg_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+144);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_pdg_id(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_pdg_id(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_pdg_id(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_particle_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_particle_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+152);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_particle_id(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_particle_id(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_particle_id(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_at_element(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_at_element(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+160);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_at_element(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_at_element(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_at_element(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_at_turn(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_at_turn(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+168);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_at_turn(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_at_turn(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_at_turn(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_state(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_state(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+176);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_state(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_state(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_state(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesData_getp_parent_particle_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_parent_particle_id(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+184);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesData_get_parent_particle_id(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_parent_particle_id(ParticlesData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesData_getp1_parent_particle_id(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesData_getp__rng_s1(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len__rng_s1(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+192);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesData_get__rng_s1(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__rng_s1(ParticlesData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesData_getp1__rng_s1(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesData_getp__rng_s2(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len__rng_s2(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+200);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesData_get__rng_s2(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__rng_s2(ParticlesData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesData_getp1__rng_s2(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesData_getp__rng_s3(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len__rng_s3(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+208);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesData_get__rng_s3(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__rng_s3(ParticlesData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesData_getp1__rng_s3(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesData_getp__rng_s4(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len__rng_s4(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+216);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesData_get__rng_s4(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesData_set__rng_s4(ParticlesData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesData_getp1__rng_s4(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_x(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_x(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+224);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_x(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_x(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_x(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_y(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_y(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+232);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_y(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_y(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_y(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_px(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_px(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+240);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_px(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_px(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_px(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesData_getp_py(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesData_len_py(ParticlesData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+248);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesData_get_py(const ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesData_set_py(ParticlesData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesData_getp1_py(ParticlesData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xpart Package.   //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XPART_BASE_RNG_H
#define XPART_BASE_RNG_H

//#include <stdint.h> //only_for_context none

// Combined LCG-Thausworthe generator from (example 37-4):
// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-37-efficient-random-number-generation-and-application
#define MASK 0xffffffffUL
#define TAUSWORTHE(s,a,b,c,d) ((((s) &c) <<d) &MASK) ^ (((((s) <<a) &MASK)^(s)) >>b)
#define LCG(s,A,C) ((((A*(s)) &MASK) + C) &MASK)


 static inline
double rng_get (uint32_t *s1, uint32_t *s2, uint32_t *s3, uint32_t *s4 ){
  *s1 = TAUSWORTHE (*s1, 13, 19, 4294967294UL, 12);  // p1=2^31-1
  *s2 = TAUSWORTHE (*s2, 2, 25, 4294967288UL, 4);    // p2=2^30-1
  *s3 = TAUSWORTHE (*s3, 3, 11, 4294967280UL, 17);   // p3=2^28-1
  *s4 = LCG(*s4, 1664525, 1013904223UL);             // p4=2^32

  // Combined period is lcm(p1,p2,p3,p4) ~ 2^121
  return ((*s1) ^ (*s2) ^ (*s3) ^ (*s4)) / 4294967296.0 ;
}

 static inline
void rng_set (uint32_t *s1, uint32_t *s2, uint32_t *s3, uint32_t *s4, uint32_t s ){
  *s1 = LCG (s, 69069, 0);
  if (*s1 < 2) *s1 += 2UL;
  *s2 = LCG (*s1, 69069, 0);
  if (*s2 < 8) *s2 += 8UL;
  *s3 = LCG (*s2, 69069, 0);
  if (*s3 < 16) *s3 += 16UL;
  *s4 = LCG (*s3, 69069, 0);

  /* "warm it up" */
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  return;
}

#endif /* XPART_BASE_RNG_H */

 
// copyright ############################### //
// This file is part of the Xpart Package.   //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XPART_PARTICLES_RNG_H
#define XPART_PARTICLES_RNG_H

 
void Particles_initialize_rand_gen(ParticlesData particles,
      uint32_t* seeds, int n_init){

for (int ii=0; ii<n_init; ii++){ //autovectorized


    uint32_t s1, s2, s3, s4, s;
    s = seeds[ii];

    rng_set(&s1, &s2, &s3, &s4, s);

    ParticlesData_set__rng_s1(particles, ii, s1);
    ParticlesData_set__rng_s2(particles, ii, s2);
    ParticlesData_set__rng_s3(particles, ii, s3);
    ParticlesData_set__rng_s4(particles, ii, s4);

}//end autovectorized


}

#endif /* XPART_PARTICLES_RNG_H */


 typedef struct {
                 int64_t  _capacity;
                 int64_t  _num_active_particles;
                 int64_t  _num_lost_particles;
                 int64_t  start_tracking_at_element;
                 double  q0;
                 double  mass0;
      double* p0c;
      double* gamma0;
      double* beta0;
      double* s;
      double* zeta;
      double* ptau;
      double* delta;
      double* rpp;
      double* rvv;
      double* chi;
      double* charge_ratio;
      double* weight;
      int64_t* pdg_id;
      int64_t* particle_id;
      int64_t* at_element;
      int64_t* at_turn;
      int64_t* state;
      int64_t* parent_particle_id;
      uint32_t* _rng_s1;
      uint32_t* _rng_s2;
      uint32_t* _rng_s3;
      uint32_t* _rng_s4;
      double* x;
      double* y;
      double* px;
      double* py;
                 int64_t ipart;
                 int64_t endpart;
      int8_t* io_buffer;
} LocalParticle;


         static inline
        void LocalParticle_add_to_p0c(LocalParticle* part, double value){
#ifndef FREEZE_VAR_p0c
  part->p0c[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_gamma0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_gamma0
  part->gamma0[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_beta0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_beta0
  part->beta0[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_s(LocalParticle* part, double value){
#ifndef FREEZE_VAR_s
  part->s[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_zeta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_zeta
  part->zeta[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_ptau(LocalParticle* part, double value){
#ifndef FREEZE_VAR_ptau
  part->ptau[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_delta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_delta
  part->delta[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_rpp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rpp
  part->rpp[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_rvv(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rvv
  part->rvv[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_chi(LocalParticle* part, double value){
#ifndef FREEZE_VAR_chi
  part->chi[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_charge_ratio(LocalParticle* part, double value){
#ifndef FREEZE_VAR_charge_ratio
  part->charge_ratio[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_weight(LocalParticle* part, double value){
#ifndef FREEZE_VAR_weight
  part->weight[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_pdg_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_pdg_id
  part->pdg_id[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_particle_id
  part->particle_id[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_at_element(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_element
  part->at_element[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_at_turn(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_turn
  part->at_turn[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_state(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_state
  part->state[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_parent_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_parent_particle_id
  part->parent_particle_id[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to__rng_s1(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s1
  part->_rng_s1[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to__rng_s2(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s2
  part->_rng_s2[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to__rng_s3(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s3
  part->_rng_s3[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to__rng_s4(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s4
  part->_rng_s4[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_x(LocalParticle* part, double value){
#ifndef FREEZE_VAR_x
  part->x[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_y(LocalParticle* part, double value){
#ifndef FREEZE_VAR_y
  part->y[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_px(LocalParticle* part, double value){
#ifndef FREEZE_VAR_px
  part->px[part->ipart] += value;
#endif
}


         static inline
        void LocalParticle_add_to_py(LocalParticle* part, double value){
#ifndef FREEZE_VAR_py
  part->py[part->ipart] += value;
#endif
}


 static inline
int64_t LocalParticle_get__capacity(LocalParticle* part){
  return part->_capacity;
}
 static inline
int64_t LocalParticle_get__num_active_particles(LocalParticle* part){
  return part->_num_active_particles;
}
 static inline
int64_t LocalParticle_get__num_lost_particles(LocalParticle* part){
  return part->_num_lost_particles;
}
 static inline
int64_t LocalParticle_get_start_tracking_at_element(LocalParticle* part){
  return part->start_tracking_at_element;
}
 static inline
double LocalParticle_get_q0(LocalParticle* part){
  return part->q0;
}
 static inline
double LocalParticle_get_mass0(LocalParticle* part){
  return part->mass0;
}
 static inline
double LocalParticle_get_p0c(LocalParticle* part){
  return part->p0c[part->ipart];
}
 static inline
double LocalParticle_get_gamma0(LocalParticle* part){
  return part->gamma0[part->ipart];
}
 static inline
double LocalParticle_get_beta0(LocalParticle* part){
  return part->beta0[part->ipart];
}
 static inline
double LocalParticle_get_s(LocalParticle* part){
  return part->s[part->ipart];
}
 static inline
double LocalParticle_get_zeta(LocalParticle* part){
  return part->zeta[part->ipart];
}
 static inline
double LocalParticle_get_ptau(LocalParticle* part){
  return part->ptau[part->ipart];
}
 static inline
double LocalParticle_get_delta(LocalParticle* part){
  return part->delta[part->ipart];
}
 static inline
double LocalParticle_get_rpp(LocalParticle* part){
  return part->rpp[part->ipart];
}
 static inline
double LocalParticle_get_rvv(LocalParticle* part){
  return part->rvv[part->ipart];
}
 static inline
double LocalParticle_get_chi(LocalParticle* part){
  return part->chi[part->ipart];
}
 static inline
double LocalParticle_get_charge_ratio(LocalParticle* part){
  return part->charge_ratio[part->ipart];
}
 static inline
double LocalParticle_get_weight(LocalParticle* part){
  return part->weight[part->ipart];
}
 static inline
int64_t LocalParticle_get_pdg_id(LocalParticle* part){
  return part->pdg_id[part->ipart];
}
 static inline
int64_t LocalParticle_get_particle_id(LocalParticle* part){
  return part->particle_id[part->ipart];
}
 static inline
int64_t LocalParticle_get_at_element(LocalParticle* part){
  return part->at_element[part->ipart];
}
 static inline
int64_t LocalParticle_get_at_turn(LocalParticle* part){
  return part->at_turn[part->ipart];
}
 static inline
int64_t LocalParticle_get_state(LocalParticle* part){
  return part->state[part->ipart];
}
 static inline
int64_t LocalParticle_get_parent_particle_id(LocalParticle* part){
  return part->parent_particle_id[part->ipart];
}
 static inline
uint32_t LocalParticle_get__rng_s1(LocalParticle* part){
  return part->_rng_s1[part->ipart];
}
 static inline
uint32_t LocalParticle_get__rng_s2(LocalParticle* part){
  return part->_rng_s2[part->ipart];
}
 static inline
uint32_t LocalParticle_get__rng_s3(LocalParticle* part){
  return part->_rng_s3[part->ipart];
}
 static inline
uint32_t LocalParticle_get__rng_s4(LocalParticle* part){
  return part->_rng_s4[part->ipart];
}
 static inline
double LocalParticle_get_x(LocalParticle* part){
  return part->x[part->ipart];
}
 static inline
double LocalParticle_get_y(LocalParticle* part){
  return part->y[part->ipart];
}
 static inline
double LocalParticle_get_px(LocalParticle* part){
  return part->px[part->ipart];
}
 static inline
double LocalParticle_get_py(LocalParticle* part){
  return part->py[part->ipart];
}


         static inline
        void LocalParticle_set_p0c(LocalParticle* part, double value){
#ifndef FREEZE_VAR_p0c
  part->p0c[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_gamma0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_gamma0
  part->gamma0[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_beta0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_beta0
  part->beta0[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_s(LocalParticle* part, double value){
#ifndef FREEZE_VAR_s
  part->s[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_zeta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_zeta
  part->zeta[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_ptau(LocalParticle* part, double value){
#ifndef FREEZE_VAR_ptau
  part->ptau[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_delta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_delta
  part->delta[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_rpp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rpp
  part->rpp[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_rvv(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rvv
  part->rvv[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_chi(LocalParticle* part, double value){
#ifndef FREEZE_VAR_chi
  part->chi[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_charge_ratio(LocalParticle* part, double value){
#ifndef FREEZE_VAR_charge_ratio
  part->charge_ratio[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_weight(LocalParticle* part, double value){
#ifndef FREEZE_VAR_weight
  part->weight[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_pdg_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_pdg_id
  part->pdg_id[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_particle_id
  part->particle_id[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_at_element(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_element
  part->at_element[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_at_turn(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_turn
  part->at_turn[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_state(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_state
  part->state[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_parent_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_parent_particle_id
  part->parent_particle_id[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set__rng_s1(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s1
  part->_rng_s1[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set__rng_s2(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s2
  part->_rng_s2[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set__rng_s3(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s3
  part->_rng_s3[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set__rng_s4(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s4
  part->_rng_s4[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_x(LocalParticle* part, double value){
#ifndef FREEZE_VAR_x
  part->x[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_y(LocalParticle* part, double value){
#ifndef FREEZE_VAR_y
  part->y[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_px(LocalParticle* part, double value){
#ifndef FREEZE_VAR_px
  part->px[part->ipart] = value;
#endif
}

         static inline
        void LocalParticle_set_py(LocalParticle* part, double value){
#ifndef FREEZE_VAR_py
  part->py[part->ipart] = value;
#endif
}


         static inline
        void LocalParticle_scale_p0c(LocalParticle* part, double value){
#ifndef FREEZE_VAR_p0c
  part->p0c[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_gamma0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_gamma0
  part->gamma0[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_beta0(LocalParticle* part, double value){
#ifndef FREEZE_VAR_beta0
  part->beta0[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_s(LocalParticle* part, double value){
#ifndef FREEZE_VAR_s
  part->s[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_zeta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_zeta
  part->zeta[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_ptau(LocalParticle* part, double value){
#ifndef FREEZE_VAR_ptau
  part->ptau[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_delta(LocalParticle* part, double value){
#ifndef FREEZE_VAR_delta
  part->delta[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_rpp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rpp
  part->rpp[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_rvv(LocalParticle* part, double value){
#ifndef FREEZE_VAR_rvv
  part->rvv[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_chi(LocalParticle* part, double value){
#ifndef FREEZE_VAR_chi
  part->chi[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_charge_ratio(LocalParticle* part, double value){
#ifndef FREEZE_VAR_charge_ratio
  part->charge_ratio[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_weight(LocalParticle* part, double value){
#ifndef FREEZE_VAR_weight
  part->weight[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_pdg_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_pdg_id
  part->pdg_id[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_particle_id
  part->particle_id[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_at_element(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_element
  part->at_element[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_at_turn(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_at_turn
  part->at_turn[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_state(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_state
  part->state[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_parent_particle_id(LocalParticle* part, int64_t value){
#ifndef FREEZE_VAR_parent_particle_id
  part->parent_particle_id[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale__rng_s1(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s1
  part->_rng_s1[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale__rng_s2(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s2
  part->_rng_s2[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale__rng_s3(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s3
  part->_rng_s3[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale__rng_s4(LocalParticle* part, uint32_t value){
#ifndef FREEZE_VAR__rng_s4
  part->_rng_s4[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_x(LocalParticle* part, double value){
#ifndef FREEZE_VAR_x
  part->x[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_y(LocalParticle* part, double value){
#ifndef FREEZE_VAR_y
  part->y[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_px(LocalParticle* part, double value){
#ifndef FREEZE_VAR_px
  part->px[part->ipart] *= value;
#endif
}


         static inline
        void LocalParticle_scale_py(LocalParticle* part, double value){
#ifndef FREEZE_VAR_py
  part->py[part->ipart] *= value;
#endif
}



     static inline
    void LocalParticle_exchange(LocalParticle* part, int64_t i1, int64_t i2){
    
    {
    double temp = part->p0c[i2];
    part->p0c[i2] = part->p0c[i1];
    part->p0c[i1] = temp;
     }
    {
    double temp = part->gamma0[i2];
    part->gamma0[i2] = part->gamma0[i1];
    part->gamma0[i1] = temp;
     }
    {
    double temp = part->beta0[i2];
    part->beta0[i2] = part->beta0[i1];
    part->beta0[i1] = temp;
     }
    {
    double temp = part->s[i2];
    part->s[i2] = part->s[i1];
    part->s[i1] = temp;
     }
    {
    double temp = part->zeta[i2];
    part->zeta[i2] = part->zeta[i1];
    part->zeta[i1] = temp;
     }
    {
    double temp = part->ptau[i2];
    part->ptau[i2] = part->ptau[i1];
    part->ptau[i1] = temp;
     }
    {
    double temp = part->delta[i2];
    part->delta[i2] = part->delta[i1];
    part->delta[i1] = temp;
     }
    {
    double temp = part->rpp[i2];
    part->rpp[i2] = part->rpp[i1];
    part->rpp[i1] = temp;
     }
    {
    double temp = part->rvv[i2];
    part->rvv[i2] = part->rvv[i1];
    part->rvv[i1] = temp;
     }
    {
    double temp = part->chi[i2];
    part->chi[i2] = part->chi[i1];
    part->chi[i1] = temp;
     }
    {
    double temp = part->charge_ratio[i2];
    part->charge_ratio[i2] = part->charge_ratio[i1];
    part->charge_ratio[i1] = temp;
     }
    {
    double temp = part->weight[i2];
    part->weight[i2] = part->weight[i1];
    part->weight[i1] = temp;
     }
    {
    int64_t temp = part->pdg_id[i2];
    part->pdg_id[i2] = part->pdg_id[i1];
    part->pdg_id[i1] = temp;
     }
    {
    int64_t temp = part->particle_id[i2];
    part->particle_id[i2] = part->particle_id[i1];
    part->particle_id[i1] = temp;
     }
    {
    int64_t temp = part->at_element[i2];
    part->at_element[i2] = part->at_element[i1];
    part->at_element[i1] = temp;
     }
    {
    int64_t temp = part->at_turn[i2];
    part->at_turn[i2] = part->at_turn[i1];
    part->at_turn[i1] = temp;
     }
    {
    int64_t temp = part->state[i2];
    part->state[i2] = part->state[i1];
    part->state[i1] = temp;
     }
    {
    int64_t temp = part->parent_particle_id[i2];
    part->parent_particle_id[i2] = part->parent_particle_id[i1];
    part->parent_particle_id[i1] = temp;
     }
    {
    uint32_t temp = part->_rng_s1[i2];
    part->_rng_s1[i2] = part->_rng_s1[i1];
    part->_rng_s1[i1] = temp;
     }
    {
    uint32_t temp = part->_rng_s2[i2];
    part->_rng_s2[i2] = part->_rng_s2[i1];
    part->_rng_s2[i1] = temp;
     }
    {
    uint32_t temp = part->_rng_s3[i2];
    part->_rng_s3[i2] = part->_rng_s3[i1];
    part->_rng_s3[i1] = temp;
     }
    {
    uint32_t temp = part->_rng_s4[i2];
    part->_rng_s4[i2] = part->_rng_s4[i1];
    part->_rng_s4[i1] = temp;
     }
    {
    double temp = part->x[i2];
    part->x[i2] = part->x[i1];
    part->x[i1] = temp;
     }
    {
    double temp = part->y[i2];
    part->y[i2] = part->y[i1];
    part->y[i1] = temp;
     }
    {
    double temp = part->px[i2];
    part->px[i2] = part->px[i1];
    part->px[i1] = temp;
     }
    {
    double temp = part->py[i2];
    part->py[i2] = part->py[i1];
    part->py[i1] = temp;
     }}



         static inline
          int8_t* LocalParticle_get_io_buffer(LocalParticle* part){
            return part->io_buffer;
        }

        

         static inline
        void Particles_to_LocalParticle(ParticlesData source,
                                        LocalParticle* dest,
                                        int64_t id,
                                        int64_t eid){
  dest->_capacity = ParticlesData_get__capacity(source);
  dest->_num_active_particles = ParticlesData_get__num_active_particles(source);
  dest->_num_lost_particles = ParticlesData_get__num_lost_particles(source);
  dest->start_tracking_at_element = ParticlesData_get_start_tracking_at_element(source);
  dest->q0 = ParticlesData_get_q0(source);
  dest->mass0 = ParticlesData_get_mass0(source);
  dest->p0c = ParticlesData_getp1_p0c(source, 0);
  dest->gamma0 = ParticlesData_getp1_gamma0(source, 0);
  dest->beta0 = ParticlesData_getp1_beta0(source, 0);
  dest->s = ParticlesData_getp1_s(source, 0);
  dest->zeta = ParticlesData_getp1_zeta(source, 0);
  dest->ptau = ParticlesData_getp1_ptau(source, 0);
  dest->delta = ParticlesData_getp1_delta(source, 0);
  dest->rpp = ParticlesData_getp1_rpp(source, 0);
  dest->rvv = ParticlesData_getp1_rvv(source, 0);
  dest->chi = ParticlesData_getp1_chi(source, 0);
  dest->charge_ratio = ParticlesData_getp1_charge_ratio(source, 0);
  dest->weight = ParticlesData_getp1_weight(source, 0);
  dest->pdg_id = ParticlesData_getp1_pdg_id(source, 0);
  dest->particle_id = ParticlesData_getp1_particle_id(source, 0);
  dest->at_element = ParticlesData_getp1_at_element(source, 0);
  dest->at_turn = ParticlesData_getp1_at_turn(source, 0);
  dest->state = ParticlesData_getp1_state(source, 0);
  dest->parent_particle_id = ParticlesData_getp1_parent_particle_id(source, 0);
  dest->_rng_s1 = ParticlesData_getp1__rng_s1(source, 0);
  dest->_rng_s2 = ParticlesData_getp1__rng_s2(source, 0);
  dest->_rng_s3 = ParticlesData_getp1__rng_s3(source, 0);
  dest->_rng_s4 = ParticlesData_getp1__rng_s4(source, 0);
  dest->x = ParticlesData_getp1_x(source, 0);
  dest->y = ParticlesData_getp1_y(source, 0);
  dest->px = ParticlesData_getp1_px(source, 0);
  dest->py = ParticlesData_getp1_py(source, 0);
  dest->ipart = id;
  dest->endpart = eid;
}


         static inline
        void LocalParticle_to_Particles(
                                        LocalParticle* source,
                                        ParticlesData dest,
                                        int64_t id,
                                        int64_t set_scalar){
if (set_scalar){
  ParticlesData_set__capacity(dest,      LocalParticle_get__capacity(source));
  ParticlesData_set__num_active_particles(dest,      LocalParticle_get__num_active_particles(source));
  ParticlesData_set__num_lost_particles(dest,      LocalParticle_get__num_lost_particles(source));
  ParticlesData_set_start_tracking_at_element(dest,      LocalParticle_get_start_tracking_at_element(source));
  ParticlesData_set_q0(dest,      LocalParticle_get_q0(source));
  ParticlesData_set_mass0(dest,      LocalParticle_get_mass0(source));
}
  ParticlesData_set_p0c(dest, id,       LocalParticle_get_p0c(source));
  ParticlesData_set_gamma0(dest, id,       LocalParticle_get_gamma0(source));
  ParticlesData_set_beta0(dest, id,       LocalParticle_get_beta0(source));
  ParticlesData_set_s(dest, id,       LocalParticle_get_s(source));
  ParticlesData_set_zeta(dest, id,       LocalParticle_get_zeta(source));
  ParticlesData_set_ptau(dest, id,       LocalParticle_get_ptau(source));
  ParticlesData_set_delta(dest, id,       LocalParticle_get_delta(source));
  ParticlesData_set_rpp(dest, id,       LocalParticle_get_rpp(source));
  ParticlesData_set_rvv(dest, id,       LocalParticle_get_rvv(source));
  ParticlesData_set_chi(dest, id,       LocalParticle_get_chi(source));
  ParticlesData_set_charge_ratio(dest, id,       LocalParticle_get_charge_ratio(source));
  ParticlesData_set_weight(dest, id,       LocalParticle_get_weight(source));
  ParticlesData_set_pdg_id(dest, id,       LocalParticle_get_pdg_id(source));
  ParticlesData_set_particle_id(dest, id,       LocalParticle_get_particle_id(source));
  ParticlesData_set_at_element(dest, id,       LocalParticle_get_at_element(source));
  ParticlesData_set_at_turn(dest, id,       LocalParticle_get_at_turn(source));
  ParticlesData_set_state(dest, id,       LocalParticle_get_state(source));
  ParticlesData_set_parent_particle_id(dest, id,       LocalParticle_get_parent_particle_id(source));
  ParticlesData_set__rng_s1(dest, id,       LocalParticle_get__rng_s1(source));
  ParticlesData_set__rng_s2(dest, id,       LocalParticle_get__rng_s2(source));
  ParticlesData_set__rng_s3(dest, id,       LocalParticle_get__rng_s3(source));
  ParticlesData_set__rng_s4(dest, id,       LocalParticle_get__rng_s4(source));
  ParticlesData_set_x(dest, id,       LocalParticle_get_x(source));
  ParticlesData_set_y(dest, id,       LocalParticle_get_y(source));
  ParticlesData_set_px(dest, id,       LocalParticle_get_px(source));
  ParticlesData_set_py(dest, id,       LocalParticle_get_py(source));
}

 static inline
double LocalParticle_get_xp(LocalParticle* part){
    double const px = LocalParticle_get_px(part);
    double const rpp = LocalParticle_get_rpp(part);
    // INFO: this is not the angle, but sin(angle)
    return px*rpp;
}

 static inline
double LocalParticle_get_yp(LocalParticle* part){
    double const py = LocalParticle_get_py(part);
    double const rpp = LocalParticle_get_rpp(part);
    // INFO: this is not the angle, but sin(angle)
    return py*rpp;
}

 static inline
void LocalParticle_set_xp(LocalParticle* part, double xp){
#ifndef FREEZE_VAR_px
    double rpp = LocalParticle_get_rpp(part);
    // INFO: xp is not the angle, but sin(angle)
    LocalParticle_set_px(part, xp/rpp);
#endif
}

 static inline
void LocalParticle_set_yp(LocalParticle* part, double yp){
#ifndef FREEZE_VAR_py
    double rpp = LocalParticle_get_rpp(part);
    // INFO: yp is not the angle, but sin(angle)
    LocalParticle_set_py(part, yp/rpp);
#endif
}

 static inline
void LocalParticle_add_to_xp(LocalParticle* part, double xp){
#ifndef FREEZE_VAR_px
    LocalParticle_set_xp(part, LocalParticle_get_xp(part) + xp);
#endif
}

 static inline
void LocalParticle_scale_xp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_px
    LocalParticle_set_xp(part, LocalParticle_get_xp(part) * value);
#endif
}

 static inline
void LocalParticle_add_to_yp(LocalParticle* part, double yp){
#ifndef FREEZE_VAR_py
    LocalParticle_set_yp(part, LocalParticle_get_yp(part) + yp);
#endif
}

 static inline
void LocalParticle_scale_yp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_py
    LocalParticle_set_yp(part, LocalParticle_get_yp(part) * value);
#endif
}

 static inline
void LocalParticle_set_xp_yp(LocalParticle* part, double xp, double yp){
    double rpp = LocalParticle_get_rpp(part);
#ifndef FREEZE_VAR_px
    LocalParticle_set_px(part, xp/rpp);
#endif
#ifndef FREEZE_VAR_py
    LocalParticle_set_py(part, yp/rpp);
#endif
}

 static inline
void LocalParticle_add_to_xp_yp(LocalParticle* part, double xp, double yp){
    LocalParticle_set_xp_yp(part, LocalParticle_get_xp(part) + xp, LocalParticle_get_yp(part) + yp);
}

 static inline
void LocalParticle_scale_xp_yp(LocalParticle* part, double value_x, double value_y){
    LocalParticle_set_xp_yp(part, LocalParticle_get_xp(part) * value_x, LocalParticle_get_yp(part) * value_y);
}
 static inline
double LocalParticle_get_exact_xp(LocalParticle* part){
    double const px = LocalParticle_get_px(part);
    double const py = LocalParticle_get_py(part);
    double const one_plus_delta = 1. + LocalParticle_get_delta(part);
    double const rpp = 1./sqrt(one_plus_delta*one_plus_delta - px*px - py*py);
    // INFO: this is not the angle, but sin(angle)
    return px*rpp;
}

 static inline
double LocalParticle_get_exact_yp(LocalParticle* part){
    double const py = LocalParticle_get_py(part);
    double const px = LocalParticle_get_px(part);
    double const one_plus_delta = 1. + LocalParticle_get_delta(part);
    double const rpp = 1./sqrt(one_plus_delta*one_plus_delta - px*px - py*py);
    // INFO: this is not the angle, but sin(angle)
    return py*rpp;
}

 static inline
void LocalParticle_set_exact_xp(LocalParticle* part, double xp){
#ifndef FREEZE_VAR_px
    double rpp = LocalParticle_get_rpp(part);
    // Careful! If yp also changes, use LocalParticle_set_exact_xp_yp!
    double const yp = LocalParticle_get_exact_yp(part);
    rpp *= sqrt(1 + xp*xp + yp*yp);
    // INFO: xp is not the angle, but sin(angle)
    LocalParticle_set_px(part, xp/rpp);
#endif
}

 static inline
void LocalParticle_set_exact_yp(LocalParticle* part, double yp){
#ifndef FREEZE_VAR_py
    double rpp = LocalParticle_get_rpp(part);
    // Careful! If xp also changes, use LocalParticle_set_exact_xp_yp!
    double const xp = LocalParticle_get_exact_xp(part);
    rpp *= sqrt(1 + xp*xp + yp*yp);
    // INFO: yp is not the angle, but sin(angle)
    LocalParticle_set_py(part, yp/rpp);
#endif
}

 static inline
void LocalParticle_add_to_exact_xp(LocalParticle* part, double xp){
#ifndef FREEZE_VAR_px
    LocalParticle_set_exact_xp(part, LocalParticle_get_exact_xp(part) + xp);
#endif
}

 static inline
void LocalParticle_scale_exact_xp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_px
    LocalParticle_set_exact_xp(part, LocalParticle_get_exact_xp(part) * value);
#endif
}

 static inline
void LocalParticle_add_to_exact_yp(LocalParticle* part, double yp){
#ifndef FREEZE_VAR_py
    LocalParticle_set_exact_yp(part, LocalParticle_get_exact_yp(part) + yp);
#endif
}

 static inline
void LocalParticle_scale_exact_yp(LocalParticle* part, double value){
#ifndef FREEZE_VAR_py
    LocalParticle_set_exact_yp(part, LocalParticle_get_exact_yp(part) * value);
#endif
}

 static inline
void LocalParticle_set_exact_xp_yp(LocalParticle* part, double xp, double yp){
    double rpp = LocalParticle_get_rpp(part);
    rpp *= sqrt(1 + xp*xp + yp*yp);
#ifndef FREEZE_VAR_px
    LocalParticle_set_px(part, xp/rpp);
#endif
#ifndef FREEZE_VAR_py
    LocalParticle_set_py(part, yp/rpp);
#endif
}

 static inline
void LocalParticle_add_to_exact_xp_yp(LocalParticle* part, double xp, double yp){
    LocalParticle_set_exact_xp_yp(part, LocalParticle_get_exact_xp(part) + xp, LocalParticle_get_exact_yp(part) + yp);
}

 static inline
void LocalParticle_scale_exact_xp_yp(LocalParticle* part, double value_x, double value_y){
    LocalParticle_set_exact_xp_yp(part, LocalParticle_get_exact_xp(part) * value_x, LocalParticle_get_exact_yp(part) * value_y);
}


     static inline
    double LocalParticle_get_energy0(LocalParticle* part){

        double const p0c = LocalParticle_get_p0c(part);
        double const m0  = LocalParticle_get_mass0(part);

        return sqrt( p0c * p0c + m0 * m0 );
    }

     static inline
    void LocalParticle_update_ptau(LocalParticle* part, double new_ptau_value){

        double const beta0 = LocalParticle_get_beta0(part);

        double const ptau = new_ptau_value;

        double const irpp = sqrt(ptau*ptau + 2*ptau/beta0 +1);

        double const new_rpp = 1./irpp;
        LocalParticle_set_delta(part, irpp - 1.);

        double const new_rvv = irpp/(1 + beta0*ptau);
        LocalParticle_set_rvv(part, new_rvv);
        LocalParticle_set_ptau(part, ptau);

        LocalParticle_set_rpp(part, new_rpp );
    }

     static inline
    void LocalParticle_update_delta(LocalParticle* part, double new_delta_value){
        double const beta0 = LocalParticle_get_beta0(part);
        double const delta_beta0 = new_delta_value * beta0;
        double const ptau_beta0  = sqrt( delta_beta0 * delta_beta0 +
                                    2. * delta_beta0 * beta0 + 1. ) - 1.;

        double const one_plus_delta = 1. + new_delta_value;
        double const rvv    = ( one_plus_delta ) / ( 1. + ptau_beta0 );
        double const rpp    = 1. / one_plus_delta;
        double const ptau = ptau_beta0 / beta0;

        LocalParticle_set_delta(part, new_delta_value);

        LocalParticle_set_rvv(part, rvv );
        LocalParticle_set_rpp(part, rpp );
        LocalParticle_set_ptau(part, ptau );

    }

     static inline
    double LocalParticle_get_pzeta(LocalParticle* part){

        double const ptau = LocalParticle_get_ptau(part);
        double const beta0 = LocalParticle_get_beta0(part);

        return ptau/beta0;

    }

     static inline
    void LocalParticle_update_pzeta(LocalParticle* part, double new_pzeta_value){

        double const beta0 = LocalParticle_get_beta0(part);
        LocalParticle_update_ptau(part, beta0*new_pzeta_value);

    }

     static inline
    void increment_at_element(LocalParticle* part0, int64_t const increment){


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

            LocalParticle_add_to_at_element(part, increment);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


    }

     static inline
    void increment_at_turn(LocalParticle* part0, int flag_reset_s){


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_add_to_at_turn(part, 1);
        LocalParticle_set_at_element(part, 0);
        if (flag_reset_s>0){
            LocalParticle_set_s(part, 0.);
        }

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

    }

     static inline
    void increment_at_turn_backtrack(LocalParticle* part0, int flag_reset_s,
                                     double const line_length,
                                     int64_t const num_elements){


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_add_to_at_turn(part, -1);
        LocalParticle_set_at_element(part, num_elements);
        if (flag_reset_s>0){
            LocalParticle_set_s(part, line_length);
        }

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

    }

    // check_is_active has different implementation on CPU and GPU

    #define CPU_SERIAL_IMPLEM //only_for_context cpu_serial
//    #define CPU_OMP_IMPLEM //only_for_context cpu_openmp

    #ifdef CPU_SERIAL_IMPLEM

     static inline
    int64_t check_is_active(LocalParticle* part) {
        int64_t ipart=0;
        while (ipart < part->_num_active_particles){
            if (part->state[ipart]<1){
                LocalParticle_exchange(
                    part, ipart, part->_num_active_particles-1);
                part->_num_active_particles--;
                part->_num_lost_particles++;
            }
            else{
                ipart++;
            }
        }

        if (part->_num_active_particles==0){
            return 0;//All particles lost
        } else {
            return 1; //Some stable particles are still present
        }
    }

    #else // not CPU_SERIAL_IMPLEM
    #ifdef CPU_OMP_IMPLEM
    
     static inline
    int64_t check_is_active(LocalParticle* part) {
    #ifndef SKIP_SWAPS
        int64_t ipart = part->ipart;
        int64_t endpart = part->endpart;
        
        int64_t left = ipart;
        int64_t right = endpart - 1;
        int64_t swap_made = 0;
        int64_t has_alive = 0;
        
        if (left == right) return part->state[left] > 0;
        
        while (left < right) {
            if (part->state[left] > 0) {
                left++;
                has_alive = 1;
            }
            else if (part->state[right] <= 0) right--;
            else {
                LocalParticle_exchange(part, left, right);
                left++;
                right--;
                swap_made = 1;
            }
        }

        return swap_made || has_alive;
    #else
        return 1;
    #endif
    }
    
     static inline
    void count_reorganized_particles(LocalParticle* part) {
        int64_t num_active = 0;
        int64_t num_lost = 0;
        
        for (int64_t i = part->ipart; i < part->endpart; i++) {
            if (part->state[i] <= -999999999) break;
            else if (part->state[i] > 0) num_active++;
            else num_lost++;
        }
        
        part->_num_active_particles = num_active;
        part->_num_lost_particles = num_lost;
    }
    
    #else // not CPU_SERIAL_IMPLEM and not CPU_OMP_IMPLEM

     static inline
    int64_t check_is_active(LocalParticle* part) {
        return LocalParticle_get_state(part)>0;
    };

    #endif // CPU_OMP_IMPLEM
    #endif // CPU_SERIAL_IMPLEM

    #undef CPU_SERIAL_IMPLEM //only_for_context cpu_serial
//    #undef CPU_OMP_IMPLEM //only_for_context cpu_openmp


    
            #ifdef XTRACK_GLOBAL_XY_LIMIT

             static inline
            void global_aperture_check(LocalParticle* part0) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                    double const x = LocalParticle_get_x(part);
                    double const y = LocalParticle_get_y(part);

                int64_t const is_alive = (int64_t)(
                          (x >= -XTRACK_GLOBAL_XY_LIMIT) &&
                          (x <=  XTRACK_GLOBAL_XY_LIMIT) &&
                          (y >= -XTRACK_GLOBAL_XY_LIMIT) &&
                          (y <=  XTRACK_GLOBAL_XY_LIMIT) );

                // I assume that if I am in the function is because
                    if (!is_alive){
                       LocalParticle_set_state(part, -1);
                }

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            }

            #endif

             static inline
            void LocalParticle_add_to_energy(LocalParticle* part, double delta_energy, int pz_only ){
                double ptau = LocalParticle_get_ptau(part);
                double const p0c = LocalParticle_get_p0c(part);

                ptau += delta_energy/p0c;
                double const old_rpp = LocalParticle_get_rpp(part);

                LocalParticle_update_ptau(part, ptau);

                if (!pz_only) {
                    double const new_rpp = LocalParticle_get_rpp(part);
                    double const f = old_rpp / new_rpp;
                    LocalParticle_scale_px(part, f);
                    LocalParticle_scale_py(part, f);
                }
            }


             static inline
            void LocalParticle_update_p0c(LocalParticle* part, double new_p0c_value){

                double const mass0 = LocalParticle_get_mass0(part);
                double const old_p0c = LocalParticle_get_p0c(part);
                double const old_delta = LocalParticle_get_delta(part);
                double const old_beta0 = LocalParticle_get_beta0(part);

                double const ppc = old_p0c * old_delta + old_p0c;
                double const new_delta = (ppc - new_p0c_value)/new_p0c_value;

                double const new_energy0 = sqrt(new_p0c_value*new_p0c_value + mass0 * mass0);
                double const new_beta0 = new_p0c_value / new_energy0;
                double const new_gamma0 = new_energy0 / mass0;

                LocalParticle_set_p0c(part, new_p0c_value);
                LocalParticle_set_gamma0(part, new_gamma0);
                LocalParticle_set_beta0(part, new_beta0);

                LocalParticle_update_delta(part, new_delta);

                LocalParticle_scale_px(part, old_p0c/new_p0c_value);
                LocalParticle_scale_py(part, old_p0c/new_p0c_value);

                LocalParticle_scale_zeta(part, new_beta0/old_beta0);

            }

             static inline
            void LocalParticle_kill_particle(LocalParticle* part, int64_t kill_state) {
                LocalParticle_set_x(part, 1e30);
                LocalParticle_set_px(part, 1e30);
                LocalParticle_set_y(part, 1e30);
                LocalParticle_set_py(part, 1e30);
                LocalParticle_set_zeta(part, 1e30);
                LocalParticle_update_delta(part, -1);  // zero energy
                LocalParticle_set_state(part, kill_state);
            }
         

#ifndef XOBJ_TYPEDEF_SynchrotronRadiationRecordData
#define XOBJ_TYPEDEF_SynchrotronRadiationRecordData
typedef   struct SynchrotronRadiationRecordData_s * SynchrotronRadiationRecordData;
 static inline SynchrotronRadiationRecordData SynchrotronRadiationRecordData_getp(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  return (SynchrotronRadiationRecordData)(( char*) obj+offset);
}
 static inline RecordIndex SynchrotronRadiationRecordData_getp__index(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_get__index_capacity(const SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set__index_capacity(SynchrotronRadiationRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* SynchrotronRadiationRecordData_getp__index_capacity(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t SynchrotronRadiationRecordData_get__index_num_recorded(const SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set__index_num_recorded(SynchrotronRadiationRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* SynchrotronRadiationRecordData_getp__index_num_recorded(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t SynchrotronRadiationRecordData_get__index__dummy(const SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set__index__dummy(SynchrotronRadiationRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* SynchrotronRadiationRecordData_getp__index__dummy(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_get__index_buffer_id(const SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set__index_buffer_id(SynchrotronRadiationRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* SynchrotronRadiationRecordData_getp__index_buffer_id(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 SynchrotronRadiationRecordData_getp_photon_energy(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_len_photon_energy(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=72;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double SynchrotronRadiationRecordData_get_photon_energy(const SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=72;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set_photon_energy(SynchrotronRadiationRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=72;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* SynchrotronRadiationRecordData_getp1_photon_energy(SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=72;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNInt64 SynchrotronRadiationRecordData_getp_at_element(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_len_at_element(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t SynchrotronRadiationRecordData_get_at_element(const SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set_at_element(SynchrotronRadiationRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* SynchrotronRadiationRecordData_getp1_at_element(SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 SynchrotronRadiationRecordData_getp_at_turn(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_len_at_turn(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t SynchrotronRadiationRecordData_get_at_turn(const SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set_at_turn(SynchrotronRadiationRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* SynchrotronRadiationRecordData_getp1_at_turn(SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 SynchrotronRadiationRecordData_getp_particle_id(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_len_particle_id(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t SynchrotronRadiationRecordData_get_particle_id(const SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set_particle_id(SynchrotronRadiationRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* SynchrotronRadiationRecordData_getp1_particle_id(SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 SynchrotronRadiationRecordData_getp_particle_delta(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t SynchrotronRadiationRecordData_len_particle_delta(SynchrotronRadiationRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double SynchrotronRadiationRecordData_get_particle_delta(const SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void SynchrotronRadiationRecordData_set_particle_delta(SynchrotronRadiationRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* SynchrotronRadiationRecordData_getp1_particle_delta(SynchrotronRadiationRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_BeamstrahlungTableData
#define XOBJ_TYPEDEF_BeamstrahlungTableData
typedef   struct BeamstrahlungTableData_s * BeamstrahlungTableData;
 static inline BeamstrahlungTableData BeamstrahlungTableData_getp(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  return (BeamstrahlungTableData)(( char*) obj+offset);
}
 static inline RecordIndex BeamstrahlungTableData_getp__index(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_get__index_capacity(const BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set__index_capacity(BeamstrahlungTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamstrahlungTableData_getp__index_capacity(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamstrahlungTableData_get__index_num_recorded(const BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set__index_num_recorded(BeamstrahlungTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamstrahlungTableData_getp__index_num_recorded(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamstrahlungTableData_get__index__dummy(const BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set__index__dummy(BeamstrahlungTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamstrahlungTableData_getp__index__dummy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_get__index_buffer_id(const BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set__index_buffer_id(BeamstrahlungTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamstrahlungTableData_getp__index_buffer_id(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamstrahlungTableData_getp_at_element(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=112;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_at_element(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=112;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamstrahlungTableData_get_at_element(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=112;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_at_element(BeamstrahlungTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=112;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamstrahlungTableData_getp1_at_element(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=112;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamstrahlungTableData_getp_at_turn(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_at_turn(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamstrahlungTableData_get_at_turn(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_at_turn(BeamstrahlungTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamstrahlungTableData_getp1_at_turn(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamstrahlungTableData_getp_particle_id(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_particle_id(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamstrahlungTableData_get_particle_id(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_particle_id(BeamstrahlungTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamstrahlungTableData_getp1_particle_id(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_photon_id(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_photon_id(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_photon_id(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_photon_id(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_photon_id(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_photon_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_photon_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_photon_energy(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_photon_energy(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_photon_energy(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_photon_critical_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_photon_critical_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_photon_critical_energy(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_photon_critical_energy(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_photon_critical_energy(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_primary_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_primary_energy(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_primary_energy(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_primary_energy(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_primary_energy(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_rho_inv(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_rho_inv(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_rho_inv(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_rho_inv(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_rho_inv(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_n_avg(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_n_avg(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_n_avg(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_n_avg(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_n_avg(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamstrahlungTableData_getp_delta_avg(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamstrahlungTableData_len_delta_avg(BeamstrahlungTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamstrahlungTableData_get_delta_avg(const BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamstrahlungTableData_set_delta_avg(BeamstrahlungTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamstrahlungTableData_getp1_delta_avg(BeamstrahlungTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_BhabhaTableData
#define XOBJ_TYPEDEF_BhabhaTableData
typedef   struct BhabhaTableData_s * BhabhaTableData;
 static inline BhabhaTableData BhabhaTableData_getp(BhabhaTableData restrict  obj){
  int64_t offset=0;
  return (BhabhaTableData)(( char*) obj+offset);
}
 static inline RecordIndex BhabhaTableData_getp__index(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_get__index_capacity(const BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set__index_capacity(BhabhaTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp__index_capacity(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t BhabhaTableData_get__index_num_recorded(const BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set__index_num_recorded(BhabhaTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BhabhaTableData_getp__index_num_recorded(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t BhabhaTableData_get__index__dummy(const BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set__index__dummy(BhabhaTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BhabhaTableData_getp__index__dummy(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_get__index_buffer_id(const BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set__index_buffer_id(BhabhaTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp__index_buffer_id(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BhabhaTableData_getp_at_element(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=120;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_at_element(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=120;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BhabhaTableData_get_at_element(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=120;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_at_element(BhabhaTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=120;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp1_at_element(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=120;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BhabhaTableData_getp_at_turn(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_at_turn(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BhabhaTableData_get_at_turn(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_at_turn(BhabhaTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp1_at_turn(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BhabhaTableData_getp_particle_id(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_particle_id(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BhabhaTableData_get_particle_id(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_particle_id(BhabhaTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp1_particle_id(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BhabhaTableData_getp_photon_id(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_photon_id(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BhabhaTableData_get_photon_id(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_photon_id(BhabhaTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BhabhaTableData_getp1_photon_id(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_primary_energy(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_primary_energy(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_primary_energy(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_primary_energy(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_primary_energy(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_photon_energy(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_photon_energy(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_photon_energy(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_photon_energy(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_photon_energy(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_photon_px(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_photon_px(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_photon_px(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_photon_px(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_photon_px(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_photon_py(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_photon_py(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_photon_py(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_photon_py(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_photon_py(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_photon_pzeta(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_photon_pzeta(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_photon_pzeta(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_photon_pzeta(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_photon_pzeta(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_theta_e(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_theta_e(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_theta_e(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_theta_e(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_theta_e(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BhabhaTableData_getp_theta_g(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BhabhaTableData_len_theta_g(BhabhaTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BhabhaTableData_get_theta_g(const BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BhabhaTableData_set_theta_g(BhabhaTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BhabhaTableData_getp1_theta_g(BhabhaTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_LumiTableData
#define XOBJ_TYPEDEF_LumiTableData
typedef   struct LumiTableData_s * LumiTableData;
 static inline LumiTableData LumiTableData_getp(LumiTableData restrict  obj){
  int64_t offset=0;
  return (LumiTableData)(( char*) obj+offset);
}
 static inline RecordIndex LumiTableData_getp__index(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_get__index_capacity(const LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set__index_capacity(LumiTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* LumiTableData_getp__index_capacity(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t LumiTableData_get__index_num_recorded(const LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set__index_num_recorded(LumiTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* LumiTableData_getp__index_num_recorded(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t LumiTableData_get__index__dummy(const LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set__index__dummy(LumiTableData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* LumiTableData_getp__index__dummy(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_get__index_buffer_id(const LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set__index_buffer_id(LumiTableData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* LumiTableData_getp__index_buffer_id(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 LumiTableData_getp_at_element(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_len_at_element(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=64;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t LumiTableData_get_at_element(const LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=64;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set_at_element(LumiTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=64;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* LumiTableData_getp1_at_element(LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=64;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 LumiTableData_getp_at_turn(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_len_at_turn(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t LumiTableData_get_at_turn(const LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set_at_turn(LumiTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* LumiTableData_getp1_at_turn(LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 LumiTableData_getp_particle_id(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_len_particle_id(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t LumiTableData_get_particle_id(const LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void LumiTableData_set_particle_id(LumiTableData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* LumiTableData_getp1_particle_id(LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 LumiTableData_getp_luminosity(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t LumiTableData_len_luminosity(LumiTableData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double LumiTableData_get_luminosity(const LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void LumiTableData_set_luminosity(LumiTableData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* LumiTableData_getp1_luminosity(LumiTableData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_BeamBeamBiGaussian2DData
#define XOBJ_TYPEDEF_BeamBeamBiGaussian2DData
typedef   struct BeamBeamBiGaussian2DData_s * BeamBeamBiGaussian2DData;
 static inline BeamBeamBiGaussian2DData BeamBeamBiGaussian2DData_getp(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  return (BeamBeamBiGaussian2DData)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_scale_strength(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_scale_strength(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_scale_strength(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_ref_shift_x(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_ref_shift_x(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_ref_shift_x(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_ref_shift_y(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_ref_shift_y(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=16;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_ref_shift_y(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_shift_x(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_shift_x(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=24;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_shift_x(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_shift_y(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_shift_y(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=32;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_shift_y(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_post_subtract_px(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_post_subtract_px(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=40;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_post_subtract_px(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_post_subtract_py(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_post_subtract_py(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=48;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_post_subtract_py(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_q0(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_q0(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=56;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_q0(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_beta0(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_beta0(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=64;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_beta0(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_num_particles(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_num_particles(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=72;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_num_particles(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=80;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_Sigma_11(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=80;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=80;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_Sigma_13(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=88;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_other_beam_Sigma_33(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=96;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian2DData_get_min_sigma_diff(const BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian2DData_set_min_sigma_diff(BeamBeamBiGaussian2DData restrict  obj, double value){
  int64_t offset=0;
  offset+=104;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian2DData_getp_min_sigma_diff(BeamBeamBiGaussian2DData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */


#ifndef XFIELDS_CONSTANTS_H
#define XFIELDS_CONSTANTS_H

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //


// classical electron radius [m]
#if !defined( RE )
    #define   RE ( 2.81794092e-15 )
#endif

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif

// from python scipy version 1.9.0: cst.elementary_charge
#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.8541878128e-12)
#endif

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif

// from python scipy version 1.9.0: cst.epsilon_0
#if !defined( QELEM )
    #define QELEM (1.602176634e-19)
#endif

#if !defined( MPROTON_GEV )
    #define MPROTON_GEV (0.93827208816)
#endif

#if !defined( MELECTRON_GEV )
    #define MELECTRON_GEV (0.00051099895000)
#endif

#if !defined( MELECTRON_KG )
    #define MELECTRON_KG (9.1093837015e-31)
#endif

#if !defined( ALPHA )
    #define ALPHA (7.29735257e-3)
#endif

#if !defined( HBAR_GEVS )
    #define HBAR_GEVS (6.582119569e-25)
#endif

#if !defined( TWO_OVER_SQRT_PI )
    #define TWO_OVER_SQRT_PI (1.128379167095512573896158903121545171688101258657997713688171443418)
#endif

#if !defined( SQRT_TWO )
    #define SQRT_TWO (1.414213562373095048801688724209698078569671875376948073176679738)
#endif

#if !defined( REDUCED_COMPTON_WAVELENGTH_ELECTRON )
    #define REDUCED_COMPTON_WAVELENGTH_ELECTRON (3.8615926796089057e-13)
#endif

#if !defined( REAL_EPSILON )
    #define REAL_EPSILON 2.22044604925031e-16
#endif /* !defined( REAL_EPSILON ) */

#endif /* XFIELDS_CONSTANTS_H */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_SINCOS_H__
#define XFIELDS_SINCOS_H__

#include <math.h> //only_for_context cpu_serial cpu_openmp

/* Define XSUITE_NO_SINCOS as a compiler parameter to never use the inline
 * wrapper function below (the compiler may still decide to use sincos - like
 * intrinsic, but usually enforcing that math functions have to update
 * errno should put an end to this.
 *
 * If XSUITE_NO_SINCOS is not set, then a best-effort attempt is made to
 * use it on platforms that support it (i.e. gnu compiler, no ANSI standards,
 * relaxed errno handling for math functions.
 */

#if ( !defined( XSUITE_NO_SINCOS ) ) && ( defined( __OPENCL_C_VERSION__ ) )
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    *sin_result = sincos( arg, cos_result ); }

#elif ( !defined( XSUITE_NO_SINCOS ) ) && \
      ( ( defined( __CUDA_ARCH__ ) ) || \
        ( defined( __GNUC__ ) && !defined( __clang__ ) && \
         !defined( __STRICT_ANSI__ ) && !defined( __INTEL_COMPILER ) && \
         defined( __NO_MATH_ERRNO__ ) ) )
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    sincos( arg, sin_result, cos_result ); }

#else
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    *sin_result = sin( arg );
    *cos_result = cos( arg ); }

#endif /* XSUITE_NO_SINCOS */
#endif /* XFIELDS_SINCOS_H__ */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_HEADERS_POWER_H_H__
#define XFIELDS_HEADERS_POWER_H_H__

/** \file power_n.h
 *  \note always include constants first!!! */

 static inline double power_n( double x, unsigned int n )
{
    #if defined( __OPENCL_VERSION__ )
    return pown( x, n );
    #else

    double x_n = x;

    unsigned int const n_div_16 = n >> 4u;
    unsigned int const n_mod_16 = n - ( n_div_16 << 4u );

    switch( n_mod_16 )
    {
        case  0u: { x_n = ( double )1.0; break; }
        case  1u: { break; }
        case  2u: { x_n *= x;                                       break; }
        case  3u: { x_n *= x * x;                                   break; }
        case  4u: { x_n *= x;     x_n *= x_n;                       break; }
        case  5u: { x_n *= x;     x_n *= x_n * x;                   break; }
        case  6u: { x_n *= x * x; x_n *= x_n;                       break; }
        case  7u: { x_n *= x * x; x_n *= x_n * x;                   break; }
        case  8u: { x_n *= x;     x_n *= x_n;     x_n *= x_n;       break; }
        case  9u: { x_n *= x * x; x_n *= x_n * x_n;                 break; }
        case 10u: { x_n *= x * x; x_n *= x_n * x_n * x;             break; }
        case 11u: { x_n *= x;     x_n *= x_n * x; x_n *= x_n * x;   break; }
        case 12u: { x_n *= x * x; x_n *= x_n;     x_n *= x_n;       break; }
        case 13u: { x_n *= x * x; x_n *= x_n;     x_n *= x_n * x;   break; }
        case 14u: { x_n *= x * x; x_n *= x_n * x; x_n *= x_n;       break; }
        case 15u: { x_n *= x;     x_n *= x_n * x; x_n *= x_n * x_n; break; }
        default:  { x_n = ( double )0.0; }
    };

    if( n_div_16 > 0u ){ x *= x; x *= x; x *= x; x *= x; }

    switch( n_div_16 )
    {
        case  0u: { x_n  = ( n_mod_16 != 0u ) ? x_n : ( double )1.0; break; }
        case  1u: { x_n *= x;                                           break; }
        case  2u: { x   *= x; x_n *= x;                                 break; }
        case  3u: { x_n *= x * x * x;                                   break; }
        case  4u: { x   *= x; x *= x; x_n *= x;                         break; }
        case  5u: { x_n *= x; x *= x; x *= x; x_n *= x;                 break; }
        case  6u: { x   *= x * x; x *= x; x_n *= x;                     break; }
        case  7u: { x_n *= x; x *= x * x; x *= x; x_n *= x;             break; }
        case  8u: { x *= x; x *= x; x*= x; x_n *= x;                    break; }
        case  9u: { x *= x * x; x *= x * x; x_n *= x;                   break; }
        case 10u: { x_n *= x; x *= x * x; x *= x * x; x_n *= x;         break; }
        case 11u: { x_n *= x * x; x *= x * x; x *= x * x; x_n *= x;     break; }
        case 12u: { x *= x; x *= x; x_n *= x; x *= x; x_n *= x;         break; }
        case 13u: { x_n *= x; x *= x; x *= x; x_n *= x; x *= x;
                    x_n *= x; break; }

        case 14u: { x_n *= x * x; x *= x; x *= x; x_n *= x; x *= x;
                    x_n *= x; break; }

        case 15u: { x *= x * x; x_n *= x * x; x *= x * x; x_n *= x;    break; }

        default:
        {
            unsigned int ii = 0u;
            unsigned int nn = n_div_16 % 16u;

            for( ; ii < nn ; ++ii ) x_n *= x;

            x *= x; x *= x; x *= x; x *= x;
            nn = ( n_div_16 - nn ) >> 4u;

            for( ii = 0u ; ii < nn ; ++ii ) x_n *= x;
        }
    };

    return x_n;
    #endif /* defined( __OPENCL_VERSION__ ) */
}

#endif /* XFIELDS_HEADERS_POWER_H_H__ */

// copyright ############################### //
// This file is part of the Xfields Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XFIELDS_PARTICLE_STATES_H
#define XFIELDS_PARTICLE_STATES_H

#define XF_OUTSIDE_INTERPOL -11
#define XF_TOO_MANY_PHOTONS -12

#endif /* XFIELDS_PARTICLE_STATES_H */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_FADDEEVA_H
#define XFIELDS_FADDEEVA_H


//from file: faddeeva_mit.h

//  -*- mode:c++; tab-width:2; indent-tabs-mode:nil;  -*-

/* Copyright (c) 2012 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* (Note that this file can be compiled with either C++, in which
    case it uses C++ std::complex<double>, or C, in which case it
    uses C99 double complex.) */

/* Available at: http://ab-initio.mit.edu/Faddeeva

   Computes various error functions (erf, erfc, erfi, erfcx),
   including the Dawson integral, in the complex plane, based
   on algorithms for the computation of the Faddeeva function
              w(z) = exp(-z^2) * erfc(-i*z).
   Given w(z), the error functions are mostly straightforward
   to compute, except for certain regions where we have to
   switch to Taylor expansions to avoid cancellation errors
   [e.g. near the origin for erf(z)].

   To compute the Faddeeva function, we use a combination of two
   algorithms:

   For sufficiently large |z|, we use a continued-fraction expansion
   for w(z) similar to those described in:

      Walter Gautschi, "Efficient computation of the complex error
      function," SIAM J. Numer. Anal. 7(1), pp. 187-198 (1970)

      G. P. M. Poppe and C. M. J. Wijers, "More efficient computation
      of the complex error function," ACM Trans. Math. Soft. 16(1),
      pp. 38-46 (1990).

   Unlike those papers, however, we switch to a completely different
   algorithm for smaller |z|:

      Mofreh R. Zaghloul and Ahmed N. Ali, "Algorithm 916: Computing the
      Faddeyeva and Voigt Functions," ACM Trans. Math. Soft. 38(2), 15
      (2011).

   (I initially used this algorithm for all z, but it turned out to be
    significantly slower than the continued-fraction expansion for
    larger |z|.  On the other hand, it is competitive for smaller |z|,
    and is significantly more accurate than the Poppe & Wijers code
    in some regions, e.g. in the vicinity of z=1+1i.)

   Note that this is an INDEPENDENT RE-IMPLEMENTATION of these algorithms,
   based on the description in the papers ONLY.  In particular, I did
   not refer to the authors' Fortran or Matlab implementations, respectively,
   (which are under restrictive ACM copyright terms and therefore unusable
    in free/open-source software).

   Steven G. Johnson, Massachusetts Institute of Technology
   http://math.mit.edu/~stevenj
   October 2012.

    -- Note that Algorithm 916 assumes that the erfc(x) function,
       or rather the scaled function erfcx(x) = exp(x*x)*erfc(x),
       is supplied for REAL arguments x.   I originally used an
       erfcx routine derived from DERFC in SLATEC, but I have
       since replaced it with a much faster routine written by
       me which uses a combination of continued-fraction expansions
       and a lookup table of Chebyshev polynomials.  For speed,
       I implemented a similar algorithm for Im[w(x)] of real x,
       since this comes up frequently in the other error functions.

   A small test program is included the end, which checks
   the w(z) etc. results against several known values.  To compile
   the test function, compile with -DTEST_FADDEEVA (that is,
   #define TEST_FADDEEVA).

   If HAVE_CONFIG_H is #defined (e.g. by compiling with -DHAVE_CONFIG_H),
   then we #include "config.h", which is assumed to be a GNU autoconf-style
   header defining HAVE_* macros to indicate the presence of features. In
   particular, if HAVE_ISNAN and HAVE_ISINF are #defined, we use those
   functions in math.h instead of defining our own, and if HAVE_ERF and/or
   HAVE_ERFC are defined we use those functions from <cmath> for erf and
   erfc of real arguments, respectively, instead of defining our own.

   REVISION HISTORY:
       4 October 2012: Initial public release (SGJ)
       5 October 2012: Revised (SGJ) to fix spelling error,
                       start summation for large x at round(x/a) (> 1)
                       rather than ceil(x/a) as in the original
                       paper, which should slightly improve performance
                       (and, apparently, slightly improves accuracy)
      19 October 2012: Revised (SGJ) to fix bugs for large x, large -y,
                       and 15<x<26. Performance improvements. Prototype
                       now supplies default value for relerr.
      24 October 2012: Switch to continued-fraction expansion for
                       sufficiently large z, for performance reasons.
                       Also, avoid spurious overflow for |z| > 1e154.
                       Set relerr argument to min(relerr,0.1).
      27 October 2012: Enhance accuracy in Re[w(z)] taken by itself,
                       by switching to Alg. 916 in a region near
                       the real-z axis where continued fractions
                       have poor relative accuracy in Re[w(z)].  Thanks
                       to M. Zaghloul for the tip.
      29 October 2012: Replace SLATEC-derived erfcx routine with
                       completely rewritten code by me, using a very
                       different algorithm which is much faster.
      30 October 2012: Implemented special-case code for real z
                       (where real part is exp(-x^2) and imag part is
                        Dawson integral), using algorithm similar to erfx.
                       Export ImFaddeeva_w function to make Dawson's
                       integral directly accessible.
      3 November 2012: Provide implementations of erf, erfc, erfcx,
                       and Dawson functions in Faddeeva:: namespace,
                       in addition to Faddeeva::w.  Provide header
                       file Faddeeva.hh.
      4 November 2012: Slightly faster erf for real arguments.
                       Updated MATLAB and Octave plugins.
     27 November 2012: Support compilation with either C++ or
                       plain C (using C99 complex numbers).
                       For real x, use standard-library erf(x)
                       and erfc(x) if available (for C99 or C++11).
                       #include "config.h" if HAVE_CONFIG_H is #defined.
     15 December 2012: Portability fixes (copysign, Inf/NaN creation),
                       use CMPLX/__builtin_complex if available in C,
                       slight accuracy improvements to erf and dawson
                       functions near the origin.  Use gnulib functions
                       if GNULIB_NAMESPACE is defined.
     18 December 2012: Slight tweaks (remove recomputation of x*x in Dawson)
          12 May 2015: Bugfix for systems lacking copysign function.
*/

/////////////////////////////////////////////////////////////////////////
/* If this file is compiled as a part of a larger project,
   support using an autoconf-style config.h header file
   (with various "HAVE_*" #defines to indicate features)
   if HAVE_CONFIG_H is #defined (in GNU autotools style). */

#ifndef XFIELDS_FADDEEVA_MIT_H
#define XFIELDS_FADDEEVA_MIT_H

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

/////////////////////////////////////////////////////////////////////////
// macros to allow us to use either C++ or C (with C99 features)


// #  include "Faddeeva.h" # I include the full header here
/* Copyright (c) 2012 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* Available at: http://ab-initio.mit.edu/Faddeeva

   Header file for Faddeeva.c; see Faddeeva.cc for more information. */


// Require C99 complex-number support
#include <complex.h>


// compute w(z) = exp(-z^2) erfc(-iz) [ Faddeeva / scaled complex error func ]
static inline double complex Faddeeva_MIT_w(double complex z, double relerr);
double Faddeeva_MIT_w_im(double x); // special-case code for Im[w(x)] of real x

// Various functions that we can compute with the help of w(z)

// compute erfcx(z) = exp(z^2) erfc(z)
double complex Faddeeva_MIT_erfcx(double complex z, double relerr);
double Faddeeva_MIT_erfcx_re(double x); // special case for real x

// compute erf(z), the error function of complex arguments
double complex Faddeeva_MIT_erf(double complex z, double relerr);
double Faddeeva_MIT_erf_re(double x); // special case for real x

// compte erfi(z) = -i erf(iz), the imaginary error function
double complex Faddeeva_MIT_erfi(double complex z, double relerr);
double Faddeeva_MIT_erfi_re(double x); // special case for real x

// compute erfc(z) = 1 - erf(z), the complementary error function
double complex Faddeeva_MIT_erfc(double complex z, double relerr);
double Faddeeva_MIT_erfc_re(double x); // special case for real x

// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
double complex Faddeeva_MIT_Dawson(double complex z, double relerr);
double Faddeeva_MIT_Dawson_re(double x); // special case for real x


 static inline void faddeeva_w( double x, double y,
    double*  restrict  out_x, double*  restrict  out_y )
{
    double complex z, W;
    z = x + I * y;
    W = Faddeeva_MIT_w(z, 0);
    *out_x = creal(W);
    *out_y = cimag(W);
}

 static inline void faddeeva_w_q1( double x, double y,
    double*  restrict  out_x, double*  restrict  out_y )
{
    faddeeva_w(x, y, out_x, out_y);
}


#  define _GNU_SOURCE // enable GNU libc NAN extension if possible

#  include <float.h>
#  include <math.h>

typedef double complex cmplx;

#  define FADDEEVA(name) Faddeeva_MIT_ ## name
#  define FADDEEVA_RE(name) Faddeeva_MIT_ ## name ## _re

/* Constructing complex numbers like 0+i*NaN is problematic in C99
   without the C11 CMPLX macro, because 0.+I*NAN may give NaN+i*NAN if
   I is a complex (rather than imaginary) constant.  For some reason,
   however, it works fine in (pre-4.7) gcc if I define Inf and NaN as
   1/0 and 0/0 (and only if I compile with optimization -O1 or more),
   but not if I use the INFINITY or NAN macros. */

/* __builtin_complex was introduced in gcc 4.7, but the C11 CMPLX macro
   may not be defined unless we are using a recent (2012) version of
   glibc and compile with -std=c11... note that icc lies about being
   gcc and probably doesn't have this builtin(?), so exclude icc explicitly */
#  if !defined(CMPLX) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)) && !(defined(__ICC) || defined(__INTEL_COMPILER))
#    define CMPLX(a,b) __builtin_complex((double) (a), (double) (b))
#  endif

#  ifdef CMPLX // C11
#    define C(a,b) CMPLX(a,b)
#    define Inf INFINITY // C99 infinity
#    ifdef NAN // GNU libc extension
#      define NaN NAN
#    else
#      define NaN (0./0.) // NaN
#    endif
#  else
#    define C(a,b) ((a) + I*(b))
#    define Inf (1./0.)
#    define NaN (0./0.)
#  endif

static inline cmplx cpolar(double r, double t)
{
  if (r == 0.0 && !isnan(t))
    return 0.0;
  else
    return C(r * cos(t), r * sin(t));
}


/////////////////////////////////////////////////////////////////////////
// Auxiliary routines to compute other special functions based on w(z)

// compute erfcx(z) = exp(z^2) erfz(z)
cmplx FADDEEVA(erfcx)(cmplx z, double relerr)
{
  return FADDEEVA(w)(C(-cimag(z), creal(z)), relerr);
}

// compute the error function erf(x)
double FADDEEVA_RE(erf)(double x)
{
#if !defined(__cplusplus)
  return erf(x); // C99 supplies erf in math.h
#elif (__cplusplus >= 201103L) || defined(HAVE_ERF)
  return ::erf(x); // C++11 supplies std::erf in cmath
#else
  double mx2 = -x*x;
  if (mx2 < -750) // underflow
    return (x >= 0 ? 1.0 : -1.0);

  if (x >= 0) {
    if (x < 8e-2) goto taylor;
    return 1.0 - exp(mx2) * FADDEEVA_RE(erfcx)(x);
  }
  else { // x < 0
    if (x > -8e-2) goto taylor;
    return exp(mx2) * FADDEEVA_RE(erfcx)(-x) - 1.0;
  }

  // Use Taylor series for small |x|, to avoid cancellation inaccuracy
  //   erf(x) = 2/sqrt(pi) * x * (1 - x^2/3 + x^4/10 - x^6/42 + x^8/216 + ...)
 taylor:
  return x * (1.1283791670955125739
              + mx2 * (0.37612638903183752464
                       + mx2 * (0.11283791670955125739
                                + mx2 * (0.026866170645131251760
                                         + mx2 * 0.0052239776254421878422))));
#endif
}

// compute the error function erf(z)
cmplx FADDEEVA(erf)(cmplx z, double relerr)
{
  double x = creal(z), y = cimag(z);

  if (y == 0)
    return C(FADDEEVA_RE(erf)(x),
             y); // preserve sign of 0
  if (x == 0) // handle separately for speed & handling of y = Inf or NaN
    return C(x, // preserve sign of 0
             /* handle y -> Inf limit manually, since
                exp(y^2) -> Inf but Im[w(y)] -> 0, so
                IEEE will give us a NaN when it should be Inf */
             y*y > 720 ? (y > 0 ? Inf : -Inf)
             : exp(y*y) * FADDEEVA(w_im)(y));

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  if (mRe_z2 < -750) // underflow
    return (x >= 0 ? 1.0 : -1.0);

  /* Handle positive and negative x via different formulas,
     using the mirror symmetries of w, to avoid overflow/underflow
     problems from multiplying exponentially large and small quantities. */
  if (x >= 0) {
    if (x < 8e-2) {
      if (fabs(y) < 1e-2)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3 && x < 5e-3)
        goto taylor_erfi;
    }
    /* don't use complex exp function, since that will produce spurious NaN
       values when multiplying w in an overflow situation. */
    return 1.0 - exp(mRe_z2) *
      (C(cos(mIm_z2), sin(mIm_z2))
       * FADDEEVA(w)(C(-y,x), relerr));
  }
  else { // x < 0
    if (x > -8e-2) { // duplicate from above to avoid fabs(x) call
      if (fabs(y) < 1e-2)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3 && x > -5e-3)
        goto taylor_erfi;
    }
    else if (isnan(x))
      return C(NaN, y == 0 ? 0 : NaN);
    /* don't use complex exp function, since that will produce spurious NaN
       values when multiplying w in an overflow situation. */
    return exp(mRe_z2) *
      (C(cos(mIm_z2), sin(mIm_z2))
       * FADDEEVA(w)(C(y,-x), relerr)) - 1.0;
  }

  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
  //   erf(z) = 2/sqrt(pi) * z * (1 - z^2/3 + z^4/10 - z^6/42 + z^8/216 + ...)
 taylor:
  {
    cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2
    return z * (1.1283791670955125739
                + mz2 * (0.37612638903183752464
                         + mz2 * (0.11283791670955125739
                                  + mz2 * (0.026866170645131251760
                                          + mz2 * 0.0052239776254421878422))));
  }

  /* for small |x| and small |xy|,
     use Taylor series to avoid cancellation inaccuracy:
       erf(x+iy) = erf(iy)
          + 2*exp(y^2)/sqrt(pi) *
            [ x * (1 - x^2 * (1+2y^2)/3 + x^4 * (3+12y^2+4y^4)/30 + ...
              - i * x^2 * y * (1 - x^2 * (3+2y^2)/6 + ...) ]
     where:
        erf(iy) = exp(y^2) * Im[w(y)]
  */
 taylor_erfi:
  {
    double x2 = x*x, y2 = y*y;
    double expy2 = exp(y2);
    return C
      (expy2 * x * (1.1283791670955125739
                    - x2 * (0.37612638903183752464
                            + 0.75225277806367504925*y2)
                    + x2*x2 * (0.11283791670955125739
                               + y2 * (0.45135166683820502956
                                       + 0.15045055561273500986*y2))),
       expy2 * (FADDEEVA(w_im)(y)
                - x2*y * (1.1283791670955125739
                          - x2 * (0.56418958354775628695
                                  + 0.37612638903183752464*y2))));
  }
}

// erfi(z) = -i erf(iz)
cmplx FADDEEVA(erfi)(cmplx z, double relerr)
{
  cmplx e = FADDEEVA(erf)(C(-cimag(z),creal(z)), relerr);
  return C(cimag(e), -creal(e));
}

// erfi(x) = -i erf(ix)
double FADDEEVA_RE(erfi)(double x)
{
  return x*x > 720 ? (x > 0 ? Inf : -Inf)
    : exp(x*x) * FADDEEVA(w_im)(x);
}

// erfc(x) = 1 - erf(x)
double FADDEEVA_RE(erfc)(double x)
{
#if !defined(__cplusplus)
  return erfc(x); // C99 supplies erfc in math.h
#elif (__cplusplus >= 201103L) || defined(HAVE_ERFC)
  return ::erfc(x); // C++11 supplies std::erfc in cmath
#else
  if (x*x > 750) // underflow
    return (x >= 0 ? 0.0 : 2.0);
  return x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x)
    : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x);
#endif
}

// erfc(z) = 1 - erf(z)
cmplx FADDEEVA(erfc)(cmplx z, double relerr)
{
  double x = creal(z), y = cimag(z);

  if (x == 0.)
    return C(1,
             /* handle y -> Inf limit manually, since
                exp(y^2) -> Inf but Im[w(y)] -> 0, so
                IEEE will give us a NaN when it should be Inf */
             y*y > 720 ? (y > 0 ? -Inf : Inf)
             : -exp(y*y) * FADDEEVA(w_im)(y));
  if (y == 0.) {
    if (x*x > 750) // underflow
      return C(x >= 0 ? 0.0 : 2.0,
               -y); // preserve sign of 0
    return C(x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x)
             : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x),
             -y); // preserve sign of zero
  }

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  if (mRe_z2 < -750) // underflow
    return (x >= 0 ? 0.0 : 2.0);

  if (x >= 0)
    return cexp(C(mRe_z2, mIm_z2))
      * FADDEEVA(w)(C(-y,x), relerr);
  else
    return 2.0 - cexp(C(mRe_z2, mIm_z2))
      * FADDEEVA(w)(C(y,-x), relerr);
}

// compute Dawson(x) = sqrt(pi)/2  *  exp(-x^2) * erfi(x)
double FADDEEVA_RE(Dawson)(double x)
{
  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
  return spi2 * FADDEEVA(w_im)(x);
}

// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
cmplx FADDEEVA(Dawson)(cmplx z, double relerr)
{
  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
  double x = creal(z), y = cimag(z);

  // handle axes separately for speed & proper handling of x or y = Inf or NaN
  if (y == 0)
    return C(spi2 * FADDEEVA(w_im)(x),
             -y); // preserve sign of 0
  if (x == 0) {
    double y2 = y*y;
    if (y2 < 2.5e-5) { // Taylor expansion
      return C(x, // preserve sign of 0
               y * (1.
                    + y2 * (0.6666666666666666666666666666666666666667
                            + y2 * 0.26666666666666666666666666666666666667)));
    }
    return C(x, // preserve sign of 0
             spi2 * (y >= 0
                     ? exp(y2) - FADDEEVA_RE(erfcx)(y)
                     : FADDEEVA_RE(erfcx)(-y) - exp(y2)));
  }

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2

  /* Handle positive and negative x via different formulas,
     using the mirror symmetries of w, to avoid overflow/underflow
     problems from multiplying exponentially large and small quantities. */
  if (y >= 0) {
    if (y < 5e-3) {
      if (fabs(x) < 5e-3)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3)
        goto taylor_realaxis;
    }
    cmplx res = cexp(mz2) - FADDEEVA(w)(z, relerr);
    return spi2 * C(-cimag(res), creal(res));
  }
  else { // y < 0
    if (y > -5e-3) { // duplicate from above to avoid fabs(x) call
      if (fabs(x) < 5e-3)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3)
        goto taylor_realaxis;
    }
    else if (isnan(y))
      return C(x == 0 ? 0 : NaN, NaN);
    cmplx res = FADDEEVA(w)(-z, relerr) - cexp(mz2);
    return spi2 * C(-cimag(res), creal(res));
  }

  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
  //     dawson(z) = z - 2/3 z^3 + 4/15 z^5 + ...
 taylor:
  return z * (1.
              + mz2 * (0.6666666666666666666666666666666666666667
                       + mz2 * 0.2666666666666666666666666666666666666667));

  /* for small |y| and small |xy|,
     use Taylor series to avoid cancellation inaccuracy:
       dawson(x + iy)
        = D + y^2 (D + x - 2Dx^2)
            + y^4 (D/2 + 5x/6 - 2Dx^2 - x^3/3 + 2Dx^4/3)
        + iy [ (1-2Dx) + 2/3 y^2 (1 - 3Dx - x^2 + 2Dx^3)
              + y^4/15 (4 - 15Dx - 9x^2 + 20Dx^3 + 2x^4 - 4Dx^5) ] + ...
     where D = dawson(x)

     However, for large |x|, 2Dx -> 1 which gives cancellation problems in
     this series (many of the leading terms cancel).  So, for large |x|,
     we need to substitute a continued-fraction expansion for D.

        dawson(x) = 0.5 / (x-0.5/(x-1/(x-1.5/(x-2/(x-2.5/(x...))))))

     The 6 terms shown here seems to be the minimum needed to be
     accurate as soon as the simpler Taylor expansion above starts
     breaking down.  Using this 6-term expansion, factoring out the
     denominator, and simplifying with Maple, we obtain:

      Re dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / x
        = 33 - 28x^2 + 4x^4 + y^2 (18 - 4x^2) + 4 y^4
      Im dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / y
        = -15 + 24x^2 - 4x^4 + 2/3 y^2 (6x^2 - 15) - 4 y^4

     Finally, for |x| > 5e7, we can use a simpler 1-term continued-fraction
     expansion for the real part, and a 2-term expansion for the imaginary
     part.  (This avoids overflow problems for huge |x|.)  This yields:

     Re dawson(x + iy) = [1 + y^2 (1 + y^2/2 - (xy)^2/3)] / (2x)
     Im dawson(x + iy) = y [ -1 - 2/3 y^2 + y^4/15 (2x^2 - 4) ] / (2x^2 - 1)

 */
 taylor_realaxis:
  {
    double x2 = x*x;
    if (x2 > 1600) { // |x| > 40
      double y2 = y*y;
      if (x2 > 25e14) {// |x| > 5e7
        double xy2 = (x*y)*(x*y);
        return C((0.5 + y2 * (0.5 + 0.25*y2
                              - 0.16666666666666666667*xy2)) / x,
                 y * (-1 + y2 * (-0.66666666666666666667
                                 + 0.13333333333333333333*xy2
                                 - 0.26666666666666666667*y2))
                 / (2*x2 - 1));
      }
      return (1. / (-15 + x2*(90 + x2*(-60 + 8*x2)))) *
        C(x * (33 + x2 * (-28 + 4*x2)
               + y2 * (18 - 4*x2 + 4*y2)),
          y * (-15 + x2 * (24 - 4*x2)
               + y2 * (4*x2 - 10 - 4*y2)));
    }
    else {
      double D = spi2 * FADDEEVA(w_im)(x);
      double y2 = y*y;
      return C
        (D + y2 * (D + x - 2*D*x2)
         + y2*y2 * (D * (0.5 - x2 * (2 - 0.66666666666666666667*x2))
                    + x * (0.83333333333333333333
                           - 0.33333333333333333333 * x2)),
         y * (1 - 2*D*x
              + y2 * 0.66666666666666666667 * (1 - x2 - D*x * (3 - 2*x2))
              + y2*y2 * (0.26666666666666666667 -
                         x2 * (0.6 - 0.13333333333333333333 * x2)
                         - D*x * (1 - x2 * (1.3333333333333333333
                                            - 0.26666666666666666667 * x2)))));
    }
  }
}

/////////////////////////////////////////////////////////////////////////

// return sinc(x) = sin(x)/x, given both x and sin(x)
// [since we only use this in cases where sin(x) has already been computed]
static inline double sinc(double x, double sinx) {
  return fabs(x) < 1e-4 ? 1 - (0.1666666666666666666667)*x*x : sinx / x;
}

// sinh(x) via Taylor series, accurate to machine precision for |x| < 1e-2
static inline double sinh_taylor(double x) {
  return x * (1 + (x*x) * (0.1666666666666666666667
                           + 0.00833333333333333333333 * (x*x)));
}

static inline double sqr(double x) { return x*x; }

// precomputed table of expa2n2[n-1] = exp(-a2*n*n)
// for double-precision a2 = 0.26865... in FADDEEVA(w), below.
static const double expa2n2[] = {
  7.64405281671221563e-01,
  3.41424527166548425e-01,
  8.91072646929412548e-02,
  1.35887299055460086e-02,
  1.21085455253437481e-03,
  6.30452613933449404e-05,
  1.91805156577114683e-06,
  3.40969447714832381e-08,
  3.54175089099469393e-10,
  2.14965079583260682e-12,
  7.62368911833724354e-15,
  1.57982797110681093e-17,
  1.91294189103582677e-20,
  1.35344656764205340e-23,
  5.59535712428588720e-27,
  1.35164257972401769e-30,
  1.90784582843501167e-34,
  1.57351920291442930e-38,
  7.58312432328032845e-43,
  2.13536275438697082e-47,
  3.51352063787195769e-52,
  3.37800830266396920e-57,
  1.89769439468301000e-62,
  6.22929926072668851e-68,
  1.19481172006938722e-73,
  1.33908181133005953e-79,
  8.76924303483223939e-86,
  3.35555576166254986e-92,
  7.50264110688173024e-99,
  9.80192200745410268e-106,
  7.48265412822268959e-113,
  3.33770122566809425e-120,
  8.69934598159861140e-128,
  1.32486951484088852e-135,
  1.17898144201315253e-143,
  6.13039120236180012e-152,
  1.86258785950822098e-160,
  3.30668408201432783e-169,
  3.43017280887946235e-178,
  2.07915397775808219e-187,
  7.36384545323984966e-197,
  1.52394760394085741e-206,
  1.84281935046532100e-216,
  1.30209553802992923e-226,
  5.37588903521080531e-237,
  1.29689584599763145e-247,
  1.82813078022866562e-258,
  1.50576355348684241e-269,
  7.24692320799294194e-281,
  2.03797051314726829e-292,
  3.34880215927873807e-304,
  0.0 // underflow (also prevents reads past array end, below)
};

/////////////////////////////////////////////////////////////////////////

static inline cmplx FADDEEVA(w)(cmplx z, double relerr)
{
  if (creal(z) == 0.0)
    return C(FADDEEVA_RE(erfcx)(cimag(z)),
             creal(z)); // give correct sign of 0 in cimag(w)
  else if (cimag(z) == 0)
    return C(exp(-sqr(creal(z))),
             FADDEEVA(w_im)(creal(z)));

  double a, a2, c;
  if (relerr <= DBL_EPSILON) {
    relerr = DBL_EPSILON;
    a = 0.518321480430085929872; // pi / sqrt(-log(eps*0.5))
    c = 0.329973702884629072537; // (2/pi) * a;
    a2 = 0.268657157075235951582; // a^2
  }
  else {
    const double pi = 3.14159265358979323846264338327950288419716939937510582;
    if (relerr > 0.1) relerr = 0.1; // not sensible to compute < 1 digit
    a = pi / sqrt(-log(relerr*0.5));
    c = (2/pi)*a;
    a2 = a*a;
  }
  const double x = fabs(creal(z));
  const double y = cimag(z), ya = fabs(y);

  cmplx ret = 0.; // return value

  double sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0;

#define USE_CONTINUED_FRACTION 1 // 1 to use continued fraction for large |z|

#if USE_CONTINUED_FRACTION
  if (ya > 7 || (x > 6  // continued fraction is faster
                 /* As pointed out by M. Zaghloul, the continued
                    fraction seems to give a large relative error in
                    Re w(z) for |x| ~ 6 and small |y|, so use
                    algorithm 816 in this region: */
                 && (ya > 0.1 || (x > 8 && ya > 1e-10) || x > 28))) {

    /* Poppe & Wijers suggest using a number of terms
           nu = 3 + 1442 / (26*rho + 77)
       where rho = sqrt((x/x0)^2 + (y/y0)^2) where x0=6.3, y0=4.4.
       (They only use this expansion for rho >= 1, but rho a little less
        than 1 seems okay too.)
       Instead, I did my own fit to a slightly different function
       that avoids the hypotenuse calculation, using NLopt to minimize
       the sum of the squares of the errors in nu with the constraint
       that the estimated nu be >= minimum nu to attain machine precision.
       I also separate the regions where nu == 2 and nu == 1. */
    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
    if (x + ya > 4000) { // nu <= 2
      if (x + ya > 1e7) { // nu == 1, w(z) = i/sqrt(pi) / z
        // scale to avoid overflow
        if (x > ya) {
          double yax = ya / xs;
          double denom = ispi / (xs + yax*ya);
          ret = C(denom*yax, denom);
        }
        else if (isinf(ya))
          return ((isnan(x) || y < 0)
                  ? C(NaN,NaN) : C(0,0));
        else {
          double xya = xs / ya;
          double denom = ispi / (xya*xs + ya);
          ret = C(denom, denom*xya);
        }
      }
      else { // nu == 2, w(z) = i/sqrt(pi) * z / (z*z - 0.5)
        double dr = xs*xs - ya*ya - 0.5, di = 2*xs*ya;
        double denom = ispi / (dr*dr + di*di);
        ret = C(denom * (xs*di-ya*dr), denom * (xs*dr+ya*di));
      }
    }
    else { // compute nu(z) estimate and do general continued fraction
      const double c0=3.9, c1=11.398, c2=0.08254, c3=0.1421, c4=0.2023; // fit
      double nu = floor(c0 + c1 / (c2*x + c3*ya + c4));
      double wr = xs, wi = ya;
      for (nu = 0.5 * (nu - 1); nu > 0.4; nu -= 0.5) {
        // w <- z - nu/w:
        double denom = nu / (wr*wr + wi*wi);
        wr = xs - wr * denom;
        wi = ya + wi * denom;
      }
      { // w(z) = i/sqrt(pi) / w:
        double denom = ispi / (wr*wr + wi*wi);
        ret = C(denom*wi, denom*wr);
      }
    }
    if (y < 0) {
      // use w(z) = 2.0*exp(-z*z) - w(-z),
      // but be careful of overflow in exp(-z*z)
      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya)
      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
    }
    else
      return ret;
  }
#else // !USE_CONTINUED_FRACTION
  if (x + ya > 1e7) { // w(z) = i/sqrt(pi) / z, to machine precision
    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
    // scale to avoid overflow
    if (x > ya) {
      double yax = ya / xs;
      double denom = ispi / (xs + yax*ya);
      ret = C(denom*yax, denom);
    }
    else {
      double xya = xs / ya;
      double denom = ispi / (xya*xs + ya);
      ret = C(denom, denom*xya);
    }
    if (y < 0) {
      // use w(z) = 2.0*exp(-z*z) - w(-z),
      // but be careful of overflow in exp(-z*z)
      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya)
      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
    }
    else
      return ret;
  }
#endif // !USE_CONTINUED_FRACTION

  /* Note: The test that seems to be suggested in the paper is x <
     sqrt(-log(DBL_MIN)), about 26.6, since otherwise exp(-x^2)
     underflows to zero and sum1,sum2,sum4 are zero.  However, long
     before this occurs, the sum1,sum2,sum4 contributions are
     negligible in double precision; I find that this happens for x >
     about 6, for all y.  On the other hand, I find that the case
     where we compute all of the sums is faster (at least with the
     precomputed expa2n2 table) until about x=10.  Furthermore, if we
     try to compute all of the sums for x > 20, I find that we
     sometimes run into numerical problems because underflow/overflow
     problems start to appear in the various coefficients of the sums,
     below.  Therefore, we use x < 10 here. */
  else if (x < 10) {
    double prod2ax = 1, prodm2ax = 1;
    double expx2;

    if (isnan(y))
      return C(y,y);

    /* Somewhat ugly copy-and-paste duplication here, but I see significant
       speedups from using the special-case code with the precomputed
       exponential, and the x < 5e-4 special case is needed for accuracy. */

    if (relerr == DBL_EPSILON) { // use precomputed exp(-a2*(n*n)) table
      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
        const double x2 = x*x;
        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
        // compute exp(2*a*x) and exp(-2*a*x) via Taylor, to double precision
        const double ax2 = 1.036642960860171859744*x; // 2*a*x
        const double exp2ax =
          1 + ax2 * (1 + ax2 * (0.5 + 0.166666666666666666667*ax2));
        const double expm2ax =
          1 - ax2 * (1 - ax2 * (0.5 - 0.166666666666666666667*ax2));
        for (int n = 1; 1; ++n) {
          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum3 += coef * prod2ax;

          // really = sum5 - sum4
          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);

          // test convergence via sum3
          if (coef * prod2ax < relerr * sum3) break;
        }
      }
      else { // x > 5e-4, compute sum4 and sum5 separately
        expx2 = exp(-x*x);
        const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
        for (int n = 1; 1; ++n) {
          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum4 += (coef * prodm2ax) * (a*n);
          sum3 += coef * prod2ax;
          sum5 += (coef * prod2ax) * (a*n);
          // test convergence via sum5, since this sum has the slowest decay
          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
        }
      }
    }
    else { // relerr != DBL_EPSILON, compute exp(-a2*(n*n)) on the fly
      const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
        const double x2 = x*x;
        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
        for (int n = 1; 1; ++n) {
          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum3 += coef * prod2ax;

          // really = sum5 - sum4
          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);

          // test convergence via sum3
          if (coef * prod2ax < relerr * sum3) break;
        }
      }
      else { // x > 5e-4, compute sum4 and sum5 separately
        expx2 = exp(-x*x);
        for (int n = 1; 1; ++n) {
          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum4 += (coef * prodm2ax) * (a*n);
          sum3 += coef * prod2ax;
          sum5 += (coef * prod2ax) * (a*n);
          // test convergence via sum5, since this sum has the slowest decay
          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
        }
      }
    }
    const double expx2erfcxy = // avoid spurious overflow for large negative y
      y > -6 // for y < -6, erfcx(y) = 2*exp(y*y) to double precision
      ? expx2*FADDEEVA_RE(erfcx)(y) : 2*exp(y*y-x*x);
    if (y > 5) { // imaginary terms cancel
      const double sinxy = sin(x*y);
      ret = (expx2erfcxy - c*y*sum1) * cos(2*x*y)
        + (c*x*expx2) * sinxy * sinc(x*y, sinxy);
    }
    else {
      double xs = creal(z);
      const double sinxy = sin(xs*y);
      const double sin2xy = sin(2*xs*y), cos2xy = cos(2*xs*y);
      const double coef1 = expx2erfcxy - c*y*sum1;
      const double coef2 = c*xs*expx2;
      ret = C(coef1 * cos2xy + coef2 * sinxy * sinc(xs*y, sinxy),
              coef2 * sinc(2*xs*y, sin2xy) - coef1 * sin2xy);
    }
  }
  else { // x large: only sum3 & sum5 contribute (see above note)
    if (isnan(x))
      return C(x,x);
    if (isnan(y))
      return C(y,y);

#if USE_CONTINUED_FRACTION
    ret = exp(-x*x); // |y| < 1e-10, so we only need exp(-x*x) term
#else
    if (y < 0) {
      /* erfcx(y) ~ 2*exp(y*y) + (< 1) if y < 0, so
         erfcx(y)*exp(-x*x) ~ 2*exp(y*y-x*x) term may not be negligible
         if y*y - x*x > -36 or so.  So, compute this term just in case.
         We also need the -exp(-x*x) term to compute Re[w] accurately
         in the case where y is very small. */
      ret = cpolar(2*exp(y*y-x*x) - exp(-x*x), -2*creal(z)*y);
    }
    else
      ret = exp(-x*x); // not negligible in real part if y very small
#endif
    // (round instead of ceil as in original paper; note that x/a > 1 here)
    double n0 = floor(x/a + 0.5); // sum in both directions, starting at n0
    double dx = a*n0 - x;
    sum3 = exp(-dx*dx) / (a2*(n0*n0) + y*y);
    sum5 = a*n0 * sum3;
    double exp1 = exp(4*a*dx), exp1dn = 1;
    int dn;
    for (dn = 1; n0 - dn > 0; ++dn) { // loop over n0-dn and n0+dn terms
      double np = n0 + dn, nm = n0 - dn;
      double tp = exp(-sqr(a*dn+dx));
      double tm = tp * (exp1dn *= exp1); // trick to get tm from tp
      tp /= (a2*(np*np) + y*y);
      tm /= (a2*(nm*nm) + y*y);
      sum3 += tp + tm;
      sum5 += a * (np * tp + nm * tm);
      if (a * (np * tp + nm * tm) < relerr * sum5) goto finish;
    }
    while (1) { // loop over n0+dn terms only (since n0-dn <= 0)
      double np = n0 + dn++;
      double tp = exp(-sqr(a*dn+dx)) / (a2*(np*np) + y*y);
      sum3 += tp;
      sum5 += a * np * tp;
      if (a * np * tp < relerr * sum5) goto finish;
    }
  }
 finish:
  return ret + C((0.5*c)*y*(sum2+sum3),
                 (0.5*c)*copysign(sum5-sum4, creal(z)));
}

/////////////////////////////////////////////////////////////////////////

/* erfcx(x) = exp(x^2) erfc(x) function, for real x, written by
   Steven G. Johnson, October 2012.

   This function combines a few different ideas.

   First, for x > 50, it uses a continued-fraction expansion (same as
   for the Faddeeva function, but with algebraic simplifications for z=i*x).

   Second, for 0 <= x <= 50, it uses Chebyshev polynomial approximations,
   but with two twists:

      a) It maps x to y = 4 / (4+x) in [0,1].  This simple transformation,
         inspired by a similar transformation in the octave-forge/specfun
         erfcx by Soren Hauberg, results in much faster Chebyshev convergence
         than other simple transformations I have examined.

      b) Instead of using a single Chebyshev polynomial for the entire
         [0,1] y interval, we break the interval up into 100 equal
         subintervals, with a switch/lookup table, and use much lower
         degree Chebyshev polynomials in each subinterval. This greatly
         improves performance in my tests.

   For x < 0, we use the relationship erfcx(-x) = 2 exp(x^2) - erfc(x),
   with the usual checks for overflow etcetera.

   Performance-wise, it seems to be substantially faster than either
   the SLATEC DERFC function [or an erfcx function derived therefrom]
   or Cody's CALERF function (from netlib.org/specfun), while
   retaining near machine precision in accuracy.  */

/* Given y100=100*y, where y = 4/(4+x) for x >= 0, compute erfc(x).

   Uses a look-up table of 100 different Chebyshev polynomials
   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
   with the help of Maple and a little shell script.   This allows
   the Chebyshev polynomials to be of significantly lower degree (about 1/4)
   compared to fitting the whole [0,1] interval with a single polynomial. */
static double erfcx_y100(double y100)
{
  switch ((int) y100) {
case 0: {
double t = 2*y100 - 1;
return 0.70878032454106438663e-3 + (0.71234091047026302958e-3 + (0.35779077297597742384e-5 + (0.17403143962587937815e-7 + (0.81710660047307788845e-10 + (0.36885022360434957634e-12 + 0.15917038551111111111e-14 * t) * t) * t) * t) * t) * t;
}
case 1: {
double t = 2*y100 - 3;
return 0.21479143208285144230e-2 + (0.72686402367379996033e-3 + (0.36843175430938995552e-5 + (0.18071841272149201685e-7 + (0.85496449296040325555e-10 + (0.38852037518534291510e-12 + 0.16868473576888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 2: {
double t = 2*y100 - 5;
return 0.36165255935630175090e-2 + (0.74182092323555510862e-3 + (0.37948319957528242260e-5 + (0.18771627021793087350e-7 + (0.89484715122415089123e-10 + (0.40935858517772440862e-12 + 0.17872061464888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 3: {
double t = 2*y100 - 7;
return 0.51154983860031979264e-2 + (0.75722840734791660540e-3 + (0.39096425726735703941e-5 + (0.19504168704300468210e-7 + (0.93687503063178993915e-10 + (0.43143925959079664747e-12 + 0.18939926435555555556e-14 * t) * t) * t) * t) * t) * t;
}
case 4: {
double t = 2*y100 - 9;
return 0.66457513172673049824e-2 + (0.77310406054447454920e-3 + (0.40289510589399439385e-5 + (0.20271233238288381092e-7 + (0.98117631321709100264e-10 + (0.45484207406017752971e-12 + 0.20076352213333333333e-14 * t) * t) * t) * t) * t) * t;
}
case 5: {
double t = 2*y100 - 11;
return 0.82082389970241207883e-2 + (0.78946629611881710721e-3 + (0.41529701552622656574e-5 + (0.21074693344544655714e-7 + (0.10278874108587317989e-9 + (0.47965201390613339638e-12 + 0.21285907413333333333e-14 * t) * t) * t) * t) * t) * t;
}
case 6: {
double t = 2*y100 - 13;
return 0.98039537275352193165e-2 + (0.80633440108342840956e-3 + (0.42819241329736982942e-5 + (0.21916534346907168612e-7 + (0.10771535136565470914e-9 + (0.50595972623692822410e-12 + 0.22573462684444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 7: {
double t = 2*y100 - 15;
return 0.11433927298290302370e-1 + (0.82372858383196561209e-3 + (0.44160495311765438816e-5 + (0.22798861426211986056e-7 + (0.11291291745879239736e-9 + (0.53386189365816880454e-12 + 0.23944209546666666667e-14 * t) * t) * t) * t) * t) * t;
}
case 8: {
double t = 2*y100 - 17;
return 0.13099232878814653979e-1 + (0.84167002467906968214e-3 + (0.45555958988457506002e-5 + (0.23723907357214175198e-7 + (0.11839789326602695603e-9 + (0.56346163067550237877e-12 + 0.25403679644444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 9: {
double t = 2*y100 - 19;
return 0.14800987015587535621e-1 + (0.86018092946345943214e-3 + (0.47008265848816866105e-5 + (0.24694040760197315333e-7 + (0.12418779768752299093e-9 + (0.59486890370320261949e-12 + 0.26957764568888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 10: {
double t = 2*y100 - 21;
return 0.16540351739394069380e-1 + (0.87928458641241463952e-3 + (0.48520195793001753903e-5 + (0.25711774900881709176e-7 + (0.13030128534230822419e-9 + (0.62820097586874779402e-12 + 0.28612737351111111111e-14 * t) * t) * t) * t) * t) * t;
}
case 11: {
double t = 2*y100 - 23;
return 0.18318536789842392647e-1 + (0.89900542647891721692e-3 + (0.50094684089553365810e-5 + (0.26779777074218070482e-7 + (0.13675822186304615566e-9 + (0.66358287745352705725e-12 + 0.30375273884444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 12: {
double t = 2*y100 - 25;
return 0.20136801964214276775e-1 + (0.91936908737673676012e-3 + (0.51734830914104276820e-5 + (0.27900878609710432673e-7 + (0.14357976402809042257e-9 + (0.70114790311043728387e-12 + 0.32252476000000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 13: {
double t = 2*y100 - 27;
return 0.21996459598282740954e-1 + (0.94040248155366777784e-3 + (0.53443911508041164739e-5 + (0.29078085538049374673e-7 + (0.15078844500329731137e-9 + (0.74103813647499204269e-12 + 0.34251892320000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 14: {
double t = 2*y100 - 29;
return 0.23898877187226319502e-1 + (0.96213386835900177540e-3 + (0.55225386998049012752e-5 + (0.30314589961047687059e-7 + (0.15840826497296335264e-9 + (0.78340500472414454395e-12 + 0.36381553564444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 15: {
double t = 2*y100 - 31;
return 0.25845480155298518485e-1 + (0.98459293067820123389e-3 + (0.57082915920051843672e-5 + (0.31613782169164830118e-7 + (0.16646478745529630813e-9 + (0.82840985928785407942e-12 + 0.38649975768888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 16: {
double t = 2*y100 - 33;
return 0.27837754783474696598e-1 + (0.10078108563256892757e-2 + (0.59020366493792212221e-5 + (0.32979263553246520417e-7 + (0.17498524159268458073e-9 + (0.87622459124842525110e-12 + 0.41066206488888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 17: {
double t = 2*y100 - 35;
return 0.29877251304899307550e-1 + (0.10318204245057349310e-2 + (0.61041829697162055093e-5 + (0.34414860359542720579e-7 + (0.18399863072934089607e-9 + (0.92703227366365046533e-12 + 0.43639844053333333334e-14 * t) * t) * t) * t) * t) * t;
}
case 18: {
double t = 2*y100 - 37;
return 0.31965587178596443475e-1 + (0.10566560976716574401e-2 + (0.63151633192414586770e-5 + (0.35924638339521924242e-7 + (0.19353584758781174038e-9 + (0.98102783859889264382e-12 + 0.46381060817777777779e-14 * t) * t) * t) * t) * t) * t;
}
case 19: {
double t = 2*y100 - 39;
return 0.34104450552588334840e-1 + (0.10823541191350532574e-2 + (0.65354356159553934436e-5 + (0.37512918348533521149e-7 + (0.20362979635817883229e-9 + (0.10384187833037282363e-11 + 0.49300625262222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 20: {
double t = 2*y100 - 41;
return 0.36295603928292425716e-1 + (0.11089526167995268200e-2 + (0.67654845095518363577e-5 + (0.39184292949913591646e-7 + (0.21431552202133775150e-9 + (0.10994259106646731797e-11 + 0.52409949102222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 21: {
double t = 2*y100 - 43;
return 0.38540888038840509795e-1 + (0.11364917134175420009e-2 + (0.70058230641246312003e-5 + (0.40943644083718586939e-7 + (0.22563034723692881631e-9 + (0.11642841011361992885e-11 + 0.55721092871111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 22: {
double t = 2*y100 - 45;
return 0.40842225954785960651e-1 + (0.11650136437945673891e-2 + (0.72569945502343006619e-5 + (0.42796161861855042273e-7 + (0.23761401711005024162e-9 + (0.12332431172381557035e-11 + 0.59246802364444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 23: {
double t = 2*y100 - 47;
return 0.43201627431540222422e-1 + (0.11945628793917272199e-2 + (0.75195743532849206263e-5 + (0.44747364553960993492e-7 + (0.25030885216472953674e-9 + (0.13065684400300476484e-11 + 0.63000532853333333334e-14 * t) * t) * t) * t) * t) * t;
}
case 24: {
double t = 2*y100 - 49;
return 0.45621193513810471438e-1 + (0.12251862608067529503e-2 + (0.77941720055551920319e-5 + (0.46803119830954460212e-7 + (0.26375990983978426273e-9 + (0.13845421370977119765e-11 + 0.66996477404444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 25: {
double t = 2*y100 - 51;
return 0.48103121413299865517e-1 + (0.12569331386432195113e-2 + (0.80814333496367673980e-5 + (0.48969667335682018324e-7 + (0.27801515481905748484e-9 + (0.14674637611609884208e-11 + 0.71249589351111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 26: {
double t = 2*y100 - 53;
return 0.50649709676983338501e-1 + (0.12898555233099055810e-2 + (0.83820428414568799654e-5 + (0.51253642652551838659e-7 + (0.29312563849675507232e-9 + (0.15556512782814827846e-11 + 0.75775607822222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 27: {
double t = 2*y100 - 55;
return 0.53263363664388864181e-1 + (0.13240082443256975769e-2 + (0.86967260015007658418e-5 + (0.53662102750396795566e-7 + (0.30914568786634796807e-9 + (0.16494420240828493176e-11 + 0.80591079644444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 28: {
double t = 2*y100 - 57;
return 0.55946601353500013794e-1 + (0.13594491197408190706e-2 + (0.90262520233016380987e-5 + (0.56202552975056695376e-7 + (0.32613310410503135996e-9 + (0.17491936862246367398e-11 + 0.85713381688888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 29: {
double t = 2*y100 - 59;
return 0.58702059496154081813e-1 + (0.13962391363223647892e-2 + (0.93714365487312784270e-5 + (0.58882975670265286526e-7 + (0.34414937110591753387e-9 + (0.18552853109751857859e-11 + 0.91160736711111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 30: {
double t = 2*y100 - 61;
return 0.61532500145144778048e-1 + (0.14344426411912015247e-2 + (0.97331446201016809696e-5 + (0.61711860507347175097e-7 + (0.36325987418295300221e-9 + (0.19681183310134518232e-11 + 0.96952238400000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 31: {
double t = 2*y100 - 63;
return 0.64440817576653297993e-1 + (0.14741275456383131151e-2 + (0.10112293819576437838e-4 + (0.64698236605933246196e-7 + (0.38353412915303665586e-9 + (0.20881176114385120186e-11 + 0.10310784480000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 32: {
double t = 2*y100 - 65;
return 0.67430045633130393282e-1 + (0.15153655418916540370e-2 + (0.10509857606888328667e-4 + (0.67851706529363332855e-7 + (0.40504602194811140006e-9 + (0.22157325110542534469e-11 + 0.10964842115555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 33: {
double t = 2*y100 - 67;
return 0.70503365513338850709e-1 + (0.15582323336495709827e-2 + (0.10926868866865231089e-4 + (0.71182482239613507542e-7 + (0.42787405890153386710e-9 + (0.23514379522274416437e-11 + 0.11659571751111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 34: {
double t = 2*y100 - 69;
return 0.73664114037944596353e-1 + (0.16028078812438820413e-2 + (0.11364423678778207991e-4 + (0.74701423097423182009e-7 + (0.45210162777476488324e-9 + (0.24957355004088569134e-11 + 0.12397238257777777778e-13 * t) * t) * t) * t) * t) * t;
}
case 35: {
double t = 2*y100 - 71;
return 0.76915792420819562379e-1 + (0.16491766623447889354e-2 + (0.11823685320041302169e-4 + (0.78420075993781544386e-7 + (0.47781726956916478925e-9 + (0.26491544403815724749e-11 + 0.13180196462222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 36: {
double t = 2*y100 - 73;
return 0.80262075578094612819e-1 + (0.16974279491709504117e-2 + (0.12305888517309891674e-4 + (0.82350717698979042290e-7 + (0.50511496109857113929e-9 + (0.28122528497626897696e-11 + 0.14010889635555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 37: {
double t = 2*y100 - 75;
return 0.83706822008980357446e-1 + (0.17476561032212656962e-2 + (0.12812343958540763368e-4 + (0.86506399515036435592e-7 + (0.53409440823869467453e-9 + (0.29856186620887555043e-11 + 0.14891851591111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 38: {
double t = 2*y100 - 77;
return 0.87254084284461718231e-1 + (0.17999608886001962327e-2 + (0.13344443080089492218e-4 + (0.90900994316429008631e-7 + (0.56486134972616465316e-9 + (0.31698707080033956934e-11 + 0.15825697795555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 39: {
double t = 2*y100 - 79;
return 0.90908120182172748487e-1 + (0.18544478050657699758e-2 + (0.13903663143426120077e-4 + (0.95549246062549906177e-7 + (0.59752787125242054315e-9 + (0.33656597366099099413e-11 + 0.16815130613333333333e-13 * t) * t) * t) * t) * t) * t;
}
case 40: {
double t = 2*y100 - 81;
return 0.94673404508075481121e-1 + (0.19112284419887303347e-2 + (0.14491572616545004930e-4 + (0.10046682186333613697e-6 + (0.63221272959791000515e-9 + (0.35736693975589130818e-11 + 0.17862931591111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 41: {
double t = 2*y100 - 83;
return 0.98554641648004456555e-1 + (0.19704208544725622126e-2 + (0.15109836875625443935e-4 + (0.10567036667675984067e-6 + (0.66904168640019354565e-9 + (0.37946171850824333014e-11 + 0.18971959040000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 42: {
double t = 2*y100 - 85;
return 0.10255677889470089531e0 + (0.20321499629472857418e-2 + (0.15760224242962179564e-4 + (0.11117756071353507391e-6 + (0.70814785110097658502e-9 + (0.40292553276632563925e-11 + 0.20145143075555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 43: {
double t = 2*y100 - 87;
return 0.10668502059865093318e0 + (0.20965479776148731610e-2 + (0.16444612377624983565e-4 + (0.11700717962026152749e-6 + (0.74967203250938418991e-9 + (0.42783716186085922176e-11 + 0.21385479360000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 44: {
double t = 2*y100 - 89;
return 0.11094484319386444474e0 + (0.21637548491908170841e-2 + (0.17164995035719657111e-4 + (0.12317915750735938089e-6 + (0.79376309831499633734e-9 + (0.45427901763106353914e-11 + 0.22696025653333333333e-13 * t) * t) * t) * t) * t) * t;
}
case 45: {
double t = 2*y100 - 91;
return 0.11534201115268804714e0 + (0.22339187474546420375e-2 + (0.17923489217504226813e-4 + (0.12971465288245997681e-6 + (0.84057834180389073587e-9 + (0.48233721206418027227e-11 + 0.24079890062222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 46: {
double t = 2*y100 - 93;
return 0.11988259392684094740e0 + (0.23071965691918689601e-2 + (0.18722342718958935446e-4 + (0.13663611754337957520e-6 + (0.89028385488493287005e-9 + (0.51210161569225846701e-11 + 0.25540227111111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 47: {
double t = 2*y100 - 95;
return 0.12457298393509812907e0 + (0.23837544771809575380e-2 + (0.19563942105711612475e-4 + (0.14396736847739470782e-6 + (0.94305490646459247016e-9 + (0.54366590583134218096e-11 + 0.27080225920000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 48: {
double t = 2*y100 - 97;
return 0.12941991566142438816e0 + (0.24637684719508859484e-2 + (0.20450821127475879816e-4 + (0.15173366280523906622e-6 + (0.99907632506389027739e-9 + (0.57712760311351625221e-11 + 0.28703099555555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 49: {
double t = 2*y100 - 99;
return 0.13443048593088696613e0 + (0.25474249981080823877e-2 + (0.21385669591362915223e-4 + (0.15996177579900443030e-6 + (0.10585428844575134013e-8 + (0.61258809536787882989e-11 + 0.30412080142222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 50: {
double t = 2*y100 - 101;
return 0.13961217543434561353e0 + (0.26349215871051761416e-2 + (0.22371342712572567744e-4 + (0.16868008199296822247e-6 + (0.11216596910444996246e-8 + (0.65015264753090890662e-11 + 0.32210394506666666666e-13 * t) * t) * t) * t) * t) * t;
}
case 51: {
double t = 2*y100 - 103;
return 0.14497287157673800690e0 + (0.27264675383982439814e-2 + (0.23410870961050950197e-4 + (0.17791863939526376477e-6 + (0.11886425714330958106e-8 + (0.68993039665054288034e-11 + 0.34101266222222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 52: {
double t = 2*y100 - 105;
return 0.15052089272774618151e0 + (0.28222846410136238008e-2 + (0.24507470422713397006e-4 + (0.18770927679626136909e-6 + (0.12597184587583370712e-8 + (0.73203433049229821618e-11 + 0.36087889048888888890e-13 * t) * t) * t) * t) * t) * t;
}
case 53: {
double t = 2*y100 - 107;
return 0.15626501395774612325e0 + (0.29226079376196624949e-2 + (0.25664553693768450545e-4 + (0.19808568415654461964e-6 + (0.13351257759815557897e-8 + (0.77658124891046760667e-11 + 0.38173420035555555555e-13 * t) * t) * t) * t) * t) * t;
}
case 54: {
double t = 2*y100 - 109;
return 0.16221449434620737567e0 + (0.30276865332726475672e-2 + (0.26885741326534564336e-4 + (0.20908350604346384143e-6 + (0.14151148144240728728e-8 + (0.82369170665974313027e-11 + 0.40360957457777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 55: {
double t = 2*y100 - 111;
return 0.16837910595412130659e0 + (0.31377844510793082301e-2 + (0.28174873844911175026e-4 + (0.22074043807045782387e-6 + (0.14999481055996090039e-8 + (0.87348993661930809254e-11 + 0.42653528977777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 56: {
double t = 2*y100 - 113;
return 0.17476916455659369953e0 + (0.32531815370903068316e-2 + (0.29536024347344364074e-4 + (0.23309632627767074202e-6 + (0.15899007843582444846e-8 + (0.92610375235427359475e-11 + 0.45054073102222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 57: {
double t = 2*y100 - 115;
return 0.18139556223643701364e0 + (0.33741744168096996041e-2 + (0.30973511714709500836e-4 + (0.24619326937592290996e-6 + (0.16852609412267750744e-8 + (0.98166442942854895573e-11 + 0.47565418097777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 58: {
double t = 2*y100 - 117;
return 0.18826980194443664549e0 + (0.35010775057740317997e-2 + (0.32491914440014267480e-4 + (0.26007572375886319028e-6 + (0.17863299617388376116e-8 + (0.10403065638343878679e-10 + 0.50190265831111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 59: {
double t = 2*y100 - 119;
return 0.19540403413693967350e0 + (0.36342240767211326315e-2 + (0.34096085096200907289e-4 + (0.27479061117017637474e-6 + (0.18934228504790032826e-8 + (0.11021679075323598664e-10 + 0.52931171733333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 60: {
double t = 2*y100 - 121;
return 0.20281109560651886959e0 + (0.37739673859323597060e-2 + (0.35791165457592409054e-4 + (0.29038742889416172404e-6 + (0.20068685374849001770e-8 + (0.11673891799578381999e-10 + 0.55790523093333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 61: {
double t = 2*y100 - 123;
return 0.21050455062669334978e0 + (0.39206818613925652425e-2 + (0.37582602289680101704e-4 + (0.30691836231886877385e-6 + (0.21270101645763677824e-8 + (0.12361138551062899455e-10 + 0.58770520160000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 62: {
double t = 2*y100 - 125;
return 0.21849873453703332479e0 + (0.40747643554689586041e-2 + (0.39476163820986711501e-4 + (0.32443839970139918836e-6 + (0.22542053491518680200e-8 + (0.13084879235290858490e-10 + 0.61873153262222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 63: {
double t = 2*y100 - 127;
return 0.22680879990043229327e0 + (0.42366354648628516935e-2 + (0.41477956909656896779e-4 + (0.34300544894502810002e-6 + (0.23888264229264067658e-8 + (0.13846596292818514601e-10 + 0.65100183751111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 64: {
double t = 2*y100 - 129;
return 0.23545076536988703937e0 + (0.44067409206365170888e-2 + (0.43594444916224700881e-4 + (0.36268045617760415178e-6 + (0.25312606430853202748e-8 + (0.14647791812837903061e-10 + 0.68453122631111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 65: {
double t = 2*y100 - 131;
return 0.24444156740777432838e0 + (0.45855530511605787178e-2 + (0.45832466292683085475e-4 + (0.38352752590033030472e-6 + (0.26819103733055603460e-8 + (0.15489984390884756993e-10 + 0.71933206364444444445e-13 * t) * t) * t) * t) * t) * t;
}
case 66: {
double t = 2*y100 - 133;
return 0.25379911500634264643e0 + (0.47735723208650032167e-2 + (0.48199253896534185372e-4 + (0.40561404245564732314e-6 + (0.28411932320871165585e-8 + (0.16374705736458320149e-10 + 0.75541379822222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 67: {
double t = 2*y100 - 135;
return 0.26354234756393613032e0 + (0.49713289477083781266e-2 + (0.50702455036930367504e-4 + (0.42901079254268185722e-6 + (0.30095422058900481753e-8 + (0.17303497025347342498e-10 + 0.79278273368888888890e-13 * t) * t) * t) * t) * t) * t;
}
case 68: {
double t = 2*y100 - 137;
return 0.27369129607732343398e0 + (0.51793846023052643767e-2 + (0.53350152258326602629e-4 + (0.45379208848865015485e-6 + (0.31874057245814381257e-8 + (0.18277905010245111046e-10 + 0.83144182364444444445e-13 * t) * t) * t) * t) * t) * t;
}
case 69: {
double t = 2*y100 - 139;
return 0.28426714781640316172e0 + (0.53983341916695141966e-2 + (0.56150884865255810638e-4 + (0.48003589196494734238e-6 + (0.33752476967570796349e-8 + (0.19299477888083469086e-10 + 0.87139049137777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 70: {
double t = 2*y100 - 141;
return 0.29529231465348519920e0 + (0.56288077305420795663e-2 + (0.59113671189913307427e-4 + (0.50782393781744840482e-6 + (0.35735475025851713168e-8 + (0.20369760937017070382e-10 + 0.91262442613333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 71: {
double t = 2*y100 - 143;
return 0.30679050522528838613e0 + (0.58714723032745403331e-2 + (0.62248031602197686791e-4 + (0.53724185766200945789e-6 + (0.37827999418960232678e-8 + (0.21490291930444538307e-10 + 0.95513539182222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 72: {
double t = 2*y100 - 145;
return 0.31878680111173319425e0 + (0.61270341192339103514e-2 + (0.65564012259707640976e-4 + (0.56837930287837738996e-6 + (0.40035151353392378882e-8 + (0.22662596341239294792e-10 + 0.99891109760000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 73: {
double t = 2*y100 - 147;
return 0.33130773722152622027e0 + (0.63962406646798080903e-2 + (0.69072209592942396666e-4 + (0.60133006661885941812e-6 + (0.42362183765883466691e-8 + (0.23888182347073698382e-10 + 0.10439349811555555556e-12 * t) * t) * t) * t) * t) * t;
}
case 74: {
double t = 2*y100 - 149;
return 0.34438138658041336523e0 + (0.66798829540414007258e-2 + (0.72783795518603561144e-4 + (0.63619220443228800680e-6 + (0.44814499336514453364e-8 + (0.25168535651285475274e-10 + 0.10901861383111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 75: {
double t = 2*y100 - 151;
return 0.35803744972380175583e0 + (0.69787978834882685031e-2 + (0.76710543371454822497e-4 + (0.67306815308917386747e-6 + (0.47397647975845228205e-8 + (0.26505114141143050509e-10 + 0.11376390933333333333e-12 * t) * t) * t) * t) * t) * t;
}
case 76: {
double t = 2*y100 - 153;
return 0.37230734890119724188e0 + (0.72938706896461381003e-2 + (0.80864854542670714092e-4 + (0.71206484718062688779e-6 + (0.50117323769745883805e-8 + (0.27899342394100074165e-10 + 0.11862637614222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 77: {
double t = 2*y100 - 155;
return 0.38722432730555448223e0 + (0.76260375162549802745e-2 + (0.85259785810004603848e-4 + (0.75329383305171327677e-6 + (0.52979361368388119355e-8 + (0.29352606054164086709e-10 + 0.12360253370666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 78: {
double t = 2*y100 - 157;
return 0.40282355354616940667e0 + (0.79762880915029728079e-2 + (0.89909077342438246452e-4 + (0.79687137961956194579e-6 + (0.55989731807360403195e-8 + (0.30866246101464869050e-10 + 0.12868841946666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 79: {
double t = 2*y100 - 159;
return 0.41914223158913787649e0 + (0.83456685186950463538e-2 + (0.94827181359250161335e-4 + (0.84291858561783141014e-6 + (0.59154537751083485684e-8 + (0.32441553034347469291e-10 + 0.13387957943111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 80: {
double t = 2*y100 - 161;
return 0.43621971639463786896e0 + (0.87352841828289495773e-2 + (0.10002929142066799966e-3 + (0.89156148280219880024e-6 + (0.62480008150788597147e-8 + (0.34079760983458878910e-10 + 0.13917107176888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 81: {
double t = 2*y100 - 163;
return 0.45409763548534330981e0 + (0.91463027755548240654e-2 + (0.10553137232446167258e-3 + (0.94293113464638623798e-6 + (0.65972492312219959885e-8 + (0.35782041795476563662e-10 + 0.14455745872000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 82: {
double t = 2*y100 - 165;
return 0.47282001668512331468e0 + (0.95799574408860463394e-2 + (0.11135019058000067469e-3 + (0.99716373005509038080e-6 + (0.69638453369956970347e-8 + (0.37549499088161345850e-10 + 0.15003280712888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 83: {
double t = 2*y100 - 167;
return 0.49243342227179841649e0 + (0.10037550043909497071e-1 + (0.11750334542845234952e-3 + (0.10544006716188967172e-5 + (0.73484461168242224872e-8 + (0.39383162326435752965e-10 + 0.15559069118222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 84: {
double t = 2*y100 - 169;
return 0.51298708979209258326e0 + (0.10520454564612427224e-1 + (0.12400930037494996655e-3 + (0.11147886579371265246e-5 + (0.77517184550568711454e-8 + (0.41283980931872622611e-10 + 0.16122419680000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 85: {
double t = 2*y100 - 171;
return 0.53453307979101369843e0 + (0.11030120618800726938e-1 + (0.13088741519572269581e-3 + (0.11784797595374515432e-5 + (0.81743383063044825400e-8 + (0.43252818449517081051e-10 + 0.16692592640000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 86: {
double t = 2*y100 - 173;
return 0.55712643071169299478e0 + (0.11568077107929735233e-1 + (0.13815797838036651289e-3 + (0.12456314879260904558e-5 + (0.86169898078969313597e-8 + (0.45290446811539652525e-10 + 0.17268801084444444444e-12 * t) * t) * t) * t) * t) * t;
}
case 87: {
double t = 2*y100 - 175;
return 0.58082532122519320968e0 + (0.12135935999503877077e-1 + (0.14584223996665838559e-3 + (0.13164068573095710742e-5 + (0.90803643355106020163e-8 + (0.47397540713124619155e-10 + 0.17850211608888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 88: {
double t = 2*y100 - 177;
return 0.60569124025293375554e0 + (0.12735396239525550361e-1 + (0.15396244472258863344e-3 + (0.13909744385382818253e-5 + (0.95651595032306228245e-8 + (0.49574672127669041550e-10 + 0.18435945564444444444e-12 * t) * t) * t) * t) * t) * t;
}
case 89: {
double t = 2*y100 - 179;
return 0.63178916494715716894e0 + (0.13368247798287030927e-1 + (0.16254186562762076141e-3 + (0.14695084048334056083e-5 + (0.10072078109604152350e-7 + (0.51822304995680707483e-10 + 0.19025081422222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 90: {
double t = 2*y100 - 181;
return 0.65918774689725319200e0 + (0.14036375850601992063e-1 + (0.17160483760259706354e-3 + (0.15521885688723188371e-5 + (0.10601827031535280590e-7 + (0.54140790105837520499e-10 + 0.19616655146666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 91: {
double t = 2*y100 - 183;
return 0.68795950683174433822e0 + (0.14741765091365869084e-1 + (0.18117679143520433835e-3 + (0.16392004108230585213e-5 + (0.11155116068018043001e-7 + (0.56530360194925690374e-10 + 0.20209663662222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 92: {
double t = 2*y100 - 185;
return 0.71818103808729967036e0 + (0.15486504187117112279e-1 + (0.19128428784550923217e-3 + (0.17307350969359975848e-5 + (0.11732656736113607751e-7 + (0.58991125287563833603e-10 + 0.20803065333333333333e-12 * t) * t) * t) * t) * t) * t;
}
case 93: {
double t = 2*y100 - 187;
return 0.74993321911726254661e0 + (0.16272790364044783382e-1 + (0.20195505163377912645e-3 + (0.18269894883203346953e-5 + (0.12335161021630225535e-7 + (0.61523068312169087227e-10 + 0.21395783431111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 94: {
double t = 2*y100 - 189;
return 0.78330143531283492729e0 + (0.17102934132652429240e-1 + (0.21321800585063327041e-3 + (0.19281661395543913713e-5 + (0.12963340087354341574e-7 + (0.64126040998066348872e-10 + 0.21986708942222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 95: {
double t = 2*y100 - 191;
return 0.81837581041023811832e0 + (0.17979364149044223802e-1 + (0.22510330592753129006e-3 + (0.20344732868018175389e-5 + (0.13617902941839949718e-7 + (0.66799760083972474642e-10 + 0.22574701262222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 96: {
double t = 2*y100 - 193;
return 0.85525144775685126237e0 + (0.18904632212547561026e-1 + (0.23764237370371255638e-3 + (0.21461248251306387979e-5 + (0.14299555071870523786e-7 + (0.69543803864694171934e-10 + 0.23158593688888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 97: {
double t = 2*y100 - 195;
return 0.89402868170849933734e0 + (0.19881418399127202569e-1 + (0.25086793128395995798e-3 + (0.22633402747585233180e-5 + (0.15008997042116532283e-7 + (0.72357609075043941261e-10 + 0.23737194737777777778e-12 * t) * t) * t) * t) * t) * t;
}
case 98: {
double t = 2*y100 - 197;
return 0.93481333942870796363e0 + (0.20912536329780368893e-1 + (0.26481403465998477969e-3 + (0.23863447359754921676e-5 + (0.15746923065472184451e-7 + (0.75240468141720143653e-10 + 0.24309291271111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 99: {
double t = 2*y100 - 199;
return 0.97771701335885035464e0 + (0.22000938572830479551e-1 + (0.27951610702682383001e-3 + (0.25153688325245314530e-5 + (0.16514019547822821453e-7 + (0.78191526829368231251e-10 + 0.24873652355555555556e-12 * t) * t) * t) * t) * t) * t;
}
  }
  // we only get here if y = 1, i.e. |x| < 4*eps, in which case
  // erfcx is within 1e-15 of 1..
  return 1.0;
}

double FADDEEVA_RE(erfcx)(double x)
{
  if (x >= 0) {
    if (x > 50) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x > 5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x+0.5/(x+1/(x+1.5/(x+2/x))))  */
      return ispi*((x*x) * (x*x+4.5) + 2) / (x * ((x*x) * (x*x+5) + 3.75));
    }
    return erfcx_y100(400/(4+x));
  }
  else
    return x < -26.7 ? HUGE_VAL : (x < -6.1 ? 2*exp(x*x)
                                   : 2*exp(x*x) - erfcx_y100(400/(4-x)));
}

/////////////////////////////////////////////////////////////////////////
/* Compute a scaled Dawson integral
            FADDEEVA(w_im)(x) = 2*Dawson(x)/sqrt(pi)
   equivalent to the imaginary part w(x) for real x.

   Uses methods similar to the erfcx calculation above: continued fractions
   for large |x|, a lookup table of Chebyshev polynomials for smaller |x|,
   and finally a Taylor expansion for |x|<0.01.

   Steven G. Johnson, October 2012. */

/* Given y100=100*y, where y = 1/(1+x) for x >= 0, compute w_im(x).

   Uses a look-up table of 100 different Chebyshev polynomials
   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
   with the help of Maple and a little shell script.   This allows
   the Chebyshev polynomials to be of significantly lower degree (about 1/30)
   compared to fitting the whole [0,1] interval with a single polynomial. */
static double w_im_y100(double y100, double x) {
  switch ((int) y100) {
    case 0: {
      double t = 2*y100 - 1;
      return 0.28351593328822191546e-2 + (0.28494783221378400759e-2 + (0.14427470563276734183e-4 + (0.10939723080231588129e-6 + (0.92474307943275042045e-9 + (0.89128907666450075245e-11 + 0.92974121935111111110e-13 * t) * t) * t) * t) * t) * t;
    }
    case 1: {
      double t = 2*y100 - 3;
      return 0.85927161243940350562e-2 + (0.29085312941641339862e-2 + (0.15106783707725582090e-4 + (0.11716709978531327367e-6 + (0.10197387816021040024e-8 + (0.10122678863073360769e-10 + 0.10917479678400000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 2: {
      double t = 2*y100 - 5;
      return 0.14471159831187703054e-1 + (0.29703978970263836210e-2 + (0.15835096760173030976e-4 + (0.12574803383199211596e-6 + (0.11278672159518415848e-8 + (0.11547462300333495797e-10 + 0.12894535335111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 3: {
      double t = 2*y100 - 7;
      return 0.20476320420324610618e-1 + (0.30352843012898665856e-2 + (0.16617609387003727409e-4 + (0.13525429711163116103e-6 + (0.12515095552507169013e-8 + (0.13235687543603382345e-10 + 0.15326595042666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 4: {
      double t = 2*y100 - 9;
      return 0.26614461952489004566e-1 + (0.31034189276234947088e-2 + (0.17460268109986214274e-4 + (0.14582130824485709573e-6 + (0.13935959083809746345e-8 + (0.15249438072998932900e-10 + 0.18344741882133333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 5: {
      double t = 2*y100 - 11;
      return 0.32892330248093586215e-1 + (0.31750557067975068584e-2 + (0.18369907582308672632e-4 + (0.15761063702089457882e-6 + (0.15577638230480894382e-8 + (0.17663868462699097951e-10 + (0.22126732680711111111e-12 + 0.30273474177737853668e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 6: {
      double t = 2*y100 - 13;
      return 0.39317207681134336024e-1 + (0.32504779701937539333e-2 + (0.19354426046513400534e-4 + (0.17081646971321290539e-6 + (0.17485733959327106250e-8 + (0.20593687304921961410e-10 + (0.26917401949155555556e-12 + 0.38562123837725712270e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 7: {
      double t = 2*y100 - 15;
      return 0.45896976511367738235e-1 + (0.33300031273110976165e-2 + (0.20423005398039037313e-4 + (0.18567412470376467303e-6 + (0.19718038363586588213e-8 + (0.24175006536781219807e-10 + (0.33059982791466666666e-12 + 0.49756574284439426165e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 8: {
      double t = 2*y100 - 17;
      return 0.52640192524848962855e-1 + (0.34139883358846720806e-2 + (0.21586390240603337337e-4 + (0.20247136501568904646e-6 + (0.22348696948197102935e-8 + (0.28597516301950162548e-10 + (0.41045502119111111110e-12 + 0.65151614515238361946e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 9: {
      double t = 2*y100 - 19;
      return 0.59556171228656770456e-1 + (0.35028374386648914444e-2 + (0.22857246150998562824e-4 + (0.22156372146525190679e-6 + (0.25474171590893813583e-8 + (0.34122390890697400584e-10 + (0.51593189879111111110e-12 + 0.86775076853908006938e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 10: {
      double t = 2*y100 - 21;
      return 0.66655089485108212551e-1 + (0.35970095381271285568e-2 + (0.24250626164318672928e-4 + (0.24339561521785040536e-6 + (0.29221990406518411415e-8 + (0.41117013527967776467e-10 + (0.65786450716444444445e-12 + 0.11791885745450623331e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 11: {
      double t = 2*y100 - 23;
      return 0.73948106345519174661e-1 + (0.36970297216569341748e-2 + (0.25784588137312868792e-4 + (0.26853012002366752770e-6 + (0.33763958861206729592e-8 + (0.50111549981376976397e-10 + (0.85313857496888888890e-12 + 0.16417079927706899860e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 12: {
      double t = 2*y100 - 25;
      return 0.81447508065002963203e-1 + (0.38035026606492705117e-2 + (0.27481027572231851896e-4 + (0.29769200731832331364e-6 + (0.39336816287457655076e-8 + (0.61895471132038157624e-10 + (0.11292303213511111111e-11 + 0.23558532213703884304e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 13: {
      double t = 2*y100 - 27;
      return 0.89166884027582716628e-1 + (0.39171301322438946014e-2 + (0.29366827260422311668e-4 + (0.33183204390350724895e-6 + (0.46276006281647330524e-8 + (0.77692631378169813324e-10 + (0.15335153258844444444e-11 + 0.35183103415916026911e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 14: {
      double t = 2*y100 - 29;
      return 0.97121342888032322019e-1 + (0.40387340353207909514e-2 + (0.31475490395950776930e-4 + (0.37222714227125135042e-6 + (0.55074373178613809996e-8 + (0.99509175283990337944e-10 + (0.21552645758222222222e-11 + 0.55728651431872687605e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 15: {
      double t = 2*y100 - 31;
      return 0.10532778218603311137e0 + (0.41692873614065380607e-2 + (0.33849549774889456984e-4 + (0.42064596193692630143e-6 + (0.66494579697622432987e-8 + (0.13094103581931802337e-9 + (0.31896187409777777778e-11 + 0.97271974184476560742e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 16: {
      double t = 2*y100 - 33;
      return 0.11380523107427108222e0 + (0.43099572287871821013e-2 + (0.36544324341565929930e-4 + (0.47965044028581857764e-6 + (0.81819034238463698796e-8 + (0.17934133239549647357e-9 + (0.50956666166186293627e-11 + (0.18850487318190638010e-12 + 0.79697813173519853340e-14 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 17: {
      double t = 2*y100 - 35;
      return 0.12257529703447467345e0 + (0.44621675710026986366e-2 + (0.39634304721292440285e-4 + (0.55321553769873381819e-6 + (0.10343619428848520870e-7 + (0.26033830170470368088e-9 + (0.87743837749108025357e-11 + (0.34427092430230063401e-12 + 0.10205506615709843189e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 18: {
      double t = 2*y100 - 37;
      return 0.13166276955656699478e0 + (0.46276970481783001803e-2 + (0.43225026380496399310e-4 + (0.64799164020016902656e-6 + (0.13580082794704641782e-7 + (0.39839800853954313927e-9 + (0.14431142411840000000e-10 + 0.42193457308830027541e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 19: {
      double t = 2*y100 - 39;
      return 0.14109647869803356475e0 + (0.48088424418545347758e-2 + (0.47474504753352150205e-4 + (0.77509866468724360352e-6 + (0.18536851570794291724e-7 + (0.60146623257887570439e-9 + (0.18533978397305276318e-10 + (0.41033845938901048380e-13 - 0.46160680279304825485e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 20: {
      double t = 2*y100 - 41;
      return 0.15091057940548936603e0 + (0.50086864672004685703e-2 + (0.52622482832192230762e-4 + (0.95034664722040355212e-6 + (0.25614261331144718769e-7 + (0.80183196716888606252e-9 + (0.12282524750534352272e-10 + (-0.10531774117332273617e-11 - 0.86157181395039646412e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 21: {
      double t = 2*y100 - 43;
      return 0.16114648116017010770e0 + (0.52314661581655369795e-2 + (0.59005534545908331315e-4 + (0.11885518333915387760e-5 + (0.33975801443239949256e-7 + (0.82111547144080388610e-9 + (-0.12357674017312854138e-10 + (-0.24355112256914479176e-11 - 0.75155506863572930844e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 22: {
      double t = 2*y100 - 45;
      return 0.17185551279680451144e0 + (0.54829002967599420860e-2 + (0.67013226658738082118e-4 + (0.14897400671425088807e-5 + (0.40690283917126153701e-7 + (0.44060872913473778318e-9 + (-0.52641873433280000000e-10 - 0.30940587864543343124e-11 * t) * t) * t) * t) * t) * t) * t;
    }
    case 23: {
      double t = 2*y100 - 47;
      return 0.18310194559815257381e0 + (0.57701559375966953174e-2 + (0.76948789401735193483e-4 + (0.18227569842290822512e-5 + (0.41092208344387212276e-7 + (-0.44009499965694442143e-9 + (-0.92195414685628803451e-10 + (-0.22657389705721753299e-11 + 0.10004784908106839254e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 24: {
      double t = 2*y100 - 49;
      return 0.19496527191546630345e0 + (0.61010853144364724856e-2 + (0.88812881056342004864e-4 + (0.21180686746360261031e-5 + (0.30652145555130049203e-7 + (-0.16841328574105890409e-8 + (-0.11008129460612823934e-9 + (-0.12180794204544515779e-12 + 0.15703325634590334097e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 25: {
      double t = 2*y100 - 51;
      return 0.20754006813966575720e0 + (0.64825787724922073908e-2 + (0.10209599627522311893e-3 + (0.22785233392557600468e-5 + (0.73495224449907568402e-8 + (-0.29442705974150112783e-8 + (-0.94082603434315016546e-10 + (0.23609990400179321267e-11 + 0.14141908654269023788e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 26: {
      double t = 2*y100 - 53;
      return 0.22093185554845172146e0 + (0.69182878150187964499e-2 + (0.11568723331156335712e-3 + (0.22060577946323627739e-5 + (-0.26929730679360840096e-7 + (-0.38176506152362058013e-8 + (-0.47399503861054459243e-10 + (0.40953700187172127264e-11 + 0.69157730376118511127e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 27: {
      double t = 2*y100 - 55;
      return 0.23524827304057813918e0 + (0.74063350762008734520e-2 + (0.12796333874615790348e-3 + (0.18327267316171054273e-5 + (-0.66742910737957100098e-7 + (-0.40204740975496797870e-8 + (0.14515984139495745330e-10 + (0.44921608954536047975e-11 - 0.18583341338983776219e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 28: {
      double t = 2*y100 - 57;
      return 0.25058626331812744775e0 + (0.79377285151602061328e-2 + (0.13704268650417478346e-3 + (0.11427511739544695861e-5 + (-0.10485442447768377485e-6 + (-0.34850364756499369763e-8 + (0.72656453829502179208e-10 + (0.36195460197779299406e-11 - 0.84882136022200714710e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 29: {
      double t = 2*y100 - 59;
      return 0.26701724900280689785e0 + (0.84959936119625864274e-2 + (0.14112359443938883232e-3 + (0.17800427288596909634e-6 + (-0.13443492107643109071e-6 + (-0.23512456315677680293e-8 + (0.11245846264695936769e-9 + (0.19850501334649565404e-11 - 0.11284666134635050832e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 30: {
      double t = 2*y100 - 61;
      return 0.28457293586253654144e0 + (0.90581563892650431899e-2 + (0.13880520331140646738e-3 + (-0.97262302362522896157e-6 + (-0.15077100040254187366e-6 + (-0.88574317464577116689e-9 + (0.12760311125637474581e-9 + (0.20155151018282695055e-12 - 0.10514169375181734921e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 31: {
      double t = 2*y100 - 63;
      return 0.30323425595617385705e0 + (0.95968346790597422934e-2 + (0.12931067776725883939e-3 + (-0.21938741702795543986e-5 + (-0.15202888584907373963e-6 + (0.61788350541116331411e-9 + (0.11957835742791248256e-9 + (-0.12598179834007710908e-11 - 0.75151817129574614194e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 32: {
      double t = 2*y100 - 65;
      return 0.32292521181517384379e0 + (0.10082957727001199408e-1 + (0.11257589426154962226e-3 + (-0.33670890319327881129e-5 + (-0.13910529040004008158e-6 + (0.19170714373047512945e-8 + (0.94840222377720494290e-10 + (-0.21650018351795353201e-11 - 0.37875211678024922689e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 33: {
      double t = 2*y100 - 67;
      return 0.34351233557911753862e0 + (0.10488575435572745309e-1 + (0.89209444197248726614e-4 + (-0.43893459576483345364e-5 + (-0.11488595830450424419e-6 + (0.28599494117122464806e-8 + (0.61537542799857777779e-10 - 0.24935749227658002212e-11 * t) * t) * t) * t) * t) * t) * t;
    }
    case 34: {
      double t = 2*y100 - 69;
      return 0.36480946642143669093e0 + (0.10789304203431861366e-1 + (0.60357993745283076834e-4 + (-0.51855862174130669389e-5 + (-0.83291664087289801313e-7 + (0.33898011178582671546e-8 + (0.27082948188277716482e-10 + (-0.23603379397408694974e-11 + 0.19328087692252869842e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 35: {
      double t = 2*y100 - 71;
      return 0.38658679935694939199e0 + (0.10966119158288804999e-1 + (0.27521612041849561426e-4 + (-0.57132774537670953638e-5 + (-0.48404772799207914899e-7 + (0.35268354132474570493e-8 + (-0.32383477652514618094e-11 + (-0.19334202915190442501e-11 + 0.32333189861286460270e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 36: {
      double t = 2*y100 - 73;
      return 0.40858275583808707870e0 + (0.11006378016848466550e-1 + (-0.76396376685213286033e-5 + (-0.59609835484245791439e-5 + (-0.13834610033859313213e-7 + (0.33406952974861448790e-8 + (-0.26474915974296612559e-10 + (-0.13750229270354351983e-11 + 0.36169366979417390637e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 37: {
      double t = 2*y100 - 75;
      return 0.43051714914006682977e0 + (0.10904106549500816155e-1 + (-0.43477527256787216909e-4 + (-0.59429739547798343948e-5 + (0.17639200194091885949e-7 + (0.29235991689639918688e-8 + (-0.41718791216277812879e-10 + (-0.81023337739508049606e-12 + 0.33618915934461994428e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 38: {
      double t = 2*y100 - 77;
      return 0.45210428135559607406e0 + (0.10659670756384400554e-1 + (-0.78488639913256978087e-4 + (-0.56919860886214735936e-5 + (0.44181850467477733407e-7 + (0.23694306174312688151e-8 + (-0.49492621596685443247e-10 + (-0.31827275712126287222e-12 + 0.27494438742721623654e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 39: {
      double t = 2*y100 - 79;
      return 0.47306491195005224077e0 + (0.10279006119745977570e-1 + (-0.11140268171830478306e-3 + (-0.52518035247451432069e-5 + (0.64846898158889479518e-7 + (0.17603624837787337662e-8 + (-0.51129481592926104316e-10 + (0.62674584974141049511e-13 + 0.20055478560829935356e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 40: {
      double t = 2*y100 - 81;
      return 0.49313638965719857647e0 + (0.97725799114772017662e-2 + (-0.14122854267291533334e-3 + (-0.46707252568834951907e-5 + (0.79421347979319449524e-7 + (0.11603027184324708643e-8 + (-0.48269605844397175946e-10 + (0.32477251431748571219e-12 + 0.12831052634143527985e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 41: {
      double t = 2*y100 - 83;
      return 0.51208057433416004042e0 + (0.91542422354009224951e-2 + (-0.16726530230228647275e-3 + (-0.39964621752527649409e-5 + (0.88232252903213171454e-7 + (0.61343113364949928501e-9 + (-0.42516755603130443051e-10 + (0.47910437172240209262e-12 + 0.66784341874437478953e-14 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 42: {
      double t = 2*y100 - 85;
      return 0.52968945458607484524e0 + (0.84400880445116786088e-2 + (-0.18908729783854258774e-3 + (-0.32725905467782951931e-5 + (0.91956190588652090659e-7 + (0.14593989152420122909e-9 + (-0.35239490687644444445e-10 + 0.54613829888448694898e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 43: {
      double t = 2*y100 - 87;
      return 0.54578857454330070965e0 + (0.76474155195880295311e-2 + (-0.20651230590808213884e-3 + (-0.25364339140543131706e-5 + (0.91455367999510681979e-7 + (-0.23061359005297528898e-9 + (-0.27512928625244444444e-10 + 0.54895806008493285579e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 44: {
      double t = 2*y100 - 89;
      return 0.56023851910298493910e0 + (0.67938321739997196804e-2 + (-0.21956066613331411760e-3 + (-0.18181127670443266395e-5 + (0.87650335075416845987e-7 + (-0.51548062050366615977e-9 + (-0.20068462174044444444e-10 + 0.50912654909758187264e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 45: {
      double t = 2*y100 - 91;
      return 0.57293478057455721150e0 + (0.58965321010394044087e-2 + (-0.22841145229276575597e-3 + (-0.11404605562013443659e-5 + (0.81430290992322326296e-7 + (-0.71512447242755357629e-9 + (-0.13372664928000000000e-10 + 0.44461498336689298148e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 46: {
      double t = 2*y100 - 93;
      return 0.58380635448407827360e0 + (0.49717469530842831182e-2 + (-0.23336001540009645365e-3 + (-0.51952064448608850822e-6 + (0.73596577815411080511e-7 + (-0.84020916763091566035e-9 + (-0.76700972702222222221e-11 + 0.36914462807972467044e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 47: {
      double t = 2*y100 - 95;
      return 0.59281340237769489597e0 + (0.40343592069379730568e-2 + (-0.23477963738658326185e-3 + (0.34615944987790224234e-7 + (0.64832803248395814574e-7 + (-0.90329163587627007971e-9 + (-0.30421940400000000000e-11 + 0.29237386653743536669e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 48: {
      double t = 2*y100 - 97;
      return 0.59994428743114271918e0 + (0.30976579788271744329e-2 + (-0.23308875765700082835e-3 + (0.51681681023846925160e-6 + (0.55694594264948268169e-7 + (-0.91719117313243464652e-9 + (0.53982743680000000000e-12 + 0.22050829296187771142e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 49: {
      double t = 2*y100 - 99;
      return 0.60521224471819875444e0 + (0.21732138012345456060e-2 + (-0.22872428969625997456e-3 + (0.92588959922653404233e-6 + (0.46612665806531930684e-7 + (-0.89393722514414153351e-9 + (0.31718550353777777778e-11 + 0.15705458816080549117e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 50: {
      double t = 2*y100 - 101;
      return 0.60865189969791123620e0 + (0.12708480848877451719e-2 + (-0.22212090111534847166e-3 + (0.12636236031532793467e-5 + (0.37904037100232937574e-7 + (-0.84417089968101223519e-9 + (0.49843180828444444445e-11 + 0.10355439441049048273e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 51: {
      double t = 2*y100 - 103;
      return 0.61031580103499200191e0 + (0.39867436055861038223e-3 + (-0.21369573439579869291e-3 + (0.15339402129026183670e-5 + (0.29787479206646594442e-7 + (-0.77687792914228632974e-9 + (0.61192452741333333334e-11 + 0.60216691829459295780e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 52: {
      double t = 2*y100 - 105;
      return 0.61027109047879835868e0 + (-0.43680904508059878254e-3 + (-0.20383783788303894442e-3 + (0.17421743090883439959e-5 + (0.22400425572175715576e-7 + (-0.69934719320045128997e-9 + (0.67152759655111111110e-11 + 0.26419960042578359995e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 53: {
      double t = 2*y100 - 107;
      return 0.60859639489217430521e0 + (-0.12305921390962936873e-2 + (-0.19290150253894682629e-3 + (0.18944904654478310128e-5 + (0.15815530398618149110e-7 + (-0.61726850580964876070e-9 + 0.68987888999111111110e-11 * t) * t) * t) * t) * t) * t;
    }
    case 54: {
      double t = 2*y100 - 109;
      return 0.60537899426486075181e0 + (-0.19790062241395705751e-2 + (-0.18120271393047062253e-3 + (0.19974264162313241405e-5 + (0.10055795094298172492e-7 + (-0.53491997919318263593e-9 + (0.67794550295111111110e-11 - 0.17059208095741511603e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 55: {
      double t = 2*y100 - 111;
      return 0.60071229457904110537e0 + (-0.26795676776166354354e-2 + (-0.16901799553627508781e-3 + (0.20575498324332621581e-5 + (0.51077165074461745053e-8 + (-0.45536079828057221858e-9 + (0.64488005516444444445e-11 - 0.29311677573152766338e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 56: {
      double t = 2*y100 - 113;
      return 0.59469361520112714738e0 + (-0.33308208190600993470e-2 + (-0.15658501295912405679e-3 + (0.20812116912895417272e-5 + (0.93227468760614182021e-9 + (-0.38066673740116080415e-9 + (0.59806790359111111110e-11 - 0.36887077278950440597e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 57: {
      double t = 2*y100 - 115;
      return 0.58742228631775388268e0 + (-0.39321858196059227251e-2 + (-0.14410441141450122535e-3 + (0.20743790018404020716e-5 + (-0.25261903811221913762e-8 + (-0.31212416519526924318e-9 + (0.54328422462222222221e-11 - 0.40864152484979815972e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 58: {
      double t = 2*y100 - 117;
      return 0.57899804200033018447e0 + (-0.44838157005618913447e-2 + (-0.13174245966501437965e-3 + (0.20425306888294362674e-5 + (-0.53330296023875447782e-8 + (-0.25041289435539821014e-9 + (0.48490437205333333334e-11 - 0.42162206939169045177e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 59: {
      double t = 2*y100 - 119;
      return 0.56951968796931245974e0 + (-0.49864649488074868952e-2 + (-0.11963416583477567125e-3 + (0.19906021780991036425e-5 + (-0.75580140299436494248e-8 + (-0.19576060961919820491e-9 + (0.42613011928888888890e-11 - 0.41539443304115604377e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 60: {
      double t = 2*y100 - 121;
      return 0.55908401930063918964e0 + (-0.54413711036826877753e-2 + (-0.10788661102511914628e-3 + (0.19229663322982839331e-5 + (-0.92714731195118129616e-8 + (-0.14807038677197394186e-9 + (0.36920870298666666666e-11 - 0.39603726688419162617e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 61: {
      double t = 2*y100 - 123;
      return 0.54778496152925675315e0 + (-0.58501497933213396670e-2 + (-0.96582314317855227421e-4 + (0.18434405235069270228e-5 + (-0.10541580254317078711e-7 + (-0.10702303407788943498e-9 + (0.31563175582222222222e-11 - 0.36829748079110481422e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 62: {
      double t = 2*y100 - 125;
      return 0.53571290831682823999e0 + (-0.62147030670760791791e-2 + (-0.85782497917111760790e-4 + (0.17553116363443470478e-5 + (-0.11432547349815541084e-7 + (-0.72157091369041330520e-10 + (0.26630811607111111111e-11 - 0.33578660425893164084e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 63: {
      double t = 2*y100 - 127;
      return 0.52295422962048434978e0 + (-0.65371404367776320720e-2 + (-0.75530164941473343780e-4 + (0.16613725797181276790e-5 + (-0.12003521296598910761e-7 + (-0.42929753689181106171e-10 + (0.22170894940444444444e-11 - 0.30117697501065110505e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 64: {
      double t = 2*y100 - 129;
      return 0.50959092577577886140e0 + (-0.68197117603118591766e-2 + (-0.65852936198953623307e-4 + (0.15639654113906716939e-5 + (-0.12308007991056524902e-7 + (-0.18761997536910939570e-10 + (0.18198628922666666667e-11 - 0.26638355362285200932e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 65: {
      double t = 2*y100 - 131;
      return 0.49570040481823167970e0 + (-0.70647509397614398066e-2 + (-0.56765617728962588218e-4 + (0.14650274449141448497e-5 + (-0.12393681471984051132e-7 + (0.92904351801168955424e-12 + (0.14706755960177777778e-11 - 0.23272455351266325318e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 66: {
      double t = 2*y100 - 133;
      return 0.48135536250935238066e0 + (-0.72746293327402359783e-2 + (-0.48272489495730030780e-4 + (0.13661377309113939689e-5 + (-0.12302464447599382189e-7 + (0.16707760028737074907e-10 + (0.11672928324444444444e-11 - 0.20105801424709924499e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 67: {
      double t = 2*y100 - 135;
      return 0.46662374675511439448e0 + (-0.74517177649528487002e-2 + (-0.40369318744279128718e-4 + (0.12685621118898535407e-5 + (-0.12070791463315156250e-7 + (0.29105507892605823871e-10 + (0.90653314645333333334e-12 - 0.17189503312102982646e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 68: {
      double t = 2*y100 - 137;
      return 0.45156879030168268778e0 + (-0.75983560650033817497e-2 + (-0.33045110380705139759e-4 + (0.11732956732035040896e-5 + (-0.11729986947158201869e-7 + (0.38611905704166441308e-10 + (0.68468768305777777779e-12 - 0.14549134330396754575e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 69: {
      double t = 2*y100 - 139;
      return 0.43624909769330896904e0 + (-0.77168291040309554679e-2 + (-0.26283612321339907756e-4 + (0.10811018836893550820e-5 + (-0.11306707563739851552e-7 + (0.45670446788529607380e-10 + (0.49782492549333333334e-12 - 0.12191983967561779442e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 70: {
      double t = 2*y100 - 141;
      return 0.42071877443548481181e0 + (-0.78093484015052730097e-2 + (-0.20064596897224934705e-4 + (0.99254806680671890766e-6 + (-0.10823412088884741451e-7 + (0.50677203326904716247e-10 + (0.34200547594666666666e-12 - 0.10112698698356194618e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 71: {
      double t = 2*y100 - 143;
      return 0.40502758809710844280e0 + (-0.78780384460872937555e-2 + (-0.14364940764532853112e-4 + (0.90803709228265217384e-6 + (-0.10298832847014466907e-7 + (0.53981671221969478551e-10 + (0.21342751381333333333e-12 - 0.82975901848387729274e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 72: {
      double t = 2*y100 - 145;
      return 0.38922115269731446690e0 + (-0.79249269708242064120e-2 + (-0.91595258799106970453e-5 + (0.82783535102217576495e-6 + (-0.97484311059617744437e-8 + (0.55889029041660225629e-10 + (0.10851981336888888889e-12 - 0.67278553237853459757e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 73: {
      double t = 2*y100 - 147;
      return 0.37334112915460307335e0 + (-0.79519385109223148791e-2 + (-0.44219833548840469752e-5 + (0.75209719038240314732e-6 + (-0.91848251458553190451e-8 + (0.56663266668051433844e-10 + (0.23995894257777777778e-13 - 0.53819475285389344313e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 74: {
      double t = 2*y100 - 149;
      return 0.35742543583374223085e0 + (-0.79608906571527956177e-2 + (-0.12530071050975781198e-6 + (0.68088605744900552505e-6 + (-0.86181844090844164075e-8 + (0.56530784203816176153e-10 + (-0.43120012248888888890e-13 - 0.42372603392496813810e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 75: {
      double t = 2*y100 - 151;
      return 0.34150846431979618536e0 + (-0.79534924968773806029e-2 + (0.37576885610891515813e-5 + (0.61419263633090524326e-6 + (-0.80565865409945960125e-8 + (0.55684175248749269411e-10 + (-0.95486860764444444445e-13 - 0.32712946432984510595e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 76: {
      double t = 2*y100 - 153;
      return 0.32562129649136346824e0 + (-0.79313448067948884309e-2 + (0.72539159933545300034e-5 + (0.55195028297415503083e-6 + (-0.75063365335570475258e-8 + (0.54281686749699595941e-10 - 0.13545424295111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 77: {
      double t = 2*y100 - 155;
      return 0.30979191977078391864e0 + (-0.78959416264207333695e-2 + (0.10389774377677210794e-4 + (0.49404804463196316464e-6 + (-0.69722488229411164685e-8 + (0.52469254655951393842e-10 - 0.16507860650666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 78: {
      double t = 2*y100 - 157;
      return 0.29404543811214459904e0 + (-0.78486728990364155356e-2 + (0.13190885683106990459e-4 + (0.44034158861387909694e-6 + (-0.64578942561562616481e-8 + (0.50354306498006928984e-10 - 0.18614473550222222222e-12 * t) * t) * t) * t) * t) * t;
    }
    case 79: {
      double t = 2*y100 - 159;
      return 0.27840427686253660515e0 + (-0.77908279176252742013e-2 + (0.15681928798708548349e-4 + (0.39066226205099807573e-6 + (-0.59658144820660420814e-8 + (0.48030086420373141763e-10 - 0.20018995173333333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 80: {
      double t = 2*y100 - 161;
      return 0.26288838011163800908e0 + (-0.77235993576119469018e-2 + (0.17886516796198660969e-4 + (0.34482457073472497720e-6 + (-0.54977066551955420066e-8 + (0.45572749379147269213e-10 - 0.20852924954666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 81: {
      double t = 2*y100 - 163;
      return 0.24751539954181029717e0 + (-0.76480877165290370975e-2 + (0.19827114835033977049e-4 + (0.30263228619976332110e-6 + (-0.50545814570120129947e-8 + (0.43043879374212005966e-10 - 0.21228012028444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 82: {
      double t = 2*y100 - 165;
      return 0.23230087411688914593e0 + (-0.75653060136384041587e-2 + (0.21524991113020016415e-4 + (0.26388338542539382413e-6 + (-0.46368974069671446622e-8 + (0.40492715758206515307e-10 - 0.21238627815111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 83: {
      double t = 2*y100 - 167;
      return 0.21725840021297341931e0 + (-0.74761846305979730439e-2 + (0.23000194404129495243e-4 + (0.22837400135642906796e-6 + (-0.42446743058417541277e-8 + (0.37958104071765923728e-10 - 0.20963978568888888889e-12 * t) * t) * t) * t) * t) * t;
    }
    case 84: {
      double t = 2*y100 - 169;
      return 0.20239979200788191491e0 + (-0.73815761980493466516e-2 + (0.24271552727631854013e-4 + (0.19590154043390012843e-6 + (-0.38775884642456551753e-8 + (0.35470192372162901168e-10 - 0.20470131678222222222e-12 * t) * t) * t) * t) * t) * t;
    }
    case 85: {
      double t = 2*y100 - 171;
      return 0.18773523211558098962e0 + (-0.72822604530339834448e-2 + (0.25356688567841293697e-4 + (0.16626710297744290016e-6 + (-0.35350521468015310830e-8 + (0.33051896213898864306e-10 - 0.19811844544000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 86: {
      double t = 2*y100 - 173;
      return 0.17327341258479649442e0 + (-0.71789490089142761950e-2 + (0.26272046822383820476e-4 + (0.13927732375657362345e-6 + (-0.32162794266956859603e-8 + (0.30720156036105652035e-10 - 0.19034196304000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 87: {
      double t = 2*y100 - 175;
      return 0.15902166648328672043e0 + (-0.70722899934245504034e-2 + (0.27032932310132226025e-4 + (0.11474573347816568279e-6 + (-0.29203404091754665063e-8 + (0.28487010262547971859e-10 - 0.18174029063111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 88: {
      double t = 2*y100 - 177;
      return 0.14498609036610283865e0 + (-0.69628725220045029273e-2 + (0.27653554229160596221e-4 + (0.92493727167393036470e-7 + (-0.26462055548683583849e-8 + (0.26360506250989943739e-10 - 0.17261211260444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 89: {
      double t = 2*y100 - 179;
      return 0.13117165798208050667e0 + (-0.68512309830281084723e-2 + (0.28147075431133863774e-4 + (0.72351212437979583441e-7 + (-0.23927816200314358570e-8 + (0.24345469651209833155e-10 - 0.16319736960000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 90: {
      double t = 2*y100 - 181;
      return 0.11758232561160626306e0 + (-0.67378491192463392927e-2 + (0.28525664781722907847e-4 + (0.54156999310046790024e-7 + (-0.21589405340123827823e-8 + (0.22444150951727334619e-10 - 0.15368675584000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 91: {
      double t = 2*y100 - 183;
      return 0.10422112945361673560e0 + (-0.66231638959845581564e-2 + (0.28800551216363918088e-4 + (0.37758983397952149613e-7 + (-0.19435423557038933431e-8 + (0.20656766125421362458e-10 - 0.14422990012444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 92: {
      double t = 2*y100 - 185;
      return 0.91090275493541084785e-1 + (-0.65075691516115160062e-2 + (0.28982078385527224867e-4 + (0.23014165807643012781e-7 + (-0.17454532910249875958e-8 + (0.18981946442680092373e-10 - 0.13494234691555555556e-12 * t) * t) * t) * t) * t) * t;
    }
    case 93: {
      double t = 2*y100 - 187;
      return 0.78191222288771379358e-1 + (-0.63914190297303976434e-2 + (0.29079759021299682675e-4 + (0.97885458059415717014e-8 + (-0.15635596116134296819e-8 + (0.17417110744051331974e-10 - 0.12591151763555555556e-12 * t) * t) * t) * t) * t) * t;
    }
    case 94: {
      double t = 2*y100 - 189;
      return 0.65524757106147402224e-1 + (-0.62750311956082444159e-2 + (0.29102328354323449795e-4 + (-0.20430838882727954582e-8 + (-0.13967781903855367270e-8 + (0.15958771833747057569e-10 - 0.11720175765333333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 95: {
      double t = 2*y100 - 191;
      return 0.53091065838453612773e-1 + (-0.61586898417077043662e-2 + (0.29057796072960100710e-4 + (-0.12597414620517987536e-7 + (-0.12440642607426861943e-8 + (0.14602787128447932137e-10 - 0.10885859114666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 96: {
      double t = 2*y100 - 193;
      return 0.40889797115352738582e-1 + (-0.60426484889413678200e-2 + (0.28953496450191694606e-4 + (-0.21982952021823718400e-7 + (-0.11044169117553026211e-8 + (0.13344562332430552171e-10 - 0.10091231402844444444e-12 * t) * t) * t) * t) * t) * t;
    }
  case 97: case 98:
  case 99: case 100: { // use Taylor expansion for small x (|x| <= 0.0309...)
      //  (2/sqrt(pi)) * (x - 2/3 x^3  + 4/15 x^5  - 8/105 x^7 + 16/945 x^9)
      double x2 = x*x;
      return x * (1.1283791670955125739
                  - x2 * (0.75225277806367504925
                          - x2 * (0.30090111122547001970
                                  - x2 * (0.085971746064420005629
                                          - x2 * 0.016931216931216931217))));
    }
  }
  /* Since 0 <= y100 < 101, this is only reached if x is NaN,
     in which case we should return NaN. */
  return NaN;
}

double FADDEEVA(w_im)(double x)
{
  if (x >= 0) {
    if (x > 45) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x > 5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
    }
    return w_im_y100(100/(1+x), x);
  }
  else { // = -FADDEEVA(w_im)(-x)
    if (x < -45) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x < -5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
    }
    return -w_im_y100(100/(1-x), -x);
  }
}

/////////////////////////////////////////////////////////////////////////

// Compile with -DTEST_FADDEEVA to compile a little test program
#ifdef TEST_FADDEEVA

#ifdef __cplusplus
#  include <cstdio>
#else
#  include <stdio.h>
#endif

// compute relative error |b-a|/|a|, handling case of NaN and Inf,
static double relerr(double a, double b) {
  if (isnan(a) || isnan(b) || isinf(a) || isinf(b)) {
    if ((isnan(a) && !isnan(b)) || (!isnan(a) && isnan(b)) ||
        (isinf(a) && !isinf(b)) || (!isinf(a) && isinf(b)) ||
        (isinf(a) && isinf(b) && a*b < 0))
      return Inf; // "infinite" error
    return 0; // matching infinity/nan results counted as zero error
  }
  if (a == 0)
    return b == 0 ? 0 : Inf;
  else
    return fabs((b-a) / a);
}

int main(void) {
  double errmax_all = 0;
  {
    printf("############# w(z) tests #############\n");
#define NTST 57 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(624.2,-0.26123),
      C(-0.4,3.),
      C(0.6,2.),
      C(-1.,1.),
      C(-1.,-9.),
      C(-1.,9.),
      C(-0.0000000234545,1.1234),
      C(-3.,5.1),
      C(-53,30.1),
      C(0.0,0.12345),
      C(11,1),
      C(-22,-2),
      C(9,-28),
      C(21,-33),
      C(1e5,1e5),
      C(1e14,1e14),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(-6.01,0.01),
      C(-0.7,-0.7),
      C(2.611780000000000e+01, 4.540909610972489e+03),
      C(0.8e7,0.3e7),
      C(-20,-19.8081),
      C(1e-16,-1.1e-16),
      C(2.3e-8,1.3e-8),
      C(6.3,-1e-13),
      C(6.3,1e-20),
      C(1e-20,6.3),
      C(1e-20,16.3),
      C(9,1e-300),
      C(6.01,0.11),
      C(8.01,1.01e-10),
      C(28.01,1e-300),
      C(10.01,1e-200),
      C(10.01,-1e-200),
      C(10.01,0.99e-10),
      C(10.01,-0.99e-10),
      C(1e-20,7.01),
      C(-1,7.01),
      C(5.99,7.01),
      C(1,0),
      C(55,0),
      C(-0.1,0),
      C(1e-20,0),
      C(0,5e-14),
      C(0,51),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN)
    };
    cmplx w[NTST] = { /* w(z), computed with WolframAlpha
                                   ... note that WolframAlpha is problematic
                                   some of the above inputs, so I had to
                                   use the continued-fraction expansion
                                   in WolframAlpha in some cases, or switch
                                   to Maple */
      C(-3.78270245518980507452677445620103199303131110e-7,
        0.000903861276433172057331093754199933411710053155),
      C(0.1764906227004816847297495349730234591778719532788,
        -0.02146550539468457616788719893991501311573031095617),
      C(0.2410250715772692146133539023007113781272362309451,
        0.06087579663428089745895459735240964093522265589350),
      C(0.30474420525691259245713884106959496013413834051768,
        -0.20821893820283162728743734725471561394145872072738),
      C(7.317131068972378096865595229600561710140617977e34,
        8.321873499714402777186848353320412813066170427e34),
      C(0.0615698507236323685519612934241429530190806818395,
        -0.00676005783716575013073036218018565206070072304635),
      C(0.3960793007699874918961319170187598400134746631,
        -5.593152259116644920546186222529802777409274656e-9),
      C(0.08217199226739447943295069917990417630675021771804,
        -0.04701291087643609891018366143118110965272615832184),
      C(0.00457246000350281640952328010227885008541748668738,
        -0.00804900791411691821818731763401840373998654987934),
      C(0.8746342859608052666092782112565360755791467973338452,
        0.),
      C(0.00468190164965444174367477874864366058339647648741,
        0.0510735563901306197993676329845149741675029197050),
      C(-0.0023193175200187620902125853834909543869428763219,
        -0.025460054739731556004902057663500272721780776336),
      C(9.11463368405637174660562096516414499772662584e304,
        3.97101807145263333769664875189354358563218932e305),
      C(-4.4927207857715598976165541011143706155432296e281,
        -2.8019591213423077494444700357168707775769028e281),
      C(2.820947917809305132678577516325951485807107151e-6,
        2.820947917668257736791638444590253942253354058e-6),
      C(2.82094791773878143474039725787438662716372268e-15,
        2.82094791773878143474039725773333923127678361e-15),
      C(-0.0000563851289696244350147899376081488003110150498,
        -0.000169211755126812174631861529808288295454992688),
      C(-5.586035480670854326218608431294778077663867e-162,
        5.586035480670854326218608431294778077663867e-161),
      C(0.00016318325137140451888255634399123461580248456,
        -0.095232456573009287370728788146686162555021209999),
      C(0.69504753678406939989115375989939096800793577783885,
        -1.8916411171103639136680830887017670616339912024317),
      C(0.0001242418269653279656612334210746733213167234822,
        7.145975826320186888508563111992099992116786763e-7),
      C(2.318587329648353318615800865959225429377529825e-8,
        6.182899545728857485721417893323317843200933380e-8),
      C(-0.0133426877243506022053521927604277115767311800303,
        -0.0148087097143220769493341484176979826888871576145),
      C(1.00000000000000012412170838050638522857747934,
        1.12837916709551279389615890312156495593616433e-16),
      C(0.9999999853310704677583504063775310832036830015,
        2.595272024519678881897196435157270184030360773e-8),
      C(-1.4731421795638279504242963027196663601154624e-15,
        0.090727659684127365236479098488823462473074709),
      C(5.79246077884410284575834156425396800754409308e-18,
        0.0907276596841273652364790985059772809093822374),
      C(0.0884658993528521953466533278764830881245144368,
        1.37088352495749125283269718778582613192166760e-22),
      C(0.0345480845419190424370085249304184266813447878,
        2.11161102895179044968099038990446187626075258e-23),
      C(6.63967719958073440070225527042829242391918213e-36,
        0.0630820900592582863713653132559743161572639353),
      C(0.00179435233208702644891092397579091030658500743634,
        0.0951983814805270647939647438459699953990788064762),
      C(9.09760377102097999924241322094863528771095448e-13,
        0.0709979210725138550986782242355007611074966717),
      C(7.2049510279742166460047102593255688682910274423e-304,
        0.0201552956479526953866611812593266285000876784321),
      C(3.04543604652250734193622967873276113872279682e-44,
        0.0566481651760675042930042117726713294607499165),
      C(3.04543604652250734193622967873276113872279682e-44,
        0.0566481651760675042930042117726713294607499165),
      C(0.5659928732065273429286988428080855057102069081e-12,
        0.056648165176067504292998527162143030538756683302),
      C(-0.56599287320652734292869884280802459698927645e-12,
        0.0566481651760675042929985271621430305387566833029),
      C(0.0796884251721652215687859778119964009569455462,
        1.11474461817561675017794941973556302717225126e-22),
      C(0.07817195821247357458545539935996687005781943386550,
        -0.01093913670103576690766705513142246633056714279654),
      C(0.04670032980990449912809326141164730850466208439937,
        0.03944038961933534137558064191650437353429669886545),
      C(0.36787944117144232159552377016146086744581113103176,
        0.60715770584139372911503823580074492116122092866515),
      C(0,
        0.010259688805536830986089913987516716056946786526145),
      C(0.99004983374916805357390597718003655777207908125383,
        -0.11208866436449538036721343053869621153527769495574),
      C(0.99999999999999999999999999999999999999990000,
        1.12837916709551257389615890312154517168802603e-20),
      C(0.999999999999943581041645226871305192054749891144158,
        0),
      C(0.0110604154853277201542582159216317923453996211744250,
        0),
      C(0,0),
      C(0,0),
      C(0,0),
      C(Inf,0),
      C(0,0),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,0),
      C(NaN,NaN),
      C(NaN,NaN)
    };
    double errmax = 0;
    for (int i = 0; i < NTST; ++i) {
      cmplx fw = FADDEEVA(w)(z[i],0.);
      double re_err = relerr(creal(w[i]), creal(fw));
      double im_err = relerr(cimag(w[i]), cimag(fw));
      printf("w(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n",
             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]),
             re_err, im_err);
      if (re_err > errmax) errmax = re_err;
      if (im_err > errmax) errmax = im_err;
    }
    if (errmax > 1e-13) {
      printf("FAILURE -- relative error %g too large!\n", errmax);
      return 1;
    }
    printf("SUCCESS (max relative error = %g)\n", errmax);
    if (errmax > errmax_all) errmax_all = errmax;
  }
  {
#undef NTST
#define NTST 41 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(1,2),
      C(-1,2),
      C(1,-2),
      C(-1,-2),
      C(9,-28),
      C(21,-33),
      C(1e3,1e3),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(5.1e-3, 1e-8),
      C(-4.9e-3, 4.95e-3),
      C(4.9e-3, 0.5),
      C(4.9e-4, -0.5e1),
      C(-4.9e-5, -0.5e2),
      C(5.1e-3, 0.5),
      C(5.1e-4, -0.5e1),
      C(-5.1e-5, -0.5e2),
      C(1e-6,2e-6),
      C(0,2e-6),
      C(0,2),
      C(0,20),
      C(0,200),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(1e-3,NaN),
      C(7e-2,7e-2),
      C(7e-2,-7e-4),
      C(-9e-2,7e-4),
      C(-9e-2,9e-2),
      C(-7e-4,9e-2),
      C(7e-2,0.9e-2),
      C(7e-2,1.1e-2)
    };
    cmplx w[NTST] = { // erf(z[i]), evaluated with Maple
      C(-0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553),
      C(0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553),
      C(-0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553),
      C(0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553),
      C(0.3359473673830576996788000505817956637777e304,
        -0.1999896139679880888755589794455069208455e304),
      C(0.3584459971462946066523939204836760283645e278,
        0.3818954885257184373734213077678011282505e280),
      C(0.9996020422657148639102150147542224526887,
        0.00002801044116908227889681753993542916894856),
      C(-1, 0),
      C(1, 0),
      C(0.005754683859034800134412990541076554934877,
        0.1128349818335058741511924929801267822634e-7),
      C(-0.005529149142341821193633460286828381876955,
        0.005585388387864706679609092447916333443570),
      C(0.007099365669981359632319829148438283865814,
        0.6149347012854211635026981277569074001219),
      C(0.3981176338702323417718189922039863062440e8,
        -0.8298176341665249121085423917575122140650e10),
      C(-Inf,
        -Inf),
      C(0.007389128308257135427153919483147229573895,
        0.6149332524601658796226417164791221815139),
      C(0.4143671923267934479245651547534414976991e8,
        -0.8298168216818314211557046346850921446950e10),
      C(-Inf,
        -Inf),
      C(0.1128379167099649964175513742247082845155e-5,
        0.2256758334191777400570377193451519478895e-5),
      C(0,
        0.2256758334194034158904576117253481476197e-5),
      C(0,
        18.56480241457555259870429191324101719886),
      C(0,
        0.1474797539628786202447733153131835124599e173),
      C(0,
        Inf),
      C(1,0),
      C(-1,0),
      C(0,Inf),
      C(0,-Inf),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(0.07924380404615782687930591956705225541145,
        0.07872776218046681145537914954027729115247),
      C(0.07885775828512276968931773651224684454495,
        -0.0007860046704118224342390725280161272277506),
      C(-0.1012806432747198859687963080684978759881,
        0.0007834934747022035607566216654982820299469),
      C(-0.1020998418798097910247132140051062512527,
        0.1010030778892310851309082083238896270340),
      C(-0.0007962891763147907785684591823889484764272,
        0.1018289385936278171741809237435404896152),
      C(0.07886408666470478681566329888615410479530,
        0.01010604288780868961492224347707949372245),
      C(0.07886723099940260286824654364807981336591,
        0.01235199327873258197931147306290916629654)
    };
#define TST(f,isc)                                                      \
    printf("############# " #f "(z) tests #############\n");            \
    double errmax = 0;                                                  \
    for (int i = 0; i < NTST; ++i) {                                    \
      cmplx fw = FADDEEVA(f)(z[i],0.);                  \
      double re_err = relerr(creal(w[i]), creal(fw));                   \
      double im_err = relerr(cimag(w[i]), cimag(fw));                   \
      printf(#f "(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n", \
             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]), \
             re_err, im_err);                                           \
      if (re_err > errmax) errmax = re_err;                             \
      if (im_err > errmax) errmax = im_err;                             \
    }                                                                   \
    if (errmax > 1e-13) {                                               \
      printf("FAILURE -- relative error %g too large!\n", errmax);      \
      return 1;                                                         \
    }                                                                   \
    printf("Checking " #f "(x) special case...\n");                     \
    for (int i = 0; i < 10000; ++i) {                                   \
      double x = pow(10., -300. + i * 600. / (10000 - 1));              \
      double re_err = relerr(FADDEEVA_RE(f)(x),                         \
                             creal(FADDEEVA(f)(C(x,x*isc),0.)));        \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(-x),                               \
                      creal(FADDEEVA(f)(C(-x,x*isc),0.)));              \
      if (re_err > errmax) errmax = re_err;                             \
    }                                                                   \
    {                                                                   \
      double re_err = relerr(FADDEEVA_RE(f)(Inf),                       \
                             creal(FADDEEVA(f)(C(Inf,0.),0.))); \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(-Inf),                             \
                      creal(FADDEEVA(f)(C(-Inf,0.),0.)));               \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(NaN),                              \
                      creal(FADDEEVA(f)(C(NaN,0.),0.)));                \
      if (re_err > errmax) errmax = re_err;                             \
    }                                                                   \
    if (errmax > 1e-13) {                                               \
      printf("FAILURE -- relative error %g too large!\n", errmax);      \
      return 1;                                                         \
    }                                                                   \
    printf("SUCCESS (max relative error = %g)\n", errmax);              \
    if (errmax > errmax_all) errmax_all = errmax

    TST(erf, 1e-20);
  }
  {
    // since erfi just calls through to erf, just one test should
    // be sufficient to make sure I didn't screw up the signs or something
#undef NTST
#define NTST 1 // define instead of const for C compatibility
    cmplx z[NTST] = { C(1.234,0.5678) };
    cmplx w[NTST] = { // erfi(z[i]), computed with Maple
      C(1.081032284405373149432716643834106923212,
        1.926775520840916645838949402886591180834)
    };
    TST(erfi, 0);
  }
  {
    // since erfcx just calls through to w, just one test should
    // be sufficient to make sure I didn't screw up the signs or something
#undef NTST
#define NTST 1 // define instead of const for C compatibility
    cmplx z[NTST] = { C(1.234,0.5678) };
    cmplx w[NTST] = { // erfcx(z[i]), computed with Maple
      C(0.3382187479799972294747793561190487832579,
        -0.1116077470811648467464927471872945833154)
    };
    TST(erfcx, 0);
  }
  {
#undef NTST
#define NTST 30 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(1,2),
      C(-1,2),
      C(1,-2),
      C(-1,-2),
      C(9,-28),
      C(21,-33),
      C(1e3,1e3),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(5.1e-3, 1e-8),
      C(0,2e-6),
      C(0,2),
      C(0,20),
      C(0,200),
      C(2e-6,0),
      C(2,0),
      C(20,0),
      C(200,0),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(88,0)
    };
    cmplx w[NTST] = { // erfc(z[i]), evaluated with Maple
      C(1.536643565778565033991795559314192749442,
        5.049143703447034669543036958614140565553),
      C(0.4633564342214349660082044406858072505579,
        5.049143703447034669543036958614140565553),
      C(1.536643565778565033991795559314192749442,
        -5.049143703447034669543036958614140565553),
      C(0.4633564342214349660082044406858072505579,
        -5.049143703447034669543036958614140565553),
      C(-0.3359473673830576996788000505817956637777e304,
        0.1999896139679880888755589794455069208455e304),
      C(-0.3584459971462946066523939204836760283645e278,
        -0.3818954885257184373734213077678011282505e280),
      C(0.0003979577342851360897849852457775473112748,
        -0.00002801044116908227889681753993542916894856),
      C(2, 0),
      C(0, 0),
      C(0.9942453161409651998655870094589234450651,
        -0.1128349818335058741511924929801267822634e-7),
      C(1,
        -0.2256758334194034158904576117253481476197e-5),
      C(1,
        -18.56480241457555259870429191324101719886),
      C(1,
        -0.1474797539628786202447733153131835124599e173),
      C(1, -Inf),
      C(0.9999977432416658119838633199332831406314,
        0),
      C(0.004677734981047265837930743632747071389108,
        0),
      C(0.5395865611607900928934999167905345604088e-175,
        0),
      C(0, 0),
      C(0, 0),
      C(2, 0),
      C(1, -Inf),
      C(1, Inf),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, 0),
      C(1, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(0,0)
    };
    TST(erfc, 1e-20);
  }
  {
#undef NTST
#define NTST 48 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(2,1),
      C(-2,1),
      C(2,-1),
      C(-2,-1),
      C(-28,9),
      C(33,-21),
      C(1e3,1e3),
      C(-1000,-3001),
      C(1e-8, 5.1e-3),
      C(4.95e-3, -4.9e-3),
      C(5.1e-3, 5.1e-3),
      C(0.5, 4.9e-3),
      C(-0.5e1, 4.9e-4),
      C(-0.5e2, -4.9e-5),
      C(0.5e3, 4.9e-6),
      C(0.5, 5.1e-3),
      C(-0.5e1, 5.1e-4),
      C(-0.5e2, -5.1e-5),
      C(1e-6,2e-6),
      C(2e-6,0),
      C(2,0),
      C(20,0),
      C(200,0),
      C(0,4.9e-3),
      C(0,-5.1e-3),
      C(0,2e-6),
      C(0,-2),
      C(0,20),
      C(0,-200),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(39, 6.4e-5),
      C(41, 6.09e-5),
      C(4.9e7, 5e-11),
      C(5.1e7, 4.8e-11),
      C(1e9, 2.4e-12),
      C(1e11, 2.4e-14),
      C(1e13, 2.4e-16),
      C(1e300, 2.4e-303)
    };
    cmplx w[NTST] = { // dawson(z[i]), evaluated with Maple
      C(0.1635394094345355614904345232875688576839,
        -0.1531245755371229803585918112683241066853),
      C(-0.1635394094345355614904345232875688576839,
        -0.1531245755371229803585918112683241066853),
      C(0.1635394094345355614904345232875688576839,
        0.1531245755371229803585918112683241066853),
      C(-0.1635394094345355614904345232875688576839,
        0.1531245755371229803585918112683241066853),
      C(-0.01619082256681596362895875232699626384420,
        -0.005210224203359059109181555401330902819419),
      C(0.01078377080978103125464543240346760257008,
        0.006866888783433775382193630944275682670599),
      C(-0.5808616819196736225612296471081337245459,
        0.6688593905505562263387760667171706325749),
      C(Inf,
        -Inf),
      C(0.1000052020902036118082966385855563526705e-7,
        0.005100088434920073153418834680320146441685),
      C(0.004950156837581592745389973960217444687524,
        -0.004899838305155226382584756154100963570500),
      C(0.005100176864319675957314822982399286703798,
        0.005099823128319785355949825238269336481254),
      C(0.4244534840871830045021143490355372016428,
        0.002820278933186814021399602648373095266538),
      C(-0.1021340733271046543881236523269967674156,
        -0.00001045696456072005761498961861088944159916),
      C(-0.01000200120119206748855061636187197886859,
        0.9805885888237419500266621041508714123763e-8),
      C(0.001000002000012000023960527532953151819595,
        -0.9800058800588007290937355024646722133204e-11),
      C(0.4244549085628511778373438768121222815752,
        0.002935393851311701428647152230552122898291),
      C(-0.1021340732357117208743299813648493928105,
        -0.00001088377943049851799938998805451564893540),
      C(-0.01000200120119126652710792390331206563616,
        0.1020612612857282306892368985525393707486e-7),
      C(0.1000000000007333333333344266666666664457e-5,
        0.2000000000001333333333323199999999978819e-5),
      C(0.1999999999994666666666675199999999990248e-5,
        0),
      C(0.3013403889237919660346644392864226952119,
        0),
      C(0.02503136792640367194699495234782353186858,
        0),
      C(0.002500031251171948248596912483183760683918,
        0),
      C(0,0.004900078433419939164774792850907128053308),
      C(0,-0.005100088434920074173454208832365950009419),
      C(0,0.2000000000005333333333341866666666676419e-5),
      C(0,-48.16001211429122974789822893525016528191),
      C(0,0.4627407029504443513654142715903005954668e174),
      C(0,-Inf),
      C(0,0),
      C(-0,0),
      C(0, Inf),
      C(0, -Inf),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, 0),
      C(0, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(0.01282473148489433743567240624939698290584,
        -0.2105957276516618621447832572909153498104e-7),
      C(0.01219875253423634378984109995893708152885,
        -0.1813040560401824664088425926165834355953e-7),
      C(0.1020408163265306334945473399689037886997e-7,
        -0.1041232819658476285651490827866174985330e-25),
      C(0.9803921568627452865036825956835185367356e-8,
        -0.9227220299884665067601095648451913375754e-26),
      C(0.5000000000000000002500000000000000003750e-9,
        -0.1200000000000000001800000188712838420241e-29),
      C(5.00000000000000000000025000000000000000000003e-12,
        -1.20000000000000000000018000000000000000000004e-36),
      C(5.00000000000000000000000002500000000000000000e-14,
        -1.20000000000000000000000001800000000000000000e-42),
      C(5e-301, 0)
    };
    TST(Dawson, 1e-20);
  }
  printf("#####################################\n");
  printf("SUCCESS (max relative error = %g)\n", errmax_all);
}

#endif

#endif

//end file: faddeeva_mit.h


#endif /* XFIELDS_FADDEEVA_H */


// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2023.                   //
// ########################################### //

#ifndef XFIELDS_BIGAUSSIAN_H
#define XFIELDS_BIGAUSSIAN_H


// for quick test with gcc
//#include "constants.h" //only_for_context none
//#include "faddeeva.h" //only_for_context none
//#include "complex_error_function.h" //only_for_context none
//#include "compute_gx_gy.h" //only_for_context none

//from file: compute_gx_gy.h

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_COMPUTE_GX_GY
#define XFIELDS_COMPUTE_GX_GY

 static inline void compute_Gx_Gy(
        const double x,
        const double y,
        const double sigma_x,
        const double sigma_y,
        const double min_sigma_diff,
        const double Ex,
        const double Ey,
        double* Gx_ptr,
        double* Gy_ptr) {

    double Gx, Gy;

    if (fabs(sigma_x-sigma_y) < min_sigma_diff) {
        const double sigma = 0.5 * (sigma_x+sigma_y);
        if ((x*x + y*y) < 1e-14) {
            Gx = 1./(8 * PI * EPSILON_0 * sigma * sigma);
            Gy = Gx;
        }
	    else {
            Gx = 1/(2.*(x*x+y*y))*(y*Ey-x*Ex+1./(2*PI*EPSILON_0*sigma*sigma)
                    *x*x*exp(-(x*x+y*y)/(2.*sigma*sigma)));
            Gy = 1./(2*(x*x+y*y))*(x*Ex-y*Ey+1./(2*PI*EPSILON_0*sigma*sigma)
                    *y*y*exp(-(x*x+y*y)/(2.*sigma*sigma)));
	    }
    }
    else {
        const double Sig_11 = sigma_x*sigma_x;
        const double Sig_33 = sigma_y*sigma_y;

        Gx = -1./(2*(Sig_11-Sig_33))*(x*Ex+y*Ey+1./(2*PI*EPSILON_0)
                *(sigma_y/sigma_x*exp(-x*x/(2*Sig_11)-y*y/(2*Sig_33))-1.));
        Gy = 1./(2*(Sig_11-Sig_33))*(x*Ex+y*Ey+1./(2*PI*EPSILON_0)*
                (sigma_x/sigma_y*exp(-x*x/(2*Sig_11)-y*y/(2*Sig_33))-1.));

    }

    *Gx_ptr = Gx;
    *Gy_ptr = Gy;
}

#endif //XFIELDS_COMPUTE_GX_GY

//end file: compute_gx_gy.h


 static inline
void get_charge_density(const double x,
                      const double y,
                      const double sigma_x,
                      const double sigma_y,
                      double* rho)
{

  // this is a PDF
  double factor = 1 / (2*PI*sigma_x*sigma_y);
  double exp_x = exp(-x*x/(2*sigma_x*sigma_x));
  double exp_y = exp(-y*y/(2*sigma_y*sigma_y));
  *rho = factor * exp_x * exp_y;  // [m^-2]
}

 static inline
void get_transv_field_gauss_round(
    double sigma, double Delta_x, double Delta_y,
    double x, double y,
    double* Ex,
    double* Ey)
{
  double r2, temp;

  r2 = (x-Delta_x)*(x-Delta_x)+(y-Delta_y)*(y-Delta_y);
  if (r2<1e-20) temp = sqrt(r2)/(2.*PI*EPSILON_0*sigma); //linearised
  else          temp = (1-exp(-0.5*r2/(sigma*sigma)))/(2.*PI*EPSILON_0*r2);

  (*Ex) = temp * (x-Delta_x);
  (*Ey) = temp * (y-Delta_y);
}

 static inline
void get_transv_field_gauss_ellip(
        double sigma_x,  double sigma_y,
        double Delta_x,  double Delta_y,
        const double x,
	const double y,
        double* Ex_out,
        double* Ey_out)
{
  double sigmax = sigma_x;
  double sigmay = sigma_y;

  // I always go to the first quadrant and then apply the signs a posteriori
  // numerically more stable (see http://inspirehep.net/record/316705/files/slac-pub-5582.pdf)

  double abx = fabs(x - Delta_x);
  double aby = fabs(y - Delta_y);

  double S, factBE, Ex, Ey;
  double etaBE_re, etaBE_im, zetaBE_re, zetaBE_im;
  double w_etaBE_re, w_etaBE_im, w_zetaBE_re, w_zetaBE_im;
  double expBE;


  if (sigmax>sigmay){
    S = sqrt(2.*(sigmax*sigmax-sigmay*sigmay));
    factBE = 1./(2.*EPSILON_0*SQRT_PI*S);

    etaBE_re = sigmay/sigmax*abx;
    etaBE_im = sigmax/sigmay*aby;

    zetaBE_re = abx;
    zetaBE_im = aby;

    //w_zetaBE_re, w_zetaBE_im = wfun(zetaBE_re/S, zetaBE_im/S)
    faddeeva_w(zetaBE_re/S, zetaBE_im/S , &(w_zetaBE_re), &(w_zetaBE_im));

    //w_etaBE_re, w_etaBE_im = wfun(etaBE_re/S, etaBE_im/S)
    faddeeva_w(etaBE_re/S, etaBE_im/S , &(w_etaBE_re), &(w_etaBE_im));

    expBE = exp(-abx*abx/(2*sigmax*sigmax)-aby*aby/(2*sigmay*sigmay));

    Ex = factBE*(w_zetaBE_im - w_etaBE_im*expBE);
    Ey = factBE*(w_zetaBE_re - w_etaBE_re*expBE);

  }
  else if (sigmax<sigmay){
    S = sqrt(2.*(sigmay*sigmay-sigmax*sigmax));
    factBE = 1./(2.*EPSILON_0*SQRT_PI*S);

    etaBE_re = sigmax/sigmay*aby;
    etaBE_im = sigmay/sigmax*abx;

    zetaBE_re = aby;
    zetaBE_im = abx;

    //w_zetaBE_re, w_zetaBE_im = wfun(zetaBE_re/S, zetaBE_im/S)
    faddeeva_w(zetaBE_re/S, zetaBE_im/S , &(w_zetaBE_re), &(w_zetaBE_im));

    //w_etaBE_re, w_etaBE_im = wfun(etaBE_re/S, etaBE_im/S)
    faddeeva_w(etaBE_re/S, etaBE_im/S , &(w_etaBE_re), &(w_etaBE_im));

    expBE = exp(-aby*aby/(2*sigmay*sigmay)-abx*abx/(2*sigmax*sigmax));

    Ey = factBE*(w_zetaBE_im - w_etaBE_im*expBE);
    Ex = factBE*(w_zetaBE_re - w_etaBE_re*expBE);

  }
  else{
    Ex = Ey = 0.;
  }

  if((x - Delta_x)<0) Ex=-Ex;
  if((y - Delta_y)<0) Ey=-Ey;

  (*Ex_out) = Ex;
  (*Ey_out) = Ey;
}

 static inline
void get_Ex_Ey_gauss(
             const double  x,
             const double  y,
             const double  sigma_x,
             const double  sigma_y,
             const double  min_sigma_diff,
             double* Ex_ptr,
             double* Ey_ptr){

        // round beam
	if (fabs(sigma_x-sigma_y)< min_sigma_diff){
	    double sigma = 0.5*(sigma_x+sigma_y);
	    	get_transv_field_gauss_round(sigma, 0., 0., x, y, Ex_ptr, Ey_ptr);
	}

        // elliptical beam
	else{
	    get_transv_field_gauss_ellip(
	            sigma_x, sigma_y, 0., 0., x, y, Ex_ptr, Ey_ptr);

	}
}

#endif // XFIELDS_BIGAUSSIAN_H

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_BEAMBEAM_H
#define XFIELDS_BEAMBEAM_H

#if !defined(mysign)
    #define mysign(a) (((a) >= 0) - ((a) < 0))
#endif

 static inline
void BeamBeamBiGaussian2D_track_local_particle(
        BeamBeamBiGaussian2DData el, LocalParticle* part0){

    double const ref_shift_x = BeamBeamBiGaussian2DData_get_ref_shift_x(el);
    double const ref_shift_y = BeamBeamBiGaussian2DData_get_ref_shift_y(el);

    double const other_beam_shift_x = BeamBeamBiGaussian2DData_get_other_beam_shift_x(el);
    double const other_beam_shift_y = BeamBeamBiGaussian2DData_get_other_beam_shift_y(el);

    double const scale_strength = BeamBeamBiGaussian2DData_get_scale_strength(el);
    double const post_subtract_px = scale_strength*BeamBeamBiGaussian2DData_get_post_subtract_px(el);
    double const post_subtract_py = scale_strength*BeamBeamBiGaussian2DData_get_post_subtract_py(el);

    double const other_beam_q0 = scale_strength*BeamBeamBiGaussian2DData_get_other_beam_q0(el);
    double const other_beam_beta0 = BeamBeamBiGaussian2DData_get_other_beam_beta0(el);

    double const other_beam_num_particles = BeamBeamBiGaussian2DData_get_other_beam_num_particles(el);

    double const other_beam_Sigma_11 = BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(el);
    double const other_beam_Sigma_13 = BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(el);
    double const other_beam_Sigma_33 = BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(el);

    double const min_sigma_diff = BeamBeamBiGaussian2DData_get_min_sigma_diff(el);


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp


        double const x = LocalParticle_get_x(part);
        double const y = LocalParticle_get_y(part);
        double const part_q0 = LocalParticle_get_q0(part);
        double const part_mass0 = LocalParticle_get_mass0(part);
        double const part_chi = LocalParticle_get_chi(part);
        double const part_beta0 = LocalParticle_get_beta0(part);
        double const part_gamma0 = LocalParticle_get_gamma0(part);

        double const x_bar = x - ref_shift_x - other_beam_shift_x;
        double const y_bar = y - ref_shift_y - other_beam_shift_y;

        // Move to rotated frame to account for transverse coupling (if needed)
        double x_hat, y_hat, costheta, sintheta, Sig_11_hat, Sig_33_hat;
        if (fabs(other_beam_Sigma_13) > 1e-13) {
            double const R = other_beam_Sigma_11 - other_beam_Sigma_33;
            double const W = other_beam_Sigma_11 + other_beam_Sigma_33;
            double const T = R * R + 4 * other_beam_Sigma_13 * other_beam_Sigma_13;
            double const sqrtT = sqrt(T);
            double const signR = mysign(R);
            double const cos2theta = signR*R/sqrtT;
            costheta = sqrt(0.5*(1.+cos2theta));
            sintheta = signR*mysign(other_beam_Sigma_13)*sqrt(0.5*(1.-cos2theta));
            x_hat = x_bar*costheta +y_bar*sintheta;
            y_hat = -x_bar*sintheta +y_bar*costheta;
            Sig_11_hat = 0.5*(W+signR*sqrtT);
            Sig_33_hat = 0.5*(W-signR*sqrtT);
        }
        else{
            sintheta = 0;
            costheta = 1;
            x_hat = x_bar;
            y_hat = y_bar;
            Sig_11_hat = other_beam_Sigma_11;
            Sig_33_hat = other_beam_Sigma_33;
        }

        // Get transverse fields
        double Ex, Ey; // Ex = -dphi/dx, Ey = -dphi/dy
        get_Ex_Ey_gauss(x_hat, y_hat,
            sqrt(Sig_11_hat), sqrt(Sig_33_hat),
            min_sigma_diff,
            &Ex, &Ey);

        const double charge_mass_ratio = part_chi*QELEM*part_q0
                    /(part_mass0*QELEM/(C_LIGHT*C_LIGHT));
        const double factor = (charge_mass_ratio
                    * other_beam_num_particles * other_beam_q0 * QELEM
                    / (part_gamma0*part_beta0*C_LIGHT*C_LIGHT)
                    * (1+other_beam_beta0 * part_beta0)
                    / (other_beam_beta0 + part_beta0));

        double const dpx_hat = factor * Ex;
        double const dpy_hat = factor * Ey;

        double const dpx = dpx_hat*costheta - dpy_hat*sintheta;
        double const dpy = dpx_hat*sintheta + dpy_hat*costheta;

        LocalParticle_add_to_px(part, dpx - post_subtract_px);
        LocalParticle_add_to_py(part, dpy - post_subtract_py);


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}

#endif


             
            void BeamBeamBiGaussian2D_track_particles(
               BeamBeamBiGaussian2DData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              BeamBeamBiGaussian2D_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_CavityData
#define XOBJ_TYPEDEF_CavityData
typedef   struct CavityData_s * CavityData;
 static inline CavityData CavityData_getp(CavityData restrict  obj){
  int64_t offset=0;
  return (CavityData)(( char*) obj+offset);
}
 static inline double CavityData_get_voltage(const CavityData restrict  obj){
  int64_t offset=0;
  return *( double*)(( char*) obj+offset);
}
 static inline void CavityData_set_voltage(CavityData restrict  obj, double value){
  int64_t offset=0;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* CavityData_getp_voltage(CavityData restrict  obj){
  int64_t offset=0;
  return ( double*)(( char*) obj+offset);
}
 static inline double CavityData_get_frequency(const CavityData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( double*)(( char*) obj+offset);
}
 static inline void CavityData_set_frequency(CavityData restrict  obj, double value){
  int64_t offset=0;
  offset+=8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* CavityData_getp_frequency(CavityData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( double*)(( char*) obj+offset);
}
 static inline double CavityData_get_lag(const CavityData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( double*)(( char*) obj+offset);
}
 static inline void CavityData_set_lag(CavityData restrict  obj, double value){
  int64_t offset=0;
  offset+=16;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* CavityData_getp_lag(CavityData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( double*)(( char*) obj+offset);
}
 static inline double CavityData_get_lag_taper(const CavityData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( double*)(( char*) obj+offset);
}
 static inline void CavityData_set_lag_taper(CavityData restrict  obj, double value){
  int64_t offset=0;
  offset+=24;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* CavityData_getp_lag_taper(CavityData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CAVITY_H
#define XTRACK_CAVITY_H

 static inline
void Cavity_track_local_particle(CavityData el, LocalParticle* part0){

    #ifndef XSUITE_BACKTRACK
    double const K_FACTOR = ( ( double )2.0 *PI ) / C_LIGHT;
    #else
    double const K_FACTOR = -( ( double )2.0 *PI ) / C_LIGHT;
    #endif
    double const volt = CavityData_get_voltage(el);
    double const freq = CavityData_get_frequency(el);
    double const lag = CavityData_get_lag(el);
    double const lag_taper = CavityData_get_lag_taper(el);

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp


        double const   beta0  = LocalParticle_get_beta0(part);
        double const   zeta   = LocalParticle_get_zeta(part);
        double const   q      = fabs(LocalParticle_get_q0(part))
                		        * LocalParticle_get_charge_ratio(part);
        double const   tau    = zeta / beta0;

        double const   phase  = DEG2RAD  * (lag + lag_taper) - K_FACTOR * freq * tau;

        double const energy   = q * volt * sin(phase);

        #ifdef XTRACK_CAVITY_PRESERVE_ANGLE
        LocalParticle_add_to_energy(part, energy, 0);
        #else
        LocalParticle_add_to_energy(part, energy, 1);
        #endif


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}

#endif


             
            void Cavity_track_particles(
               CavityData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              Cavity_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_DipoleEdgeData
#define XOBJ_TYPEDEF_DipoleEdgeData
typedef   struct DipoleEdgeData_s * DipoleEdgeData;
 static inline DipoleEdgeData DipoleEdgeData_getp(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  return (DipoleEdgeData)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_r21(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_r21(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_r21(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_r43(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_r43(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_r43(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_hgap(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_hgap(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=16;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_hgap(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_k(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_k(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=24;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_k(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_e1(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_e1(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=32;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_e1(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_e1_fd(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_e1_fd(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=40;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_e1_fd(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( double*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_fint(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_fint(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=48;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_fint(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t DipoleEdgeData_get_model(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_model(DipoleEdgeData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=56;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* DipoleEdgeData_getp_model(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t DipoleEdgeData_get_side(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_side(DipoleEdgeData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=64;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* DipoleEdgeData_getp_side(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double DipoleEdgeData_get_delta_taper(const DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return *( double*)(( char*) obj+offset);
}
 static inline void DipoleEdgeData_set_delta_taper(DipoleEdgeData restrict  obj, double value){
  int64_t offset=0;
  offset+=72;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DipoleEdgeData_getp_delta_taper(DipoleEdgeData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_TRACK_YROTATION_H
#define XTRACK_TRACK_YROTATION_H

 static inline
void YRotation_single_particle(LocalParticle* part, double sin_angle, double cos_angle, double tan_angle){

    double const beta0 = LocalParticle_get_beta0(part);
    double const beta = LocalParticle_get_rvv(part)*beta0;
    double const x  = LocalParticle_get_x(part);
    double const y  = LocalParticle_get_y(part);
    double const px = LocalParticle_get_px(part);
    double const py = LocalParticle_get_py(part);
    double const t = LocalParticle_get_zeta(part)/beta0;
    double const pt = LocalParticle_get_pzeta(part)*beta0;

    double pz = sqrt(1.0 + 2.0*pt/beta + pt*pt - px*px - py*py);
    double ptt = 1.0 - tan_angle*px/pz;
    double x_hat = x/(cos_angle*ptt);
    double px_hat = cos_angle*px + sin_angle*pz;
    double y_hat = y + tan_angle*x*py/(pz*ptt);
    double t_hat = t - tan_angle*x*(1.0/beta+pt)/(pz*ptt);

    LocalParticle_set_x(part, x_hat);
    LocalParticle_set_px(part, px_hat);
    LocalParticle_set_y(part, y_hat);
    LocalParticle_set_zeta(part,t_hat*beta0);

}

#endif /* XTRACK_TRACK_YROTATION_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_WEDGE_TRACK_H
#define XTRACK_WEDGE_TRACK_H

#define POW2(X) ((X)*(X))

 static inline
void Wedge_single_particle(
        LocalParticle* part,  // LocalParticle to track
        const double theta,   // Angle of the wedge
        const double k0       // Dipole strength
) {
    if (fabs(k0) < 10e-10) {
        const double sin_ = sin(theta);
        const double cos_ = cos(theta);
        const double tan_ = tan(theta);
        YRotation_single_particle(part, sin_, cos_, tan_);
        return;
    }

    // Params
    const double b1 = k0;

    const double rvv = LocalParticle_get_rvv(part);
    // Particle coordinates
    const double x = LocalParticle_get_x(part);
    const double px = LocalParticle_get_px(part);
    const double py = LocalParticle_get_py(part);

    // Useful constants
    const double one_plus_delta = LocalParticle_get_delta(part) + 1.0;
    const double A = 1.0 / sqrt(POW2(one_plus_delta) - POW2(py));
    const double pz = sqrt(POW2(one_plus_delta) - POW2(px) - POW2(py));

    // Map
    const double new_px = px * cos(theta) + (pz - b1 * x) * sin(theta);

    const double new_pz = sqrt(POW2(one_plus_delta) - POW2(new_px) - POW2(py));
    const double new_x = x * cos(theta) \
        + (x * px * sin(2 * theta) + POW2(sin(theta)) * (2 * x * pz - b1 * POW2(x))) \
          / (new_pz + pz * cos(theta) - px * sin(theta));
    const double D = asin(A * px) - asin(A * new_px);
    const double delta_y = py * (theta + D) / b1;
    const double delta_ell = one_plus_delta * (theta + D) / b1;

    // Update particle coordinates
    LocalParticle_set_x(part, new_x);
    LocalParticle_add_to_y(part, delta_y);
    LocalParticle_set_px(part, new_px);
    LocalParticle_add_to_zeta(part, -delta_ell / rvv);
}

#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FRINGE_TRACK_H
#define XTRACK_FRINGE_TRACK_H

#define POW2(X) ((X)*(X))
#define POW3(X) ((X)*(X)*(X))
#define POW4(X) ((X)*(X)*(X)*(X))


#ifndef XTRACK_FRINGE_FROM_PTC

// MAD-NG implementation
// https://github.com/MethodicalAcceleratorDesign/MAD/blob/d3cabd9cdebde62ebedb51bab61ac033b9159489/src/madl_dynmap.mad#L1864

 static inline
void Fringe_single_particle(
        LocalParticle* part,  // LocalParticle to track
        const double fint,    // Fringe field integral
        const double hgap,    // Half gap
        const double k0       // Dipole strength
) {
    if (fabs(k0) < 10e-10) {
        return;
    }

    const double beta0 = LocalParticle_get_beta0(part);

    // Particle coordinates
    const double x = LocalParticle_get_x(part);
    const double px = LocalParticle_get_px(part);
    const double y = LocalParticle_get_y(part);
    const double py = LocalParticle_get_py(part);
    const double t = LocalParticle_get_zeta(part) / beta0;
    const double pt = LocalParticle_get_ptau(part);
    const double delta = LocalParticle_get_delta(part);

    const double fh = hgap * fint;
    const double fsad = (fh > 10e-10) ? 1./(72 * fh) : 0;
    const double k0w = k0;

    const double _beta = 1. / beta0 ;
    const double b0 = k0w; // MAD does something with the charge (to be checked)

    const double dpp = POW2(1. + delta);
    const double pz = sqrt(dpp - POW2(px) - POW2(py));
    const double _pz = 1./pz;
    const double relp = 1./sqrt(dpp);
    const double tfac = -(_beta + pt);

    const double c2 = b0*fh*2;
    const double c3 = POW2(b0)*fsad*relp;

    const double xp = px/pz;
    const double yp = py/pz;
    const double xyp = xp*yp;
    const double yp2 = 1.+POW2(yp);
    const double xp2 = POW2(xp);
    const double _yp2 = 1./yp2;

    const double fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz;
    const double co2 = b0/POW2(cos(fi0));
    const double co1 = co2/(1 + POW2(xp*_yp2))*_yp2;
    const double co3 = co2*c2;

    const double fi1 =    co1          - co3*2*xp*(1+yp2)*pz;
    const double fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz;
    const double fi3 =                 - co3*(1 + xp2*(1+yp2));

    const double kx = fi1*(1+xp2)*_pz   + fi2*xyp*_pz       - fi3*xp;
    const double ky = fi1*xyp*_pz       + fi2*yp2*_pz       - fi3*yp;
    const double kz = fi1*tfac*xp*POW2(_pz) + fi2*tfac*yp*POW2(_pz) - fi3*tfac*_pz;

    const double new_y = 2 * y / (1 + sqrt(1 - 2 * ky * y));
    const double new_x  = x  + 0.5 * kx * POW2(new_y);
    const double new_py = py - 4 * c3 * POW3(new_y) - b0 * tan(fi0) * new_y;
    const double new_t = t + 0.5 * kz * POW2(new_y) + c3 * POW4(new_y) * POW2(relp) * tfac;

    const double new_zeta = new_t * beta0;

    LocalParticle_set_x(part, new_x);
    LocalParticle_set_y(part, new_y);
    LocalParticle_set_py(part, new_py);
    LocalParticle_set_zeta(part, new_zeta);
}

#endif // no XTRACK_FRINGE_FROM_PTC


#ifdef XTRACK_FRINGE_FROM_PTC
// The following is ported from PTC:
//https://github.com/MethodicalAcceleratorDesign/MAD-X/blob/master/libs/ptc/src/Sh_def_kind.f90#L4936

 static inline
void Fringe_single_particle(
        LocalParticle* part,  // LocalParticle to track
        const double fint,    // Fringe field integral
        const double hgap,    // Half gap
        const double k0       // Dipole strength
) {
    if (fabs(k0) < 10e-10) {
        return;
    }

    const double b = k0; // PTC naming convention

    double fsad=0.0;
    if(fint*hgap != 0.){
      fsad=1./(fint*hgap*2)/36.0;
    }

    // Particle coordinates
    const double beta0 = LocalParticle_get_beta0(part);
    const double x = LocalParticle_get_x(part);
    const double px = LocalParticle_get_px(part);
    const double y = LocalParticle_get_y(part);
    const double py = LocalParticle_get_py(part);
    const double ptau = LocalParticle_get_ptau(part);
    const double delta = LocalParticle_get_delta(part);

    const double pz = sqrt((1.0 + delta)*(1.0 + delta) - px * px - py * py);
    const double time_fac = 1/beta0 + ptau;
    const double rel_p = sqrt(1. + 2*ptau/beta0 + POW2(ptau));
    const double c3 = b * b * fsad / rel_p;

    const double xp = px / pz;
    const double yp = py / pz;

    const double D_1_1 = (1.0 + xp * xp) / pz;
    const double D_2_1 =  xp * yp / pz;
    const double D_3_1 = -xp;
    const double D_1_2 = xp * yp / pz;
    const double D_2_2 = (1.0 + yp * yp)/pz;
    const double D_3_2 = -yp;
    const double D_1_3 = -time_fac * xp / (pz * pz);
    const double D_2_3 = -time_fac * yp / (pz * pz);
    const double D_3_3 =  time_fac / pz;

    double fi0 = atan((xp / (1.0 + yp * yp)))-b * fint * hgap * 2.0 * ( 1.0 + xp * xp *(2.0 + yp * yp)) * pz;
    const double co2 = b / cos(fi0) / cos(fi0);
    const double co1 = co2 / (1.0 + POW2(xp / POW2(1.0 + yp * yp)));

    const double fi_1 = co1 / (1.0 + yp*yp) - co2 * b * fint * hgap * 2.0*(2.0 * xp * (2.0 + yp * yp) * pz);
    const double fi_2 = -co1 * 2.0 * xp * yp / POW2(1.0 + yp * yp) - co2 * b * fint * hgap * 2.0 * (2.0 * xp* xp * yp) * pz;
    const double fi_3 = -co2 * b * fint * hgap * 2.0 * (1.0 + xp * xp * (2.0 + yp*yp));

    fi0 = b * tan(fi0);

    double BB = 0;
    BB = fi_1 * D_1_2 + BB;
    BB = fi_2 * D_2_2 + BB;
    BB = fi_3 * D_3_2 + BB;

    const double new_y = 2.0 * y / (1.0 + sqrt(1.0 - 2.0 * BB * y));
    double new_py = py - fi0 * new_y;

    BB = 0;
    BB = fi_1 * D_1_1 + BB;
    BB = fi_2 * D_2_1 + BB;
    BB = fi_3 * D_3_1 + BB;
    const double new_x = x + 0.5 * BB * new_y * new_y;

    BB = 0;
    BB = fi_1 * D_1_3 + BB;
    BB = fi_2 * D_2_3 + BB;
    BB = fi_3 * D_3_3 + BB;
    double d_tau = -0.5 * BB * new_y * new_y;

    new_py = new_py - 4 * c3 * POW3(new_y);
    d_tau = d_tau + c3 * POW4(new_y) / POW2(rel_p) * time_fac;

    LocalParticle_set_x(part, new_x);
    LocalParticle_set_y(part, new_y);
    LocalParticle_set_py(part, new_py);
    LocalParticle_add_to_zeta(part, -d_tau * beta0); // PTC uses tau = ct
}
#endif // XTRACK_FRINGE_FROM_PTC


// The following is derived from https://cds.cern.ch/record/2857004
// still to be checked

//  static inline
// void Fringe_single_particle_paper(
//         LocalParticle* part,  // LocalParticle to track
//         const double fint,    // Fringe field integral
//         const double hgap,    // Half gap
//         const double k0       // Dipole strength
// ) {
//
//     if (fabs(k0) < 10e-10) {
//         return;
//     }
//
//     const double rvv = LocalParticle_get_rvv(part);
//     // Particle coordinates
//     const double y = LocalParticle_get_y(part);
//     const double px = LocalParticle_get_px(part);
//     const double py = LocalParticle_get_py(part);
//     const double delta = LocalParticle_get_delta(part);

//     const double one_plus_delta = delta + 1.0;

//     const double pz_sq = POW2(one_plus_delta) - POW2(px) - POW2(py);
//     const double pz = sqrt(pz_sq);
//     const double xp = px / pz;
//     const double yp = py / pz;

//     const double dpz_dpx = -xp;
//     const double dpz_dpy = -yp;
//     const double dpz_ddelta = one_plus_delta / pz;

//     const double dxp_dpx =    -px/pz_sq * dpz_dpx     + 1/pz;
//     const double dxp_dpy =    -px/pz_sq * dpz_dpy;
//     const double dxp_ddelta = -px/pz_sq * dpz_ddelta;

//     const double dyp_dpx =    -py/pz_sq * dpz_dpx;
//     const double dyp_dpy =    -py/pz_sq * dpz_dpy     + 1/pz;
//     const double dyp_ddelta = -py/pz_sq * dpz_ddelta;

//     const double phi0 = xp / (1 + POW2(yp));
//     const double dphi0_dxp = 1 / (1 + POW2(yp));
//     const double dphi0_dyp = -2 * xp * yp / POW2(1 + POW2(yp));

//     const double phi1 = 1 + 2 * POW2(xp) + POW2(xp) * POW2(yp);
//     const double dphi1_dxp = 4 * xp + 2 * POW2(yp) * xp;
//     const double dphi1_dyp = 2 * POW2(xp) * yp;

//     const double dphi0_dpx = dphi0_dxp * dxp_dpx + dphi0_dyp * dyp_dpx;
//     const double dphi0_dpy = dphi0_dxp * dxp_dpy + dphi0_dyp * dyp_dpy;
//     const double dphi0_ddelta = dphi0_dxp * dxp_ddelta + dphi0_dyp * dyp_ddelta;

//     const double dphi1_dpx = dphi1_dxp * dxp_dpx + dphi1_dyp * dyp_dpx;
//     const double dphi1_dpy = dphi1_dxp * dxp_dpy + dphi1_dyp * dyp_dpy;
//     const double dphi1_ddelta = dphi1_dxp * dxp_ddelta + dphi1_dyp * dyp_ddelta;

//     const double g = 2 * hgap;
//     const double Phi = k0 * atan(phi0) - g * k0 * k0 * fint * pz * phi1;
//     const double dPhi_dpx = k0 * 1 / (1 + POW2(phi0)) * dphi0_dpx
//                     - g * k0 * k0 * fint * (pz * dphi1_dpx + phi1 * dpz_dpx);
//     const double dPhi_dpy = k0 * 1 / (1 + POW2(phi0)) * dphi0_dpy
//                     - g * k0 * k0 * fint * (pz * dphi1_dpy + phi1 * dpz_dpy);
//     const double dPhi_ddelta = k0 * 1 / (1 + POW2(phi0)) * dphi0_ddelta
//                     - g * k0 * k0 * fint * (pz * dphi1_ddelta + phi1 * dpz_ddelta);

//     // printf("dPhi_dpy = %e\n", dPhi_dpy);
//     // printf("Phi = %e\n", Phi);

//     const double new_y = 2 * y / (1 + sqrt(1 - 2 * dPhi_dpy * y));
//     const double delta_x = dPhi_dpx * POW2(new_y) / 2;
//     const double delta_py = -Phi * new_y;
//     const double delta_zeta = - 1 / (2 * rvv) * dPhi_ddelta * POW2(new_y);

//     LocalParticle_add_to_x(part, delta_x);
//     LocalParticle_add_to_py(part, delta_py);
//     LocalParticle_add_to_zeta(part, delta_zeta);
//     LocalParticle_set_y(part, new_y);

// }

#endif // XTRACK_FRINGE_H
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_DIPOLEEDGE_H
#define XTRACK_DIPOLEEDGE_H

 static inline
void DipoleEdge_track_local_particle(DipoleEdgeData el, LocalParticle* part0){

    int64_t const model = DipoleEdgeData_get_model(el);

    #ifdef XTRACK_MULTIPOLE_NO_SYNRAD
    #define delta_taper (0)
    #else
        #ifndef XTRACK_DIPOLEEDGE_TAPER
        double const delta_taper = DipoleEdgeData_get_delta_taper(el);
        #endif
    #endif

    if (model == 0){
        double r21 = DipoleEdgeData_get_r21(el);
        double r43 = DipoleEdgeData_get_r43(el);

        #ifndef XTRACK_DIPOLEEDGE_TAPER
            r21 = r21 * (1 + delta_taper);
            r43 = r43 * (1 + delta_taper);
        #endif

        #ifdef XSUITE_BACKTRACK
            r21 = -r21;
            r43 = -r43;
        #endif


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

            double const x = LocalParticle_get_x(part);
            double const y = LocalParticle_get_y(part);

            #ifdef XTRACK_DIPOLEEDGE_TAPER
                double const delta_taper = LocalParticle_get_delta(part);
                r21 = r21 * (1 + delta_taper);
                r43 = r43 * (1 + delta_taper);
            #endif

            LocalParticle_add_to_px(part, r21*x);
            LocalParticle_add_to_py(part, r43*y);


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


    }
    else if (model == 1){

        #ifdef XSUITE_BACKTRACK

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                LocalParticle_kill_particle(part, -32);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            return;
        #else

        double const e1 = DipoleEdgeData_get_e1(el);
        double const fint = DipoleEdgeData_get_fint(el);
        double const hgap = DipoleEdgeData_get_hgap(el);
        double const k = DipoleEdgeData_get_k(el);
        int64_t const side = DipoleEdgeData_get_side(el);

        double sin_, cos_, tan_;
        if (fabs(e1) < 10e-10) {
            sin_ = -999.0; cos_ = -999.0; tan_ = -999.0;
        }
        else{
            sin_ = sin(e1); cos_ = cos(e1); tan_ = tan(e1);
        }

        if (side == 0){ // entry
            if (sin_ > -99.){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                    YRotation_single_particle(part, sin_, cos_, tan_);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            }

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                Fringe_single_particle(part, fint, hgap, k);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            if (sin_ > -99.){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                    Wedge_single_particle(part, -e1, k);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            }
        }
        else if (side == 1){ // exit
            if (sin_ > -99.){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                    Wedge_single_particle(part, -e1, k);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            }

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                Fringe_single_particle(part, fint, hgap, -k);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            if (sin_ > -99.){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

                    YRotation_single_particle(part, sin_, cos_, tan_);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

            }

        }
        #endif
    }

}

#endif


             
            void DipoleEdge_track_particles(
               DipoleEdgeData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              DipoleEdge_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_DriftData
#define XOBJ_TYPEDEF_DriftData
typedef   struct DriftData_s * DriftData;
 static inline DriftData DriftData_getp(DriftData restrict  obj){
  int64_t offset=0;
  return (DriftData)(( char*) obj+offset);
}
 static inline double DriftData_get_length(const DriftData restrict  obj){
  int64_t offset=0;
  return *( double*)(( char*) obj+offset);
}
 static inline void DriftData_set_length(DriftData restrict  obj, double value){
  int64_t offset=0;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* DriftData_getp_length(DriftData restrict  obj){
  int64_t offset=0;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_DRIFT_H
#define XTRACK_DRIFT_H


 static inline
void Drift_single_particle_expanded(LocalParticle* part, double length){
    double const rpp    = LocalParticle_get_rpp(part);
    double const rv0v    = 1./LocalParticle_get_rvv(part);
    double const xp     = LocalParticle_get_px(part) * rpp;
    double const yp     = LocalParticle_get_py(part) * rpp;
    double const dzeta  = 1 - rv0v * ( 1. + ( xp*xp + yp*yp ) / 2. );

    LocalParticle_add_to_x(part, xp * length );
    LocalParticle_add_to_y(part, yp * length );
    LocalParticle_add_to_s(part, length);
    LocalParticle_add_to_zeta(part, length * dzeta );
}


 static inline
void Drift_single_particle_exact(LocalParticle* part, double length){
    double const px = LocalParticle_get_px(part);
    double const py = LocalParticle_get_py(part);
    double const rv0v    = 1./LocalParticle_get_rvv(part);
    double const one_plus_delta = 1. + LocalParticle_get_delta(part);

    double const one_over_pz = 1./sqrt(one_plus_delta*one_plus_delta
                                       - px * px - py * py);
    double const dzeta = 1 - rv0v * one_plus_delta * one_over_pz;

    LocalParticle_add_to_x(part, px * one_over_pz * length);
    LocalParticle_add_to_y(part, py * one_over_pz * length);
    LocalParticle_add_to_zeta(part, dzeta * length);
    LocalParticle_add_to_s(part, length);
}


 static inline
void Drift_single_particle(LocalParticle* part, double length){
    #ifndef XTRACK_USE_EXACT_DRIFTS
        Drift_single_particle_expanded(part, length);
    #else
        Drift_single_particle_exact(part, length);
    #endif
}


#endif /* XTRACK_DRIFT_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_DRIFT_ELEM_H
#define XTRACK_DRIFT_ELEM_H

 static inline
void Drift_track_local_particle(DriftData el, LocalParticle* part0){

    double length = DriftData_get_length(el);
    #ifdef XSUITE_BACKTRACK
        length = -length;
    #endif


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        Drift_single_particle(part, length);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}


#endif /* XTRACK_DRIFT_ELEM_H */


             
            void Drift_track_particles(
               DriftData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              Drift_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_MarkerData
#define XOBJ_TYPEDEF_MarkerData
typedef   struct MarkerData_s * MarkerData;
 static inline MarkerData MarkerData_getp(MarkerData restrict  obj){
  int64_t offset=0;
  return (MarkerData)(( char*) obj+offset);
}
 static inline int64_t MarkerData_get__dummy(const MarkerData restrict  obj){
  int64_t offset=0;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void MarkerData_set__dummy(MarkerData restrict  obj, int64_t value){
  int64_t offset=0;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* MarkerData_getp__dummy(MarkerData restrict  obj){
  int64_t offset=0;
  return ( int64_t*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

 static inline
void Marker_track_local_particle(MarkerData el, LocalParticle* part0){}

             
            void Marker_track_particles(
               MarkerData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              Marker_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_ParticlesMonitorData
#define XOBJ_TYPEDEF_ParticlesMonitorData
typedef   struct ParticlesMonitorData_s * ParticlesMonitorData;
 static inline ParticlesMonitorData ParticlesMonitorData_getp(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  return (ParticlesMonitorData)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_start_at_turn(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_start_at_turn(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_start_at_turn(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_stop_at_turn(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_stop_at_turn(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=16;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_stop_at_turn(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_part_id_start(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_part_id_start(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=24;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_part_id_start(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_part_id_end(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_part_id_end(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_part_id_end(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_ebe_mode(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_ebe_mode(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=40;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_ebe_mode(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_n_records(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_n_records(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=48;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_n_records(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_n_repetitions(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_n_repetitions(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=56;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_n_repetitions(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_repetition_period(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_repetition_period(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=64;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_repetition_period(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_flag_auto_to_numpy(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_flag_auto_to_numpy(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=72;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_flag_auto_to_numpy(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ParticlesData ParticlesMonitorData_getp_data(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  return (ParticlesData)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_data__capacity(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__capacity(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=88;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_data__capacity(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_data__num_active_particles(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__num_active_particles(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=96;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_data__num_active_particles(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_data__num_lost_particles(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__num_lost_particles(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=104;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_data__num_lost_particles(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_get_data_start_tracking_at_element(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=112;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_start_tracking_at_element(ParticlesMonitorData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=112;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp_data_start_tracking_at_element(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=112;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double ParticlesMonitorData_get_data_q0(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=120;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_q0(ParticlesMonitorData restrict  obj, double value){
  int64_t offset=0;
  offset+=120;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp_data_q0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=120;
  return ( double*)(( char*) obj+offset);
}
 static inline double ParticlesMonitorData_get_data_mass0(const ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=128;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_mass0(ParticlesMonitorData restrict  obj, double value){
  int64_t offset=0;
  offset+=128;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp_data_mass0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=128;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_p0c(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=336;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_p0c(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=336;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_p0c(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=336;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_p0c(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=336;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_p0c(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=336;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_gamma0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_gamma0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_gamma0(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_gamma0(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_gamma0(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_beta0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_beta0(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_beta0(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_beta0(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_beta0(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_s(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_s(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_s(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_s(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_s(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_zeta(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_zeta(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_zeta(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_zeta(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_zeta(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_ptau(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_ptau(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_ptau(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_ptau(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_ptau(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_delta(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_delta(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_delta(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_delta(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_delta(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_rpp(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_rpp(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_rpp(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_rpp(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_rpp(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_rvv(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_rvv(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+112);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_rvv(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_rvv(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_rvv(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_chi(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_chi(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+120);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_chi(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_chi(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_chi(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+120);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_charge_ratio(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_charge_ratio(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+128);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_charge_ratio(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_charge_ratio(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_charge_ratio(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+128);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_weight(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_weight(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+136);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_weight(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_weight(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_weight(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+136);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_pdg_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_pdg_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+144);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_pdg_id(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_pdg_id(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_pdg_id(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+144);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_particle_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_particle_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+152);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_particle_id(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_particle_id(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_particle_id(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+152);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_at_element(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_at_element(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+160);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_at_element(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_at_element(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_at_element(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+160);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_at_turn(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_at_turn(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+168);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_at_turn(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_at_turn(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_at_turn(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+168);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_state(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_state(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+176);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_state(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_state(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_state(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+176);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 ParticlesMonitorData_getp_data_parent_particle_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_parent_particle_id(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+184);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t ParticlesMonitorData_get_data_parent_particle_id(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_parent_particle_id(ParticlesMonitorData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* ParticlesMonitorData_getp1_data_parent_particle_id(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+184);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesMonitorData_getp_data__rng_s1(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data__rng_s1(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+192);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesMonitorData_get_data__rng_s1(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__rng_s1(ParticlesMonitorData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesMonitorData_getp1_data__rng_s1(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+192);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesMonitorData_getp_data__rng_s2(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data__rng_s2(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+200);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesMonitorData_get_data__rng_s2(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__rng_s2(ParticlesMonitorData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesMonitorData_getp1_data__rng_s2(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+200);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesMonitorData_getp_data__rng_s3(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data__rng_s3(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+208);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesMonitorData_get_data__rng_s3(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__rng_s3(ParticlesMonitorData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesMonitorData_getp1_data__rng_s3(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+208);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNUint32 ParticlesMonitorData_getp_data__rng_s4(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  return (ArrNUint32)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data__rng_s4(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+216);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline uint32_t ParticlesMonitorData_get_data__rng_s4(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data__rng_s4(ParticlesMonitorData restrict  obj, int64_t i0, uint32_t value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* ParticlesMonitorData_getp1_data__rng_s4(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+216);
  offset+=16+i0*4;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_x(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_x(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+224);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_x(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_x(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_x(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+224);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_y(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_y(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+232);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_y(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_y(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_y(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+232);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_px(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_px(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+240);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_px(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_px(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_px(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+240);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 ParticlesMonitorData_getp_data_py(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t ParticlesMonitorData_len_data_py(ParticlesMonitorData restrict  obj){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+248);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double ParticlesMonitorData_get_data_py(const ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void ParticlesMonitorData_set_data_py(ParticlesMonitorData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* ParticlesMonitorData_getp1_data_py(ParticlesMonitorData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=80;
  offset+=*( int64_t*)(( char*) obj+offset+248);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_MONITORS_H
#define XTRACK_MONITORS_H

 static inline
void ParticlesMonitor_track_local_particle(ParticlesMonitorData el,
                       LocalParticle* part0){

    int64_t const start_at_turn = ParticlesMonitorData_get_start_at_turn(el);
    int64_t const stop_at_turn = ParticlesMonitorData_get_stop_at_turn(el);
    int64_t const part_id_start = ParticlesMonitorData_get_part_id_start(el);
    int64_t const part_id_end= ParticlesMonitorData_get_part_id_end(el);
    int64_t const ebe_mode = ParticlesMonitorData_get_ebe_mode(el);
    int64_t const n_repetitions = ParticlesMonitorData_get_n_repetitions(el);
    int64_t const repetition_period = ParticlesMonitorData_get_repetition_period(el);
    ParticlesData data = ParticlesMonitorData_getp_data(el);

    int64_t n_turns_record = stop_at_turn - start_at_turn;


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

    int64_t at_turn;
    if (ebe_mode){
        at_turn = LocalParticle_get_at_element(part);
    }
    else{
        #ifdef XSUITE_BACKTRACK
        return; // do not log (only ebe monitor supported for now in backtrack)
        #else
        at_turn = LocalParticle_get_at_turn(part);
        #endif
    }
    if (n_repetitions == 1){
        if (at_turn>=start_at_turn && at_turn<stop_at_turn){
            int64_t const particle_id = LocalParticle_get_particle_id(part);
            if (particle_id<part_id_end && particle_id>=part_id_start){
                int64_t const store_at =
                    n_turns_record * (particle_id - part_id_start)
                    + at_turn - start_at_turn;
                LocalParticle_to_Particles(part, data, store_at, 0);
            }
        }
    }
    else if (n_repetitions > 1){
        if (at_turn < start_at_turn){
//            return; //only_for_context cuda opencl
            break; //only_for_context cpu_serial cpu_openmp
        }
        int64_t const i_frame = (at_turn - start_at_turn) / repetition_period;
        if (i_frame < n_repetitions
                 && at_turn >= start_at_turn + i_frame*repetition_period
                 && at_turn < stop_at_turn + i_frame*repetition_period
             ){
            int64_t const particle_id = LocalParticle_get_particle_id(part);
            if (particle_id<part_id_end && particle_id>=part_id_start){
                int64_t const store_at =
                    n_turns_record * (part_id_end  - part_id_start) * i_frame
                    + n_turns_record * (particle_id - part_id_start)
                    + (at_turn - i_frame * repetition_period) - start_at_turn;
                LocalParticle_to_Particles(part, data, store_at, 0);
            }
        }
    }




//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}

#endif


             
            void ParticlesMonitor_track_particles(
               ParticlesMonitorData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              ParticlesMonitor_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_SRotationData
#define XOBJ_TYPEDEF_SRotationData
typedef   struct SRotationData_s * SRotationData;
 static inline SRotationData SRotationData_getp(SRotationData restrict  obj){
  int64_t offset=0;
  return (SRotationData)(( char*) obj+offset);
}
 static inline double SRotationData_get_cos_z(const SRotationData restrict  obj){
  int64_t offset=0;
  return *( double*)(( char*) obj+offset);
}
 static inline void SRotationData_set_cos_z(SRotationData restrict  obj, double value){
  int64_t offset=0;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* SRotationData_getp_cos_z(SRotationData restrict  obj){
  int64_t offset=0;
  return ( double*)(( char*) obj+offset);
}
 static inline double SRotationData_get_sin_z(const SRotationData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( double*)(( char*) obj+offset);
}
 static inline void SRotationData_set_sin_z(SRotationData restrict  obj, double value){
  int64_t offset=0;
  offset+=8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* SRotationData_getp_sin_z(SRotationData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( double*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_SROTATION_H
#define XTRACK_SROTATION_H


 static inline
void SRotation_single_particle(LocalParticle* part, double sin_z, double cos_z){

    double const x  = LocalParticle_get_x(part);
    double const y  = LocalParticle_get_y(part);
    double const px = LocalParticle_get_px(part);
    double const py = LocalParticle_get_py(part);

    double const x_hat  =  cos_z * x  + sin_z * y;
    double const y_hat  = -sin_z * x  + cos_z * y;
    double const px_hat =  cos_z * px + sin_z * py;
    double const py_hat = -sin_z * px + cos_z * py;

    LocalParticle_set_x(part, x_hat);
    LocalParticle_set_y(part, y_hat);
    LocalParticle_set_px(part, px_hat);
    LocalParticle_set_py(part, py_hat);

}


 static inline
void SRotation_track_local_particle(SRotationData el, LocalParticle* part0){

    double sin_z = SRotationData_get_sin_z(el);
    double cos_z = SRotationData_get_cos_z(el);

    #ifdef XSUITE_BACKTRACK
        sin_z = -sin_z;
    #endif


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        SRotation_single_particle(part, sin_z, cos_z);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}


#endif /* XTRACK_SROTATION_H */


             
            void SRotation_track_particles(
               SRotationData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              SRotation_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_RecordIdentifier
#define XOBJ_TYPEDEF_RecordIdentifier
typedef   struct RecordIdentifier_s * RecordIdentifier;
 static inline RecordIdentifier RecordIdentifier_getp(RecordIdentifier restrict  obj){
  int64_t offset=0;
  return (RecordIdentifier)(( char*) obj+offset);
}
 static inline int64_t RecordIdentifier_get_buffer_id(const RecordIdentifier restrict  obj){
  int64_t offset=0;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void RecordIdentifier_set_buffer_id(RecordIdentifier restrict  obj, int64_t value){
  int64_t offset=0;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* RecordIdentifier_getp_buffer_id(RecordIdentifier restrict  obj){
  int64_t offset=0;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t RecordIdentifier_get_offset(const RecordIdentifier restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void RecordIdentifier_set_offset(RecordIdentifier restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* RecordIdentifier_getp_offset(RecordIdentifier restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
#endif

 static inline
  int8_t* RecordIdentifier_getp_record(RecordIdentifier record_id, LocalParticle* part){
      int8_t* io_buffer = LocalParticle_get_io_buffer(part);
    if (io_buffer == NULL){
        return NULL;
    }

    int64_t buffer_id = RecordIdentifier_get_buffer_id(record_id);
      int64_t* found_id = (  int64_t*)io_buffer;
    if (buffer_id != (*found_id)){
        printf("Error: buffer_id mismatch!\n");
        return NULL;
    }

    int64_t offset = RecordIdentifier_get_offset(record_id);

    return io_buffer + offset;
    }


#ifndef XOBJ_TYPEDEF_RandomUniformData
#define XOBJ_TYPEDEF_RandomUniformData
typedef   struct RandomUniformData_s * RandomUniformData;
 static inline RandomUniformData RandomUniformData_getp(RandomUniformData restrict  obj){
  int64_t offset=0;
  return (RandomUniformData)(( char*) obj+offset);
}
 static inline uint8_t RandomUniformData_get__dummy(const RandomUniformData restrict  obj){
  int64_t offset=0;
  return *(( uint8_t*) obj+offset);
}
 static inline void RandomUniformData_set__dummy(RandomUniformData restrict  obj, uint8_t value){
  int64_t offset=0;
  *(( uint8_t*) obj+offset)=value;
}
 static inline  uint8_t* RandomUniformData_getp__dummy(RandomUniformData restrict  obj){
  int64_t offset=0;
  return ( uint8_t*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xpart Package.   //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XPART_BASE_RNG_H
#define XPART_BASE_RNG_H

//#include <stdint.h> //only_for_context none

// Combined LCG-Thausworthe generator from (example 37-4):
// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-37-efficient-random-number-generation-and-application
#define MASK 0xffffffffUL
#define TAUSWORTHE(s,a,b,c,d) ((((s) &c) <<d) &MASK) ^ (((((s) <<a) &MASK)^(s)) >>b)
#define LCG(s,A,C) ((((A*(s)) &MASK) + C) &MASK)


 static inline
double rng_get (uint32_t *s1, uint32_t *s2, uint32_t *s3, uint32_t *s4 ){
  *s1 = TAUSWORTHE (*s1, 13, 19, 4294967294UL, 12);  // p1=2^31-1
  *s2 = TAUSWORTHE (*s2, 2, 25, 4294967288UL, 4);    // p2=2^30-1
  *s3 = TAUSWORTHE (*s3, 3, 11, 4294967280UL, 17);   // p3=2^28-1
  *s4 = LCG(*s4, 1664525, 1013904223UL);             // p4=2^32

  // Combined period is lcm(p1,p2,p3,p4) ~ 2^121
  return ((*s1) ^ (*s2) ^ (*s3) ^ (*s4)) / 4294967296.0 ;
}

 static inline
void rng_set (uint32_t *s1, uint32_t *s2, uint32_t *s3, uint32_t *s4, uint32_t s ){
  *s1 = LCG (s, 69069, 0);
  if (*s1 < 2) *s1 += 2UL;
  *s2 = LCG (*s1, 69069, 0);
  if (*s2 < 8) *s2 += 8UL;
  *s3 = LCG (*s2, 69069, 0);
  if (*s3 < 16) *s3 += 16UL;
  *s4 = LCG (*s3, 69069, 0);

  /* "warm it up" */
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  rng_get (s1, s2, s3, s4);
  return;
}

#endif /* XPART_BASE_RNG_H */

 
// copyright ############################### //
// This file is part of the Xtrack Package.   //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_UNIFORM_RNG_H
#define XTRACK_UNIFORM_RNG_H
#include <stdlib.h> //only_for_context cpu_serial cpu_openmp
#include <math.h> //only_for_context cpu_serial cpu_openmp
#include <time.h> //only_for_context cpu_serial cpu_openmp


 static inline
int8_t assert_rng_set(LocalParticle* part, int64_t kill_state){
    int64_t s1 = LocalParticle_get__rng_s1(part);
    int64_t s2 = LocalParticle_get__rng_s2(part);
    int64_t s3 = LocalParticle_get__rng_s3(part);
    int64_t s4 = LocalParticle_get__rng_s4(part);
    if (s1==0 && s2==0 && s3==0 && s4==0) {
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}


 static inline
double RandomUniform_generate(LocalParticle* part){
    uint32_t s1 = LocalParticle_get__rng_s1(part);
    uint32_t s2 = LocalParticle_get__rng_s2(part);
    uint32_t s3 = LocalParticle_get__rng_s3(part);
    uint32_t s4 = LocalParticle_get__rng_s4(part);

    if (s1==0 && s2==0 && s3==0 && s4==0) {
        LocalParticle_kill_particle(part, RNG_ERR_SEEDS_NOT_SET);
        return 0;
    }

    double r = rng_get(&s1, &s2, &s3, &s4);

    LocalParticle_set__rng_s1(part, s1);
    LocalParticle_set__rng_s2(part, s2);
    LocalParticle_set__rng_s3(part, s3);
    LocalParticle_set__rng_s4(part, s4);

    return r;
}


 static inline
void RandomUniform_sample(RandomUniformData rng, LocalParticle* part0,
                               double* samples, int64_t n_samples_per_seed){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

    int i;
    for (i=0; i<n_samples_per_seed; ++i){
        double val = RandomUniform_generate(part);
        samples[n_samples_per_seed*LocalParticle_get_particle_id(part) + i] = val;
    }

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
void RandomUniform_track_local_particle(RandomUniformData rng, LocalParticle* part0) {
    kill_all_particles(part0, RNG_ERR_INVALID_TRACK);
}

#endif /* XTRACK_UNIFORM_RNG_H */


             
            void RandomUniform_track_particles(
               RandomUniformData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              RandomUniform_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }


             
            void sample_uniform(
               RandomUniformData el,

                             ParticlesData particles,
    double* samples,  int64_t n_samples_per_seed, 
                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              RandomUniform_sample(el, &lpart, samples, n_samples_per_seed);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_BeamBeamBiGaussian3DRecordData
#define XOBJ_TYPEDEF_BeamBeamBiGaussian3DRecordData
typedef   struct BeamBeamBiGaussian3DRecordData_s * BeamBeamBiGaussian3DRecordData;
 static inline BeamBeamBiGaussian3DRecordData BeamBeamBiGaussian3DRecordData_getp(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  return (BeamBeamBiGaussian3DRecordData)(( char*) obj+offset);
}
 static inline BeamstrahlungTableData BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return (BeamstrahlungTableData)(( char*) obj+offset);
}
 static inline RecordIndex BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=40;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=48;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=56;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=136;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=136;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=136;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=136;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=136;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=24;
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline BhabhaTableData BeamBeamBiGaussian3DRecordData_getp_bhabhatable(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  return (BhabhaTableData)(( char*) obj+offset);
}
 static inline RecordIndex BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=120;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=120;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=120;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=120;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=120;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+64);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+64);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+64);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+72);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+72);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+72);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+88);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+88);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+88);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+96);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+96);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+96);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+104);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+104);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+104);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+112);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+112);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset+=*( int64_t*)(( char*) obj+offset+112);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline LumiTableData BeamBeamBiGaussian3DRecordData_getp_lumitable(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  return (LumiTableData)(( char*) obj+offset);
}
 static inline RecordIndex BeamBeamBiGaussian3DRecordData_getp_lumitable__index(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=8;
  return (RecordIndex)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=16;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=16;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=16;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline uint32_t BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=24;
  return *( uint32_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj, uint32_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=24;
  *( uint32_t*)(( char*) obj+offset)=value;
}
 static inline  uint32_t* BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=24;
  return ( uint32_t*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id(const BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=32;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=32;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=32;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=64;
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_lumitable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=64;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_lumitable_at_element(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=64;
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=64;
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=64;
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+40);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+40);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNInt64 BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  return (ArrNInt64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+48);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, int64_t value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+48);
  offset+=16+i0*8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity(BeamBeamBiGaussian3DRecordData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+56);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity(const BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity(BeamBeamBiGaussian3DRecordData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+16);
  offset+=*( int64_t*)(( char*) obj+offset+56);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_RandomExponentialData
#define XOBJ_TYPEDEF_RandomExponentialData
typedef   struct RandomExponentialData_s * RandomExponentialData;
 static inline RandomExponentialData RandomExponentialData_getp(RandomExponentialData restrict  obj){
  int64_t offset=0;
  return (RandomExponentialData)(( char*) obj+offset);
}
 static inline uint8_t RandomExponentialData_get__dummy(const RandomExponentialData restrict  obj){
  int64_t offset=0;
  return *(( uint8_t*) obj+offset);
}
 static inline void RandomExponentialData_set__dummy(RandomExponentialData restrict  obj, uint8_t value){
  int64_t offset=0;
  *(( uint8_t*) obj+offset)=value;
}
 static inline  uint8_t* RandomExponentialData_getp__dummy(RandomExponentialData restrict  obj){
  int64_t offset=0;
  return ( uint8_t*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */

// copyright ############################### //
// This file is part of the Xtrack Package.   //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_EXPONENTIAL_RNG_H
#define XTRACK_EXPONENTIAL_RNG_H
#include <stdlib.h> //only_for_context cpu_serial cpu_openmp
#include <math.h> //only_for_context cpu_serial cpu_openmp
#include <time.h> //only_for_context cpu_serial cpu_openmp


 static inline
double RandomExponential_generate(LocalParticle* part){
    double x1 = RandomUniform_generate(part);
    while(x1==0.0){
        x1 = RandomUniform_generate(part);
    }
    return -log(x1);
}


 static inline
void RandomExponential_sample(RandomExponentialData rng, LocalParticle* part0,
                               double* samples, int64_t n_samples_per_seed){

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

    int i;
    for (i=0; i<n_samples_per_seed; ++i){
        double val = RandomExponential_generate(part);
        samples[n_samples_per_seed*LocalParticle_get_particle_id(part) + i] = val;
    }

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
void RandomExponential_track_local_particle(RandomExponentialData rng, LocalParticle* part0) {
    kill_all_particles(part0, RNG_ERR_INVALID_TRACK);
}


#endif /* XTRACK_EXPONENTIAL_RNG_H */


             
            void RandomExponential_track_particles(
               RandomExponentialData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              RandomExponential_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }


             
            void sample_exp(
               RandomExponentialData el,

                             ParticlesData particles,
    double* samples,  int64_t n_samples_per_seed, 
                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              RandomExponential_sample(el, &lpart, samples, n_samples_per_seed);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_BeamBeamBiGaussian3DData
#define XOBJ_TYPEDEF_BeamBeamBiGaussian3DData
typedef   struct BeamBeamBiGaussian3DData_s * BeamBeamBiGaussian3DData;
 static inline BeamBeamBiGaussian3DData BeamBeamBiGaussian3DData_getp(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  return (BeamBeamBiGaussian3DData)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_scale_strength(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_scale_strength(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_scale_strength(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get__sin_phi(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__sin_phi(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=16;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp__sin_phi(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get__cos_phi(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__cos_phi(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=24;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp__cos_phi(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get__tan_phi(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__tan_phi(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=32;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp__tan_phi(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get__sin_alpha(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__sin_alpha(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=40;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp__sin_alpha(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get__cos_alpha(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__cos_alpha(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=48;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp__cos_alpha(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_x(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_x(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=56;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_x(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_px(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_px(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=64;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_px(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_y(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_y(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=72;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_y(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_py(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=80;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_py(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=80;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_py(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=80;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_zeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_zeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=88;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_zeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_ref_shift_pzeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_ref_shift_pzeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=96;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_ref_shift_pzeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=96;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_x(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_x(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=104;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_x(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=104;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_px(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=112;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_px(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=112;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_px(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=112;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_y(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=120;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_y(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=120;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_y(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=120;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_py(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=128;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_py(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=128;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_py(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=128;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=136;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_zeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=136;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=136;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=144;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=144;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=144;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_x(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=152;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_x(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=152;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_x(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=152;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_px(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=160;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_px(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=160;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_px(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=160;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_y(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=168;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_y(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=168;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_y(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=168;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_py(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=176;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_py(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=176;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_py(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=176;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_zeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=184;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_zeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=184;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_zeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=184;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_post_subtract_pzeta(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=192;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_post_subtract_pzeta(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=192;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_post_subtract_pzeta(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=192;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_other_beam_q0(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=200;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_other_beam_q0(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=200;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_other_beam_q0(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=200;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get_num_slices_other_beam(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=208;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_num_slices_other_beam(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=208;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp_num_slices_other_beam(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=208;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=448;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=448;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=448;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=448;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=448;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+288);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+288);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+288);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+288);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+288);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+296);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+296);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+296);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+296);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+296);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+304);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+304);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+304);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+304);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+304);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+312);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+312);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+312);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+312);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+312);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+320);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+320);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+320);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+320);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+320);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+328);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+328);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+328);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+328);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+328);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+336);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+336);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+336);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+336);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+336);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+344);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+344);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+344);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+344);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+344);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+352);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+352);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+352);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+352);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+352);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+360);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+360);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+360);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+360);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+360);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+368);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+368);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+368);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+368);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+368);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+376);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+376);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+376);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+376);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+376);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+384);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+384);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+384);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+384);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+384);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+392);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+392);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+392);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+392);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+392);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+400);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+400);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+400);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+400);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+400);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+408);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+408);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+408);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+408);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+408);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_min_sigma_diff(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=216;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_min_sigma_diff(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=216;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_min_sigma_diff(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=216;
  return ( double*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_threshold_singular(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=224;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_threshold_singular(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=224;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_threshold_singular(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=224;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get_flag_beamstrahlung(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=232;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_flag_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=232;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp_flag_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=232;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+416);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+416);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+416);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+416);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+416);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+424);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+424);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+424);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+424);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+424);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+432);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+432);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+432);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+432);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+432);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+440);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+440);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(const BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+440);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+440);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung(BeamBeamBiGaussian3DData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+440);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get_flag_bhabha(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=240;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_flag_bhabha(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=240;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp_flag_bhabha(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=240;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double BeamBeamBiGaussian3DData_get_compt_x_min(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=248;
  return *( double*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_compt_x_min(BeamBeamBiGaussian3DData restrict  obj, double value){
  int64_t offset=0;
  offset+=248;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* BeamBeamBiGaussian3DData_getp_compt_x_min(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=248;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get_flag_beamsize_effect(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=256;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_flag_beamsize_effect(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=256;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp_flag_beamsize_effect(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=256;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get_flag_luminosity(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=264;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set_flag_luminosity(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=264;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp_flag_luminosity(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=264;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline RecordIdentifier BeamBeamBiGaussian3DData_getp__internal_record_id(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=272;
  return (RecordIdentifier)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=272;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=272;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=272;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t BeamBeamBiGaussian3DData_get__internal_record_id_offset(const BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=280;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void BeamBeamBiGaussian3DData_set__internal_record_id_offset(BeamBeamBiGaussian3DData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=280;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* BeamBeamBiGaussian3DData_getp__internal_record_id_offset(BeamBeamBiGaussian3DData restrict  obj){
  int64_t offset=0;
  offset+=280;
  return ( int64_t*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */


 static inline
BeamBeamBiGaussian3DRecordData BeamBeamBiGaussian3DData_getp_internal_record(BeamBeamBiGaussian3DData el, LocalParticle* part){
    RecordIdentifier record_id = BeamBeamBiGaussian3DData_getp__internal_record_id(el);
    if (RecordIdentifier_get_buffer_id(record_id) <= 0){
        return NULL;
    }
    else{
        return (BeamBeamBiGaussian3DRecordData) RecordIdentifier_getp_record(record_id, part);
    }
    }
    

#ifndef XFIELDS_CONSTANTS_H
#define XFIELDS_CONSTANTS_H

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //


// classical electron radius [m]
#if !defined( RE )
    #define   RE ( 2.81794092e-15 )
#endif

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif

// from python scipy version 1.9.0: cst.elementary_charge
#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.8541878128e-12)
#endif

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif

// from python scipy version 1.9.0: cst.epsilon_0
#if !defined( QELEM )
    #define QELEM (1.602176634e-19)
#endif

#if !defined( MPROTON_GEV )
    #define MPROTON_GEV (0.93827208816)
#endif

#if !defined( MELECTRON_GEV )
    #define MELECTRON_GEV (0.00051099895000)
#endif

#if !defined( MELECTRON_KG )
    #define MELECTRON_KG (9.1093837015e-31)
#endif

#if !defined( ALPHA )
    #define ALPHA (7.29735257e-3)
#endif

#if !defined( HBAR_GEVS )
    #define HBAR_GEVS (6.582119569e-25)
#endif

#if !defined( TWO_OVER_SQRT_PI )
    #define TWO_OVER_SQRT_PI (1.128379167095512573896158903121545171688101258657997713688171443418)
#endif

#if !defined( SQRT_TWO )
    #define SQRT_TWO (1.414213562373095048801688724209698078569671875376948073176679738)
#endif

#if !defined( REDUCED_COMPTON_WAVELENGTH_ELECTRON )
    #define REDUCED_COMPTON_WAVELENGTH_ELECTRON (3.8615926796089057e-13)
#endif

#if !defined( REAL_EPSILON )
    #define REAL_EPSILON 2.22044604925031e-16
#endif /* !defined( REAL_EPSILON ) */

#endif /* XFIELDS_CONSTANTS_H */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef _ATOMICADD_H_
#define _ATOMICADD_H_

#define ATOMICADD_CPU  //only_for_context cpu_serial cpu_openmp
//#define ATOMICADD_OPENCL //only_for_context opencl
// CUDA provides atomicAdd() natively

#ifdef ATOMICADD_CPU
inline void atomicAdd(double *addr, double val)
{
//   #pragma omp atomic //only_for_context cpu_openmp
   *addr = *addr + val;
}
#endif // ATOMICADD_CPU

#ifdef ATOMICADD_OPENCL
#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable
inline void atomicAdd(volatile __global double *addr, double val)
{
	union {
		long u64;
		double f64;
	} next, expected, current;
	current.f64 = *addr;
	do {
		expected.f64 = current.f64;
		next.f64 = expected.f64 + val;
		current.u64 = atom_cmpxchg(
			(volatile __global long *)addr,
		        (long) expected.u64,
			(long) next.u64);
	} while( current.u64 != expected.u64 );
}
#endif // ATOMICADD_OPENCL

#endif

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_SINCOS_H__
#define XFIELDS_SINCOS_H__

#include <math.h> //only_for_context cpu_serial cpu_openmp

/* Define XSUITE_NO_SINCOS as a compiler parameter to never use the inline
 * wrapper function below (the compiler may still decide to use sincos - like
 * intrinsic, but usually enforcing that math functions have to update
 * errno should put an end to this.
 *
 * If XSUITE_NO_SINCOS is not set, then a best-effort attempt is made to
 * use it on platforms that support it (i.e. gnu compiler, no ANSI standards,
 * relaxed errno handling for math functions.
 */

#if ( !defined( XSUITE_NO_SINCOS ) ) && ( defined( __OPENCL_C_VERSION__ ) )
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    *sin_result = sincos( arg, cos_result ); }

#elif ( !defined( XSUITE_NO_SINCOS ) ) && \
      ( ( defined( __CUDA_ARCH__ ) ) || \
        ( defined( __GNUC__ ) && !defined( __clang__ ) && \
         !defined( __STRICT_ANSI__ ) && !defined( __INTEL_COMPILER ) && \
         defined( __NO_MATH_ERRNO__ ) ) )
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    sincos( arg, sin_result, cos_result ); }

#else
 static inline void xsuite_sincos( double const arg,
    double*  restrict  sin_result, double*  restrict  cos_result ) {
    *sin_result = sin( arg );
    *cos_result = cos( arg ); }

#endif /* XSUITE_NO_SINCOS */
#endif /* XFIELDS_SINCOS_H__ */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_HEADERS_POWER_H_H__
#define XFIELDS_HEADERS_POWER_H_H__

/** \file power_n.h
 *  \note always include constants first!!! */

 static inline double power_n( double x, unsigned int n )
{
    #if defined( __OPENCL_VERSION__ )
    return pown( x, n );
    #else

    double x_n = x;

    unsigned int const n_div_16 = n >> 4u;
    unsigned int const n_mod_16 = n - ( n_div_16 << 4u );

    switch( n_mod_16 )
    {
        case  0u: { x_n = ( double )1.0; break; }
        case  1u: { break; }
        case  2u: { x_n *= x;                                       break; }
        case  3u: { x_n *= x * x;                                   break; }
        case  4u: { x_n *= x;     x_n *= x_n;                       break; }
        case  5u: { x_n *= x;     x_n *= x_n * x;                   break; }
        case  6u: { x_n *= x * x; x_n *= x_n;                       break; }
        case  7u: { x_n *= x * x; x_n *= x_n * x;                   break; }
        case  8u: { x_n *= x;     x_n *= x_n;     x_n *= x_n;       break; }
        case  9u: { x_n *= x * x; x_n *= x_n * x_n;                 break; }
        case 10u: { x_n *= x * x; x_n *= x_n * x_n * x;             break; }
        case 11u: { x_n *= x;     x_n *= x_n * x; x_n *= x_n * x;   break; }
        case 12u: { x_n *= x * x; x_n *= x_n;     x_n *= x_n;       break; }
        case 13u: { x_n *= x * x; x_n *= x_n;     x_n *= x_n * x;   break; }
        case 14u: { x_n *= x * x; x_n *= x_n * x; x_n *= x_n;       break; }
        case 15u: { x_n *= x;     x_n *= x_n * x; x_n *= x_n * x_n; break; }
        default:  { x_n = ( double )0.0; }
    };

    if( n_div_16 > 0u ){ x *= x; x *= x; x *= x; x *= x; }

    switch( n_div_16 )
    {
        case  0u: { x_n  = ( n_mod_16 != 0u ) ? x_n : ( double )1.0; break; }
        case  1u: { x_n *= x;                                           break; }
        case  2u: { x   *= x; x_n *= x;                                 break; }
        case  3u: { x_n *= x * x * x;                                   break; }
        case  4u: { x   *= x; x *= x; x_n *= x;                         break; }
        case  5u: { x_n *= x; x *= x; x *= x; x_n *= x;                 break; }
        case  6u: { x   *= x * x; x *= x; x_n *= x;                     break; }
        case  7u: { x_n *= x; x *= x * x; x *= x; x_n *= x;             break; }
        case  8u: { x *= x; x *= x; x*= x; x_n *= x;                    break; }
        case  9u: { x *= x * x; x *= x * x; x_n *= x;                   break; }
        case 10u: { x_n *= x; x *= x * x; x *= x * x; x_n *= x;         break; }
        case 11u: { x_n *= x * x; x *= x * x; x *= x * x; x_n *= x;     break; }
        case 12u: { x *= x; x *= x; x_n *= x; x *= x; x_n *= x;         break; }
        case 13u: { x_n *= x; x *= x; x *= x; x_n *= x; x *= x;
                    x_n *= x; break; }

        case 14u: { x_n *= x * x; x *= x; x *= x; x_n *= x; x *= x;
                    x_n *= x; break; }

        case 15u: { x *= x * x; x_n *= x * x; x *= x * x; x_n *= x;    break; }

        default:
        {
            unsigned int ii = 0u;
            unsigned int nn = n_div_16 % 16u;

            for( ; ii < nn ; ++ii ) x_n *= x;

            x *= x; x *= x; x *= x; x *= x;
            nn = ( n_div_16 - nn ) >> 4u;

            for( ii = 0u ; ii < nn ; ++ii ) x_n *= x;
        }
    };

    return x_n;
    #endif /* defined( __OPENCL_VERSION__ ) */
}

#endif /* XFIELDS_HEADERS_POWER_H_H__ */

// copyright ############################### //
// This file is part of the Xfields Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XFIELDS_PARTICLE_STATES_H
#define XFIELDS_PARTICLE_STATES_H

#define XF_OUTSIDE_INTERPOL -11
#define XF_TOO_MANY_PHOTONS -12

#endif /* XFIELDS_PARTICLE_STATES_H */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_FADDEEVA_H
#define XFIELDS_FADDEEVA_H


//from file: faddeeva_mit.h

//  -*- mode:c++; tab-width:2; indent-tabs-mode:nil;  -*-

/* Copyright (c) 2012 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* (Note that this file can be compiled with either C++, in which
    case it uses C++ std::complex<double>, or C, in which case it
    uses C99 double complex.) */

/* Available at: http://ab-initio.mit.edu/Faddeeva

   Computes various error functions (erf, erfc, erfi, erfcx),
   including the Dawson integral, in the complex plane, based
   on algorithms for the computation of the Faddeeva function
              w(z) = exp(-z^2) * erfc(-i*z).
   Given w(z), the error functions are mostly straightforward
   to compute, except for certain regions where we have to
   switch to Taylor expansions to avoid cancellation errors
   [e.g. near the origin for erf(z)].

   To compute the Faddeeva function, we use a combination of two
   algorithms:

   For sufficiently large |z|, we use a continued-fraction expansion
   for w(z) similar to those described in:

      Walter Gautschi, "Efficient computation of the complex error
      function," SIAM J. Numer. Anal. 7(1), pp. 187-198 (1970)

      G. P. M. Poppe and C. M. J. Wijers, "More efficient computation
      of the complex error function," ACM Trans. Math. Soft. 16(1),
      pp. 38-46 (1990).

   Unlike those papers, however, we switch to a completely different
   algorithm for smaller |z|:

      Mofreh R. Zaghloul and Ahmed N. Ali, "Algorithm 916: Computing the
      Faddeyeva and Voigt Functions," ACM Trans. Math. Soft. 38(2), 15
      (2011).

   (I initially used this algorithm for all z, but it turned out to be
    significantly slower than the continued-fraction expansion for
    larger |z|.  On the other hand, it is competitive for smaller |z|,
    and is significantly more accurate than the Poppe & Wijers code
    in some regions, e.g. in the vicinity of z=1+1i.)

   Note that this is an INDEPENDENT RE-IMPLEMENTATION of these algorithms,
   based on the description in the papers ONLY.  In particular, I did
   not refer to the authors' Fortran or Matlab implementations, respectively,
   (which are under restrictive ACM copyright terms and therefore unusable
    in free/open-source software).

   Steven G. Johnson, Massachusetts Institute of Technology
   http://math.mit.edu/~stevenj
   October 2012.

    -- Note that Algorithm 916 assumes that the erfc(x) function,
       or rather the scaled function erfcx(x) = exp(x*x)*erfc(x),
       is supplied for REAL arguments x.   I originally used an
       erfcx routine derived from DERFC in SLATEC, but I have
       since replaced it with a much faster routine written by
       me which uses a combination of continued-fraction expansions
       and a lookup table of Chebyshev polynomials.  For speed,
       I implemented a similar algorithm for Im[w(x)] of real x,
       since this comes up frequently in the other error functions.

   A small test program is included the end, which checks
   the w(z) etc. results against several known values.  To compile
   the test function, compile with -DTEST_FADDEEVA (that is,
   #define TEST_FADDEEVA).

   If HAVE_CONFIG_H is #defined (e.g. by compiling with -DHAVE_CONFIG_H),
   then we #include "config.h", which is assumed to be a GNU autoconf-style
   header defining HAVE_* macros to indicate the presence of features. In
   particular, if HAVE_ISNAN and HAVE_ISINF are #defined, we use those
   functions in math.h instead of defining our own, and if HAVE_ERF and/or
   HAVE_ERFC are defined we use those functions from <cmath> for erf and
   erfc of real arguments, respectively, instead of defining our own.

   REVISION HISTORY:
       4 October 2012: Initial public release (SGJ)
       5 October 2012: Revised (SGJ) to fix spelling error,
                       start summation for large x at round(x/a) (> 1)
                       rather than ceil(x/a) as in the original
                       paper, which should slightly improve performance
                       (and, apparently, slightly improves accuracy)
      19 October 2012: Revised (SGJ) to fix bugs for large x, large -y,
                       and 15<x<26. Performance improvements. Prototype
                       now supplies default value for relerr.
      24 October 2012: Switch to continued-fraction expansion for
                       sufficiently large z, for performance reasons.
                       Also, avoid spurious overflow for |z| > 1e154.
                       Set relerr argument to min(relerr,0.1).
      27 October 2012: Enhance accuracy in Re[w(z)] taken by itself,
                       by switching to Alg. 916 in a region near
                       the real-z axis where continued fractions
                       have poor relative accuracy in Re[w(z)].  Thanks
                       to M. Zaghloul for the tip.
      29 October 2012: Replace SLATEC-derived erfcx routine with
                       completely rewritten code by me, using a very
                       different algorithm which is much faster.
      30 October 2012: Implemented special-case code for real z
                       (where real part is exp(-x^2) and imag part is
                        Dawson integral), using algorithm similar to erfx.
                       Export ImFaddeeva_w function to make Dawson's
                       integral directly accessible.
      3 November 2012: Provide implementations of erf, erfc, erfcx,
                       and Dawson functions in Faddeeva:: namespace,
                       in addition to Faddeeva::w.  Provide header
                       file Faddeeva.hh.
      4 November 2012: Slightly faster erf for real arguments.
                       Updated MATLAB and Octave plugins.
     27 November 2012: Support compilation with either C++ or
                       plain C (using C99 complex numbers).
                       For real x, use standard-library erf(x)
                       and erfc(x) if available (for C99 or C++11).
                       #include "config.h" if HAVE_CONFIG_H is #defined.
     15 December 2012: Portability fixes (copysign, Inf/NaN creation),
                       use CMPLX/__builtin_complex if available in C,
                       slight accuracy improvements to erf and dawson
                       functions near the origin.  Use gnulib functions
                       if GNULIB_NAMESPACE is defined.
     18 December 2012: Slight tweaks (remove recomputation of x*x in Dawson)
          12 May 2015: Bugfix for systems lacking copysign function.
*/

/////////////////////////////////////////////////////////////////////////
/* If this file is compiled as a part of a larger project,
   support using an autoconf-style config.h header file
   (with various "HAVE_*" #defines to indicate features)
   if HAVE_CONFIG_H is #defined (in GNU autotools style). */

#ifndef XFIELDS_FADDEEVA_MIT_H
#define XFIELDS_FADDEEVA_MIT_H

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

/////////////////////////////////////////////////////////////////////////
// macros to allow us to use either C++ or C (with C99 features)


// #  include "Faddeeva.h" # I include the full header here
/* Copyright (c) 2012 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* Available at: http://ab-initio.mit.edu/Faddeeva

   Header file for Faddeeva.c; see Faddeeva.cc for more information. */


// Require C99 complex-number support
#include <complex.h>


// compute w(z) = exp(-z^2) erfc(-iz) [ Faddeeva / scaled complex error func ]
static inline double complex Faddeeva_MIT_w(double complex z, double relerr);
double Faddeeva_MIT_w_im(double x); // special-case code for Im[w(x)] of real x

// Various functions that we can compute with the help of w(z)

// compute erfcx(z) = exp(z^2) erfc(z)
double complex Faddeeva_MIT_erfcx(double complex z, double relerr);
double Faddeeva_MIT_erfcx_re(double x); // special case for real x

// compute erf(z), the error function of complex arguments
double complex Faddeeva_MIT_erf(double complex z, double relerr);
double Faddeeva_MIT_erf_re(double x); // special case for real x

// compte erfi(z) = -i erf(iz), the imaginary error function
double complex Faddeeva_MIT_erfi(double complex z, double relerr);
double Faddeeva_MIT_erfi_re(double x); // special case for real x

// compute erfc(z) = 1 - erf(z), the complementary error function
double complex Faddeeva_MIT_erfc(double complex z, double relerr);
double Faddeeva_MIT_erfc_re(double x); // special case for real x

// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
double complex Faddeeva_MIT_Dawson(double complex z, double relerr);
double Faddeeva_MIT_Dawson_re(double x); // special case for real x


 static inline void faddeeva_w( double x, double y,
    double*  restrict  out_x, double*  restrict  out_y )
{
    double complex z, W;
    z = x + I * y;
    W = Faddeeva_MIT_w(z, 0);
    *out_x = creal(W);
    *out_y = cimag(W);
}

 static inline void faddeeva_w_q1( double x, double y,
    double*  restrict  out_x, double*  restrict  out_y )
{
    faddeeva_w(x, y, out_x, out_y);
}


#  define _GNU_SOURCE // enable GNU libc NAN extension if possible

#  include <float.h>
#  include <math.h>

typedef double complex cmplx;

#  define FADDEEVA(name) Faddeeva_MIT_ ## name
#  define FADDEEVA_RE(name) Faddeeva_MIT_ ## name ## _re

/* Constructing complex numbers like 0+i*NaN is problematic in C99
   without the C11 CMPLX macro, because 0.+I*NAN may give NaN+i*NAN if
   I is a complex (rather than imaginary) constant.  For some reason,
   however, it works fine in (pre-4.7) gcc if I define Inf and NaN as
   1/0 and 0/0 (and only if I compile with optimization -O1 or more),
   but not if I use the INFINITY or NAN macros. */

/* __builtin_complex was introduced in gcc 4.7, but the C11 CMPLX macro
   may not be defined unless we are using a recent (2012) version of
   glibc and compile with -std=c11... note that icc lies about being
   gcc and probably doesn't have this builtin(?), so exclude icc explicitly */
#  if !defined(CMPLX) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)) && !(defined(__ICC) || defined(__INTEL_COMPILER))
#    define CMPLX(a,b) __builtin_complex((double) (a), (double) (b))
#  endif

#  ifdef CMPLX // C11
#    define C(a,b) CMPLX(a,b)
#    define Inf INFINITY // C99 infinity
#    ifdef NAN // GNU libc extension
#      define NaN NAN
#    else
#      define NaN (0./0.) // NaN
#    endif
#  else
#    define C(a,b) ((a) + I*(b))
#    define Inf (1./0.)
#    define NaN (0./0.)
#  endif

static inline cmplx cpolar(double r, double t)
{
  if (r == 0.0 && !isnan(t))
    return 0.0;
  else
    return C(r * cos(t), r * sin(t));
}


/////////////////////////////////////////////////////////////////////////
// Auxiliary routines to compute other special functions based on w(z)

// compute erfcx(z) = exp(z^2) erfz(z)
cmplx FADDEEVA(erfcx)(cmplx z, double relerr)
{
  return FADDEEVA(w)(C(-cimag(z), creal(z)), relerr);
}

// compute the error function erf(x)
double FADDEEVA_RE(erf)(double x)
{
#if !defined(__cplusplus)
  return erf(x); // C99 supplies erf in math.h
#elif (__cplusplus >= 201103L) || defined(HAVE_ERF)
  return ::erf(x); // C++11 supplies std::erf in cmath
#else
  double mx2 = -x*x;
  if (mx2 < -750) // underflow
    return (x >= 0 ? 1.0 : -1.0);

  if (x >= 0) {
    if (x < 8e-2) goto taylor;
    return 1.0 - exp(mx2) * FADDEEVA_RE(erfcx)(x);
  }
  else { // x < 0
    if (x > -8e-2) goto taylor;
    return exp(mx2) * FADDEEVA_RE(erfcx)(-x) - 1.0;
  }

  // Use Taylor series for small |x|, to avoid cancellation inaccuracy
  //   erf(x) = 2/sqrt(pi) * x * (1 - x^2/3 + x^4/10 - x^6/42 + x^8/216 + ...)
 taylor:
  return x * (1.1283791670955125739
              + mx2 * (0.37612638903183752464
                       + mx2 * (0.11283791670955125739
                                + mx2 * (0.026866170645131251760
                                         + mx2 * 0.0052239776254421878422))));
#endif
}

// compute the error function erf(z)
cmplx FADDEEVA(erf)(cmplx z, double relerr)
{
  double x = creal(z), y = cimag(z);

  if (y == 0)
    return C(FADDEEVA_RE(erf)(x),
             y); // preserve sign of 0
  if (x == 0) // handle separately for speed & handling of y = Inf or NaN
    return C(x, // preserve sign of 0
             /* handle y -> Inf limit manually, since
                exp(y^2) -> Inf but Im[w(y)] -> 0, so
                IEEE will give us a NaN when it should be Inf */
             y*y > 720 ? (y > 0 ? Inf : -Inf)
             : exp(y*y) * FADDEEVA(w_im)(y));

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  if (mRe_z2 < -750) // underflow
    return (x >= 0 ? 1.0 : -1.0);

  /* Handle positive and negative x via different formulas,
     using the mirror symmetries of w, to avoid overflow/underflow
     problems from multiplying exponentially large and small quantities. */
  if (x >= 0) {
    if (x < 8e-2) {
      if (fabs(y) < 1e-2)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3 && x < 5e-3)
        goto taylor_erfi;
    }
    /* don't use complex exp function, since that will produce spurious NaN
       values when multiplying w in an overflow situation. */
    return 1.0 - exp(mRe_z2) *
      (C(cos(mIm_z2), sin(mIm_z2))
       * FADDEEVA(w)(C(-y,x), relerr));
  }
  else { // x < 0
    if (x > -8e-2) { // duplicate from above to avoid fabs(x) call
      if (fabs(y) < 1e-2)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3 && x > -5e-3)
        goto taylor_erfi;
    }
    else if (isnan(x))
      return C(NaN, y == 0 ? 0 : NaN);
    /* don't use complex exp function, since that will produce spurious NaN
       values when multiplying w in an overflow situation. */
    return exp(mRe_z2) *
      (C(cos(mIm_z2), sin(mIm_z2))
       * FADDEEVA(w)(C(y,-x), relerr)) - 1.0;
  }

  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
  //   erf(z) = 2/sqrt(pi) * z * (1 - z^2/3 + z^4/10 - z^6/42 + z^8/216 + ...)
 taylor:
  {
    cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2
    return z * (1.1283791670955125739
                + mz2 * (0.37612638903183752464
                         + mz2 * (0.11283791670955125739
                                  + mz2 * (0.026866170645131251760
                                          + mz2 * 0.0052239776254421878422))));
  }

  /* for small |x| and small |xy|,
     use Taylor series to avoid cancellation inaccuracy:
       erf(x+iy) = erf(iy)
          + 2*exp(y^2)/sqrt(pi) *
            [ x * (1 - x^2 * (1+2y^2)/3 + x^4 * (3+12y^2+4y^4)/30 + ...
              - i * x^2 * y * (1 - x^2 * (3+2y^2)/6 + ...) ]
     where:
        erf(iy) = exp(y^2) * Im[w(y)]
  */
 taylor_erfi:
  {
    double x2 = x*x, y2 = y*y;
    double expy2 = exp(y2);
    return C
      (expy2 * x * (1.1283791670955125739
                    - x2 * (0.37612638903183752464
                            + 0.75225277806367504925*y2)
                    + x2*x2 * (0.11283791670955125739
                               + y2 * (0.45135166683820502956
                                       + 0.15045055561273500986*y2))),
       expy2 * (FADDEEVA(w_im)(y)
                - x2*y * (1.1283791670955125739
                          - x2 * (0.56418958354775628695
                                  + 0.37612638903183752464*y2))));
  }
}

// erfi(z) = -i erf(iz)
cmplx FADDEEVA(erfi)(cmplx z, double relerr)
{
  cmplx e = FADDEEVA(erf)(C(-cimag(z),creal(z)), relerr);
  return C(cimag(e), -creal(e));
}

// erfi(x) = -i erf(ix)
double FADDEEVA_RE(erfi)(double x)
{
  return x*x > 720 ? (x > 0 ? Inf : -Inf)
    : exp(x*x) * FADDEEVA(w_im)(x);
}

// erfc(x) = 1 - erf(x)
double FADDEEVA_RE(erfc)(double x)
{
#if !defined(__cplusplus)
  return erfc(x); // C99 supplies erfc in math.h
#elif (__cplusplus >= 201103L) || defined(HAVE_ERFC)
  return ::erfc(x); // C++11 supplies std::erfc in cmath
#else
  if (x*x > 750) // underflow
    return (x >= 0 ? 0.0 : 2.0);
  return x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x)
    : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x);
#endif
}

// erfc(z) = 1 - erf(z)
cmplx FADDEEVA(erfc)(cmplx z, double relerr)
{
  double x = creal(z), y = cimag(z);

  if (x == 0.)
    return C(1,
             /* handle y -> Inf limit manually, since
                exp(y^2) -> Inf but Im[w(y)] -> 0, so
                IEEE will give us a NaN when it should be Inf */
             y*y > 720 ? (y > 0 ? -Inf : Inf)
             : -exp(y*y) * FADDEEVA(w_im)(y));
  if (y == 0.) {
    if (x*x > 750) // underflow
      return C(x >= 0 ? 0.0 : 2.0,
               -y); // preserve sign of 0
    return C(x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x)
             : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x),
             -y); // preserve sign of zero
  }

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  if (mRe_z2 < -750) // underflow
    return (x >= 0 ? 0.0 : 2.0);

  if (x >= 0)
    return cexp(C(mRe_z2, mIm_z2))
      * FADDEEVA(w)(C(-y,x), relerr);
  else
    return 2.0 - cexp(C(mRe_z2, mIm_z2))
      * FADDEEVA(w)(C(y,-x), relerr);
}

// compute Dawson(x) = sqrt(pi)/2  *  exp(-x^2) * erfi(x)
double FADDEEVA_RE(Dawson)(double x)
{
  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
  return spi2 * FADDEEVA(w_im)(x);
}

// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
cmplx FADDEEVA(Dawson)(cmplx z, double relerr)
{
  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
  double x = creal(z), y = cimag(z);

  // handle axes separately for speed & proper handling of x or y = Inf or NaN
  if (y == 0)
    return C(spi2 * FADDEEVA(w_im)(x),
             -y); // preserve sign of 0
  if (x == 0) {
    double y2 = y*y;
    if (y2 < 2.5e-5) { // Taylor expansion
      return C(x, // preserve sign of 0
               y * (1.
                    + y2 * (0.6666666666666666666666666666666666666667
                            + y2 * 0.26666666666666666666666666666666666667)));
    }
    return C(x, // preserve sign of 0
             spi2 * (y >= 0
                     ? exp(y2) - FADDEEVA_RE(erfcx)(y)
                     : FADDEEVA_RE(erfcx)(-y) - exp(y2)));
  }

  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
  double mIm_z2 = -2*x*y; // Im(-z^2)
  cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2

  /* Handle positive and negative x via different formulas,
     using the mirror symmetries of w, to avoid overflow/underflow
     problems from multiplying exponentially large and small quantities. */
  if (y >= 0) {
    if (y < 5e-3) {
      if (fabs(x) < 5e-3)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3)
        goto taylor_realaxis;
    }
    cmplx res = cexp(mz2) - FADDEEVA(w)(z, relerr);
    return spi2 * C(-cimag(res), creal(res));
  }
  else { // y < 0
    if (y > -5e-3) { // duplicate from above to avoid fabs(x) call
      if (fabs(x) < 5e-3)
        goto taylor;
      else if (fabs(mIm_z2) < 5e-3)
        goto taylor_realaxis;
    }
    else if (isnan(y))
      return C(x == 0 ? 0 : NaN, NaN);
    cmplx res = FADDEEVA(w)(-z, relerr) - cexp(mz2);
    return spi2 * C(-cimag(res), creal(res));
  }

  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
  //     dawson(z) = z - 2/3 z^3 + 4/15 z^5 + ...
 taylor:
  return z * (1.
              + mz2 * (0.6666666666666666666666666666666666666667
                       + mz2 * 0.2666666666666666666666666666666666666667));

  /* for small |y| and small |xy|,
     use Taylor series to avoid cancellation inaccuracy:
       dawson(x + iy)
        = D + y^2 (D + x - 2Dx^2)
            + y^4 (D/2 + 5x/6 - 2Dx^2 - x^3/3 + 2Dx^4/3)
        + iy [ (1-2Dx) + 2/3 y^2 (1 - 3Dx - x^2 + 2Dx^3)
              + y^4/15 (4 - 15Dx - 9x^2 + 20Dx^3 + 2x^4 - 4Dx^5) ] + ...
     where D = dawson(x)

     However, for large |x|, 2Dx -> 1 which gives cancellation problems in
     this series (many of the leading terms cancel).  So, for large |x|,
     we need to substitute a continued-fraction expansion for D.

        dawson(x) = 0.5 / (x-0.5/(x-1/(x-1.5/(x-2/(x-2.5/(x...))))))

     The 6 terms shown here seems to be the minimum needed to be
     accurate as soon as the simpler Taylor expansion above starts
     breaking down.  Using this 6-term expansion, factoring out the
     denominator, and simplifying with Maple, we obtain:

      Re dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / x
        = 33 - 28x^2 + 4x^4 + y^2 (18 - 4x^2) + 4 y^4
      Im dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / y
        = -15 + 24x^2 - 4x^4 + 2/3 y^2 (6x^2 - 15) - 4 y^4

     Finally, for |x| > 5e7, we can use a simpler 1-term continued-fraction
     expansion for the real part, and a 2-term expansion for the imaginary
     part.  (This avoids overflow problems for huge |x|.)  This yields:

     Re dawson(x + iy) = [1 + y^2 (1 + y^2/2 - (xy)^2/3)] / (2x)
     Im dawson(x + iy) = y [ -1 - 2/3 y^2 + y^4/15 (2x^2 - 4) ] / (2x^2 - 1)

 */
 taylor_realaxis:
  {
    double x2 = x*x;
    if (x2 > 1600) { // |x| > 40
      double y2 = y*y;
      if (x2 > 25e14) {// |x| > 5e7
        double xy2 = (x*y)*(x*y);
        return C((0.5 + y2 * (0.5 + 0.25*y2
                              - 0.16666666666666666667*xy2)) / x,
                 y * (-1 + y2 * (-0.66666666666666666667
                                 + 0.13333333333333333333*xy2
                                 - 0.26666666666666666667*y2))
                 / (2*x2 - 1));
      }
      return (1. / (-15 + x2*(90 + x2*(-60 + 8*x2)))) *
        C(x * (33 + x2 * (-28 + 4*x2)
               + y2 * (18 - 4*x2 + 4*y2)),
          y * (-15 + x2 * (24 - 4*x2)
               + y2 * (4*x2 - 10 - 4*y2)));
    }
    else {
      double D = spi2 * FADDEEVA(w_im)(x);
      double y2 = y*y;
      return C
        (D + y2 * (D + x - 2*D*x2)
         + y2*y2 * (D * (0.5 - x2 * (2 - 0.66666666666666666667*x2))
                    + x * (0.83333333333333333333
                           - 0.33333333333333333333 * x2)),
         y * (1 - 2*D*x
              + y2 * 0.66666666666666666667 * (1 - x2 - D*x * (3 - 2*x2))
              + y2*y2 * (0.26666666666666666667 -
                         x2 * (0.6 - 0.13333333333333333333 * x2)
                         - D*x * (1 - x2 * (1.3333333333333333333
                                            - 0.26666666666666666667 * x2)))));
    }
  }
}

/////////////////////////////////////////////////////////////////////////

// return sinc(x) = sin(x)/x, given both x and sin(x)
// [since we only use this in cases where sin(x) has already been computed]
static inline double sinc(double x, double sinx) {
  return fabs(x) < 1e-4 ? 1 - (0.1666666666666666666667)*x*x : sinx / x;
}

// sinh(x) via Taylor series, accurate to machine precision for |x| < 1e-2
static inline double sinh_taylor(double x) {
  return x * (1 + (x*x) * (0.1666666666666666666667
                           + 0.00833333333333333333333 * (x*x)));
}

static inline double sqr(double x) { return x*x; }

// precomputed table of expa2n2[n-1] = exp(-a2*n*n)
// for double-precision a2 = 0.26865... in FADDEEVA(w), below.
static const double expa2n2[] = {
  7.64405281671221563e-01,
  3.41424527166548425e-01,
  8.91072646929412548e-02,
  1.35887299055460086e-02,
  1.21085455253437481e-03,
  6.30452613933449404e-05,
  1.91805156577114683e-06,
  3.40969447714832381e-08,
  3.54175089099469393e-10,
  2.14965079583260682e-12,
  7.62368911833724354e-15,
  1.57982797110681093e-17,
  1.91294189103582677e-20,
  1.35344656764205340e-23,
  5.59535712428588720e-27,
  1.35164257972401769e-30,
  1.90784582843501167e-34,
  1.57351920291442930e-38,
  7.58312432328032845e-43,
  2.13536275438697082e-47,
  3.51352063787195769e-52,
  3.37800830266396920e-57,
  1.89769439468301000e-62,
  6.22929926072668851e-68,
  1.19481172006938722e-73,
  1.33908181133005953e-79,
  8.76924303483223939e-86,
  3.35555576166254986e-92,
  7.50264110688173024e-99,
  9.80192200745410268e-106,
  7.48265412822268959e-113,
  3.33770122566809425e-120,
  8.69934598159861140e-128,
  1.32486951484088852e-135,
  1.17898144201315253e-143,
  6.13039120236180012e-152,
  1.86258785950822098e-160,
  3.30668408201432783e-169,
  3.43017280887946235e-178,
  2.07915397775808219e-187,
  7.36384545323984966e-197,
  1.52394760394085741e-206,
  1.84281935046532100e-216,
  1.30209553802992923e-226,
  5.37588903521080531e-237,
  1.29689584599763145e-247,
  1.82813078022866562e-258,
  1.50576355348684241e-269,
  7.24692320799294194e-281,
  2.03797051314726829e-292,
  3.34880215927873807e-304,
  0.0 // underflow (also prevents reads past array end, below)
};

/////////////////////////////////////////////////////////////////////////

static inline cmplx FADDEEVA(w)(cmplx z, double relerr)
{
  if (creal(z) == 0.0)
    return C(FADDEEVA_RE(erfcx)(cimag(z)),
             creal(z)); // give correct sign of 0 in cimag(w)
  else if (cimag(z) == 0)
    return C(exp(-sqr(creal(z))),
             FADDEEVA(w_im)(creal(z)));

  double a, a2, c;
  if (relerr <= DBL_EPSILON) {
    relerr = DBL_EPSILON;
    a = 0.518321480430085929872; // pi / sqrt(-log(eps*0.5))
    c = 0.329973702884629072537; // (2/pi) * a;
    a2 = 0.268657157075235951582; // a^2
  }
  else {
    const double pi = 3.14159265358979323846264338327950288419716939937510582;
    if (relerr > 0.1) relerr = 0.1; // not sensible to compute < 1 digit
    a = pi / sqrt(-log(relerr*0.5));
    c = (2/pi)*a;
    a2 = a*a;
  }
  const double x = fabs(creal(z));
  const double y = cimag(z), ya = fabs(y);

  cmplx ret = 0.; // return value

  double sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0;

#define USE_CONTINUED_FRACTION 1 // 1 to use continued fraction for large |z|

#if USE_CONTINUED_FRACTION
  if (ya > 7 || (x > 6  // continued fraction is faster
                 /* As pointed out by M. Zaghloul, the continued
                    fraction seems to give a large relative error in
                    Re w(z) for |x| ~ 6 and small |y|, so use
                    algorithm 816 in this region: */
                 && (ya > 0.1 || (x > 8 && ya > 1e-10) || x > 28))) {

    /* Poppe & Wijers suggest using a number of terms
           nu = 3 + 1442 / (26*rho + 77)
       where rho = sqrt((x/x0)^2 + (y/y0)^2) where x0=6.3, y0=4.4.
       (They only use this expansion for rho >= 1, but rho a little less
        than 1 seems okay too.)
       Instead, I did my own fit to a slightly different function
       that avoids the hypotenuse calculation, using NLopt to minimize
       the sum of the squares of the errors in nu with the constraint
       that the estimated nu be >= minimum nu to attain machine precision.
       I also separate the regions where nu == 2 and nu == 1. */
    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
    if (x + ya > 4000) { // nu <= 2
      if (x + ya > 1e7) { // nu == 1, w(z) = i/sqrt(pi) / z
        // scale to avoid overflow
        if (x > ya) {
          double yax = ya / xs;
          double denom = ispi / (xs + yax*ya);
          ret = C(denom*yax, denom);
        }
        else if (isinf(ya))
          return ((isnan(x) || y < 0)
                  ? C(NaN,NaN) : C(0,0));
        else {
          double xya = xs / ya;
          double denom = ispi / (xya*xs + ya);
          ret = C(denom, denom*xya);
        }
      }
      else { // nu == 2, w(z) = i/sqrt(pi) * z / (z*z - 0.5)
        double dr = xs*xs - ya*ya - 0.5, di = 2*xs*ya;
        double denom = ispi / (dr*dr + di*di);
        ret = C(denom * (xs*di-ya*dr), denom * (xs*dr+ya*di));
      }
    }
    else { // compute nu(z) estimate and do general continued fraction
      const double c0=3.9, c1=11.398, c2=0.08254, c3=0.1421, c4=0.2023; // fit
      double nu = floor(c0 + c1 / (c2*x + c3*ya + c4));
      double wr = xs, wi = ya;
      for (nu = 0.5 * (nu - 1); nu > 0.4; nu -= 0.5) {
        // w <- z - nu/w:
        double denom = nu / (wr*wr + wi*wi);
        wr = xs - wr * denom;
        wi = ya + wi * denom;
      }
      { // w(z) = i/sqrt(pi) / w:
        double denom = ispi / (wr*wr + wi*wi);
        ret = C(denom*wi, denom*wr);
      }
    }
    if (y < 0) {
      // use w(z) = 2.0*exp(-z*z) - w(-z),
      // but be careful of overflow in exp(-z*z)
      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya)
      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
    }
    else
      return ret;
  }
#else // !USE_CONTINUED_FRACTION
  if (x + ya > 1e7) { // w(z) = i/sqrt(pi) / z, to machine precision
    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
    // scale to avoid overflow
    if (x > ya) {
      double yax = ya / xs;
      double denom = ispi / (xs + yax*ya);
      ret = C(denom*yax, denom);
    }
    else {
      double xya = xs / ya;
      double denom = ispi / (xya*xs + ya);
      ret = C(denom, denom*xya);
    }
    if (y < 0) {
      // use w(z) = 2.0*exp(-z*z) - w(-z),
      // but be careful of overflow in exp(-z*z)
      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya)
      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
    }
    else
      return ret;
  }
#endif // !USE_CONTINUED_FRACTION

  /* Note: The test that seems to be suggested in the paper is x <
     sqrt(-log(DBL_MIN)), about 26.6, since otherwise exp(-x^2)
     underflows to zero and sum1,sum2,sum4 are zero.  However, long
     before this occurs, the sum1,sum2,sum4 contributions are
     negligible in double precision; I find that this happens for x >
     about 6, for all y.  On the other hand, I find that the case
     where we compute all of the sums is faster (at least with the
     precomputed expa2n2 table) until about x=10.  Furthermore, if we
     try to compute all of the sums for x > 20, I find that we
     sometimes run into numerical problems because underflow/overflow
     problems start to appear in the various coefficients of the sums,
     below.  Therefore, we use x < 10 here. */
  else if (x < 10) {
    double prod2ax = 1, prodm2ax = 1;
    double expx2;

    if (isnan(y))
      return C(y,y);

    /* Somewhat ugly copy-and-paste duplication here, but I see significant
       speedups from using the special-case code with the precomputed
       exponential, and the x < 5e-4 special case is needed for accuracy. */

    if (relerr == DBL_EPSILON) { // use precomputed exp(-a2*(n*n)) table
      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
        const double x2 = x*x;
        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
        // compute exp(2*a*x) and exp(-2*a*x) via Taylor, to double precision
        const double ax2 = 1.036642960860171859744*x; // 2*a*x
        const double exp2ax =
          1 + ax2 * (1 + ax2 * (0.5 + 0.166666666666666666667*ax2));
        const double expm2ax =
          1 - ax2 * (1 - ax2 * (0.5 - 0.166666666666666666667*ax2));
        for (int n = 1; 1; ++n) {
          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum3 += coef * prod2ax;

          // really = sum5 - sum4
          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);

          // test convergence via sum3
          if (coef * prod2ax < relerr * sum3) break;
        }
      }
      else { // x > 5e-4, compute sum4 and sum5 separately
        expx2 = exp(-x*x);
        const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
        for (int n = 1; 1; ++n) {
          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum4 += (coef * prodm2ax) * (a*n);
          sum3 += coef * prod2ax;
          sum5 += (coef * prod2ax) * (a*n);
          // test convergence via sum5, since this sum has the slowest decay
          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
        }
      }
    }
    else { // relerr != DBL_EPSILON, compute exp(-a2*(n*n)) on the fly
      const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
        const double x2 = x*x;
        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
        for (int n = 1; 1; ++n) {
          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum3 += coef * prod2ax;

          // really = sum5 - sum4
          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);

          // test convergence via sum3
          if (coef * prod2ax < relerr * sum3) break;
        }
      }
      else { // x > 5e-4, compute sum4 and sum5 separately
        expx2 = exp(-x*x);
        for (int n = 1; 1; ++n) {
          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
          prod2ax *= exp2ax;
          prodm2ax *= expm2ax;
          sum1 += coef;
          sum2 += coef * prodm2ax;
          sum4 += (coef * prodm2ax) * (a*n);
          sum3 += coef * prod2ax;
          sum5 += (coef * prod2ax) * (a*n);
          // test convergence via sum5, since this sum has the slowest decay
          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
        }
      }
    }
    const double expx2erfcxy = // avoid spurious overflow for large negative y
      y > -6 // for y < -6, erfcx(y) = 2*exp(y*y) to double precision
      ? expx2*FADDEEVA_RE(erfcx)(y) : 2*exp(y*y-x*x);
    if (y > 5) { // imaginary terms cancel
      const double sinxy = sin(x*y);
      ret = (expx2erfcxy - c*y*sum1) * cos(2*x*y)
        + (c*x*expx2) * sinxy * sinc(x*y, sinxy);
    }
    else {
      double xs = creal(z);
      const double sinxy = sin(xs*y);
      const double sin2xy = sin(2*xs*y), cos2xy = cos(2*xs*y);
      const double coef1 = expx2erfcxy - c*y*sum1;
      const double coef2 = c*xs*expx2;
      ret = C(coef1 * cos2xy + coef2 * sinxy * sinc(xs*y, sinxy),
              coef2 * sinc(2*xs*y, sin2xy) - coef1 * sin2xy);
    }
  }
  else { // x large: only sum3 & sum5 contribute (see above note)
    if (isnan(x))
      return C(x,x);
    if (isnan(y))
      return C(y,y);

#if USE_CONTINUED_FRACTION
    ret = exp(-x*x); // |y| < 1e-10, so we only need exp(-x*x) term
#else
    if (y < 0) {
      /* erfcx(y) ~ 2*exp(y*y) + (< 1) if y < 0, so
         erfcx(y)*exp(-x*x) ~ 2*exp(y*y-x*x) term may not be negligible
         if y*y - x*x > -36 or so.  So, compute this term just in case.
         We also need the -exp(-x*x) term to compute Re[w] accurately
         in the case where y is very small. */
      ret = cpolar(2*exp(y*y-x*x) - exp(-x*x), -2*creal(z)*y);
    }
    else
      ret = exp(-x*x); // not negligible in real part if y very small
#endif
    // (round instead of ceil as in original paper; note that x/a > 1 here)
    double n0 = floor(x/a + 0.5); // sum in both directions, starting at n0
    double dx = a*n0 - x;
    sum3 = exp(-dx*dx) / (a2*(n0*n0) + y*y);
    sum5 = a*n0 * sum3;
    double exp1 = exp(4*a*dx), exp1dn = 1;
    int dn;
    for (dn = 1; n0 - dn > 0; ++dn) { // loop over n0-dn and n0+dn terms
      double np = n0 + dn, nm = n0 - dn;
      double tp = exp(-sqr(a*dn+dx));
      double tm = tp * (exp1dn *= exp1); // trick to get tm from tp
      tp /= (a2*(np*np) + y*y);
      tm /= (a2*(nm*nm) + y*y);
      sum3 += tp + tm;
      sum5 += a * (np * tp + nm * tm);
      if (a * (np * tp + nm * tm) < relerr * sum5) goto finish;
    }
    while (1) { // loop over n0+dn terms only (since n0-dn <= 0)
      double np = n0 + dn++;
      double tp = exp(-sqr(a*dn+dx)) / (a2*(np*np) + y*y);
      sum3 += tp;
      sum5 += a * np * tp;
      if (a * np * tp < relerr * sum5) goto finish;
    }
  }
 finish:
  return ret + C((0.5*c)*y*(sum2+sum3),
                 (0.5*c)*copysign(sum5-sum4, creal(z)));
}

/////////////////////////////////////////////////////////////////////////

/* erfcx(x) = exp(x^2) erfc(x) function, for real x, written by
   Steven G. Johnson, October 2012.

   This function combines a few different ideas.

   First, for x > 50, it uses a continued-fraction expansion (same as
   for the Faddeeva function, but with algebraic simplifications for z=i*x).

   Second, for 0 <= x <= 50, it uses Chebyshev polynomial approximations,
   but with two twists:

      a) It maps x to y = 4 / (4+x) in [0,1].  This simple transformation,
         inspired by a similar transformation in the octave-forge/specfun
         erfcx by Soren Hauberg, results in much faster Chebyshev convergence
         than other simple transformations I have examined.

      b) Instead of using a single Chebyshev polynomial for the entire
         [0,1] y interval, we break the interval up into 100 equal
         subintervals, with a switch/lookup table, and use much lower
         degree Chebyshev polynomials in each subinterval. This greatly
         improves performance in my tests.

   For x < 0, we use the relationship erfcx(-x) = 2 exp(x^2) - erfc(x),
   with the usual checks for overflow etcetera.

   Performance-wise, it seems to be substantially faster than either
   the SLATEC DERFC function [or an erfcx function derived therefrom]
   or Cody's CALERF function (from netlib.org/specfun), while
   retaining near machine precision in accuracy.  */

/* Given y100=100*y, where y = 4/(4+x) for x >= 0, compute erfc(x).

   Uses a look-up table of 100 different Chebyshev polynomials
   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
   with the help of Maple and a little shell script.   This allows
   the Chebyshev polynomials to be of significantly lower degree (about 1/4)
   compared to fitting the whole [0,1] interval with a single polynomial. */
static double erfcx_y100(double y100)
{
  switch ((int) y100) {
case 0: {
double t = 2*y100 - 1;
return 0.70878032454106438663e-3 + (0.71234091047026302958e-3 + (0.35779077297597742384e-5 + (0.17403143962587937815e-7 + (0.81710660047307788845e-10 + (0.36885022360434957634e-12 + 0.15917038551111111111e-14 * t) * t) * t) * t) * t) * t;
}
case 1: {
double t = 2*y100 - 3;
return 0.21479143208285144230e-2 + (0.72686402367379996033e-3 + (0.36843175430938995552e-5 + (0.18071841272149201685e-7 + (0.85496449296040325555e-10 + (0.38852037518534291510e-12 + 0.16868473576888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 2: {
double t = 2*y100 - 5;
return 0.36165255935630175090e-2 + (0.74182092323555510862e-3 + (0.37948319957528242260e-5 + (0.18771627021793087350e-7 + (0.89484715122415089123e-10 + (0.40935858517772440862e-12 + 0.17872061464888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 3: {
double t = 2*y100 - 7;
return 0.51154983860031979264e-2 + (0.75722840734791660540e-3 + (0.39096425726735703941e-5 + (0.19504168704300468210e-7 + (0.93687503063178993915e-10 + (0.43143925959079664747e-12 + 0.18939926435555555556e-14 * t) * t) * t) * t) * t) * t;
}
case 4: {
double t = 2*y100 - 9;
return 0.66457513172673049824e-2 + (0.77310406054447454920e-3 + (0.40289510589399439385e-5 + (0.20271233238288381092e-7 + (0.98117631321709100264e-10 + (0.45484207406017752971e-12 + 0.20076352213333333333e-14 * t) * t) * t) * t) * t) * t;
}
case 5: {
double t = 2*y100 - 11;
return 0.82082389970241207883e-2 + (0.78946629611881710721e-3 + (0.41529701552622656574e-5 + (0.21074693344544655714e-7 + (0.10278874108587317989e-9 + (0.47965201390613339638e-12 + 0.21285907413333333333e-14 * t) * t) * t) * t) * t) * t;
}
case 6: {
double t = 2*y100 - 13;
return 0.98039537275352193165e-2 + (0.80633440108342840956e-3 + (0.42819241329736982942e-5 + (0.21916534346907168612e-7 + (0.10771535136565470914e-9 + (0.50595972623692822410e-12 + 0.22573462684444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 7: {
double t = 2*y100 - 15;
return 0.11433927298290302370e-1 + (0.82372858383196561209e-3 + (0.44160495311765438816e-5 + (0.22798861426211986056e-7 + (0.11291291745879239736e-9 + (0.53386189365816880454e-12 + 0.23944209546666666667e-14 * t) * t) * t) * t) * t) * t;
}
case 8: {
double t = 2*y100 - 17;
return 0.13099232878814653979e-1 + (0.84167002467906968214e-3 + (0.45555958988457506002e-5 + (0.23723907357214175198e-7 + (0.11839789326602695603e-9 + (0.56346163067550237877e-12 + 0.25403679644444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 9: {
double t = 2*y100 - 19;
return 0.14800987015587535621e-1 + (0.86018092946345943214e-3 + (0.47008265848816866105e-5 + (0.24694040760197315333e-7 + (0.12418779768752299093e-9 + (0.59486890370320261949e-12 + 0.26957764568888888889e-14 * t) * t) * t) * t) * t) * t;
}
case 10: {
double t = 2*y100 - 21;
return 0.16540351739394069380e-1 + (0.87928458641241463952e-3 + (0.48520195793001753903e-5 + (0.25711774900881709176e-7 + (0.13030128534230822419e-9 + (0.62820097586874779402e-12 + 0.28612737351111111111e-14 * t) * t) * t) * t) * t) * t;
}
case 11: {
double t = 2*y100 - 23;
return 0.18318536789842392647e-1 + (0.89900542647891721692e-3 + (0.50094684089553365810e-5 + (0.26779777074218070482e-7 + (0.13675822186304615566e-9 + (0.66358287745352705725e-12 + 0.30375273884444444444e-14 * t) * t) * t) * t) * t) * t;
}
case 12: {
double t = 2*y100 - 25;
return 0.20136801964214276775e-1 + (0.91936908737673676012e-3 + (0.51734830914104276820e-5 + (0.27900878609710432673e-7 + (0.14357976402809042257e-9 + (0.70114790311043728387e-12 + 0.32252476000000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 13: {
double t = 2*y100 - 27;
return 0.21996459598282740954e-1 + (0.94040248155366777784e-3 + (0.53443911508041164739e-5 + (0.29078085538049374673e-7 + (0.15078844500329731137e-9 + (0.74103813647499204269e-12 + 0.34251892320000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 14: {
double t = 2*y100 - 29;
return 0.23898877187226319502e-1 + (0.96213386835900177540e-3 + (0.55225386998049012752e-5 + (0.30314589961047687059e-7 + (0.15840826497296335264e-9 + (0.78340500472414454395e-12 + 0.36381553564444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 15: {
double t = 2*y100 - 31;
return 0.25845480155298518485e-1 + (0.98459293067820123389e-3 + (0.57082915920051843672e-5 + (0.31613782169164830118e-7 + (0.16646478745529630813e-9 + (0.82840985928785407942e-12 + 0.38649975768888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 16: {
double t = 2*y100 - 33;
return 0.27837754783474696598e-1 + (0.10078108563256892757e-2 + (0.59020366493792212221e-5 + (0.32979263553246520417e-7 + (0.17498524159268458073e-9 + (0.87622459124842525110e-12 + 0.41066206488888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 17: {
double t = 2*y100 - 35;
return 0.29877251304899307550e-1 + (0.10318204245057349310e-2 + (0.61041829697162055093e-5 + (0.34414860359542720579e-7 + (0.18399863072934089607e-9 + (0.92703227366365046533e-12 + 0.43639844053333333334e-14 * t) * t) * t) * t) * t) * t;
}
case 18: {
double t = 2*y100 - 37;
return 0.31965587178596443475e-1 + (0.10566560976716574401e-2 + (0.63151633192414586770e-5 + (0.35924638339521924242e-7 + (0.19353584758781174038e-9 + (0.98102783859889264382e-12 + 0.46381060817777777779e-14 * t) * t) * t) * t) * t) * t;
}
case 19: {
double t = 2*y100 - 39;
return 0.34104450552588334840e-1 + (0.10823541191350532574e-2 + (0.65354356159553934436e-5 + (0.37512918348533521149e-7 + (0.20362979635817883229e-9 + (0.10384187833037282363e-11 + 0.49300625262222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 20: {
double t = 2*y100 - 41;
return 0.36295603928292425716e-1 + (0.11089526167995268200e-2 + (0.67654845095518363577e-5 + (0.39184292949913591646e-7 + (0.21431552202133775150e-9 + (0.10994259106646731797e-11 + 0.52409949102222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 21: {
double t = 2*y100 - 43;
return 0.38540888038840509795e-1 + (0.11364917134175420009e-2 + (0.70058230641246312003e-5 + (0.40943644083718586939e-7 + (0.22563034723692881631e-9 + (0.11642841011361992885e-11 + 0.55721092871111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 22: {
double t = 2*y100 - 45;
return 0.40842225954785960651e-1 + (0.11650136437945673891e-2 + (0.72569945502343006619e-5 + (0.42796161861855042273e-7 + (0.23761401711005024162e-9 + (0.12332431172381557035e-11 + 0.59246802364444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 23: {
double t = 2*y100 - 47;
return 0.43201627431540222422e-1 + (0.11945628793917272199e-2 + (0.75195743532849206263e-5 + (0.44747364553960993492e-7 + (0.25030885216472953674e-9 + (0.13065684400300476484e-11 + 0.63000532853333333334e-14 * t) * t) * t) * t) * t) * t;
}
case 24: {
double t = 2*y100 - 49;
return 0.45621193513810471438e-1 + (0.12251862608067529503e-2 + (0.77941720055551920319e-5 + (0.46803119830954460212e-7 + (0.26375990983978426273e-9 + (0.13845421370977119765e-11 + 0.66996477404444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 25: {
double t = 2*y100 - 51;
return 0.48103121413299865517e-1 + (0.12569331386432195113e-2 + (0.80814333496367673980e-5 + (0.48969667335682018324e-7 + (0.27801515481905748484e-9 + (0.14674637611609884208e-11 + 0.71249589351111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 26: {
double t = 2*y100 - 53;
return 0.50649709676983338501e-1 + (0.12898555233099055810e-2 + (0.83820428414568799654e-5 + (0.51253642652551838659e-7 + (0.29312563849675507232e-9 + (0.15556512782814827846e-11 + 0.75775607822222222221e-14 * t) * t) * t) * t) * t) * t;
}
case 27: {
double t = 2*y100 - 55;
return 0.53263363664388864181e-1 + (0.13240082443256975769e-2 + (0.86967260015007658418e-5 + (0.53662102750396795566e-7 + (0.30914568786634796807e-9 + (0.16494420240828493176e-11 + 0.80591079644444444445e-14 * t) * t) * t) * t) * t) * t;
}
case 28: {
double t = 2*y100 - 57;
return 0.55946601353500013794e-1 + (0.13594491197408190706e-2 + (0.90262520233016380987e-5 + (0.56202552975056695376e-7 + (0.32613310410503135996e-9 + (0.17491936862246367398e-11 + 0.85713381688888888890e-14 * t) * t) * t) * t) * t) * t;
}
case 29: {
double t = 2*y100 - 59;
return 0.58702059496154081813e-1 + (0.13962391363223647892e-2 + (0.93714365487312784270e-5 + (0.58882975670265286526e-7 + (0.34414937110591753387e-9 + (0.18552853109751857859e-11 + 0.91160736711111111110e-14 * t) * t) * t) * t) * t) * t;
}
case 30: {
double t = 2*y100 - 61;
return 0.61532500145144778048e-1 + (0.14344426411912015247e-2 + (0.97331446201016809696e-5 + (0.61711860507347175097e-7 + (0.36325987418295300221e-9 + (0.19681183310134518232e-11 + 0.96952238400000000000e-14 * t) * t) * t) * t) * t) * t;
}
case 31: {
double t = 2*y100 - 63;
return 0.64440817576653297993e-1 + (0.14741275456383131151e-2 + (0.10112293819576437838e-4 + (0.64698236605933246196e-7 + (0.38353412915303665586e-9 + (0.20881176114385120186e-11 + 0.10310784480000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 32: {
double t = 2*y100 - 65;
return 0.67430045633130393282e-1 + (0.15153655418916540370e-2 + (0.10509857606888328667e-4 + (0.67851706529363332855e-7 + (0.40504602194811140006e-9 + (0.22157325110542534469e-11 + 0.10964842115555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 33: {
double t = 2*y100 - 67;
return 0.70503365513338850709e-1 + (0.15582323336495709827e-2 + (0.10926868866865231089e-4 + (0.71182482239613507542e-7 + (0.42787405890153386710e-9 + (0.23514379522274416437e-11 + 0.11659571751111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 34: {
double t = 2*y100 - 69;
return 0.73664114037944596353e-1 + (0.16028078812438820413e-2 + (0.11364423678778207991e-4 + (0.74701423097423182009e-7 + (0.45210162777476488324e-9 + (0.24957355004088569134e-11 + 0.12397238257777777778e-13 * t) * t) * t) * t) * t) * t;
}
case 35: {
double t = 2*y100 - 71;
return 0.76915792420819562379e-1 + (0.16491766623447889354e-2 + (0.11823685320041302169e-4 + (0.78420075993781544386e-7 + (0.47781726956916478925e-9 + (0.26491544403815724749e-11 + 0.13180196462222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 36: {
double t = 2*y100 - 73;
return 0.80262075578094612819e-1 + (0.16974279491709504117e-2 + (0.12305888517309891674e-4 + (0.82350717698979042290e-7 + (0.50511496109857113929e-9 + (0.28122528497626897696e-11 + 0.14010889635555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 37: {
double t = 2*y100 - 75;
return 0.83706822008980357446e-1 + (0.17476561032212656962e-2 + (0.12812343958540763368e-4 + (0.86506399515036435592e-7 + (0.53409440823869467453e-9 + (0.29856186620887555043e-11 + 0.14891851591111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 38: {
double t = 2*y100 - 77;
return 0.87254084284461718231e-1 + (0.17999608886001962327e-2 + (0.13344443080089492218e-4 + (0.90900994316429008631e-7 + (0.56486134972616465316e-9 + (0.31698707080033956934e-11 + 0.15825697795555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 39: {
double t = 2*y100 - 79;
return 0.90908120182172748487e-1 + (0.18544478050657699758e-2 + (0.13903663143426120077e-4 + (0.95549246062549906177e-7 + (0.59752787125242054315e-9 + (0.33656597366099099413e-11 + 0.16815130613333333333e-13 * t) * t) * t) * t) * t) * t;
}
case 40: {
double t = 2*y100 - 81;
return 0.94673404508075481121e-1 + (0.19112284419887303347e-2 + (0.14491572616545004930e-4 + (0.10046682186333613697e-6 + (0.63221272959791000515e-9 + (0.35736693975589130818e-11 + 0.17862931591111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 41: {
double t = 2*y100 - 83;
return 0.98554641648004456555e-1 + (0.19704208544725622126e-2 + (0.15109836875625443935e-4 + (0.10567036667675984067e-6 + (0.66904168640019354565e-9 + (0.37946171850824333014e-11 + 0.18971959040000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 42: {
double t = 2*y100 - 85;
return 0.10255677889470089531e0 + (0.20321499629472857418e-2 + (0.15760224242962179564e-4 + (0.11117756071353507391e-6 + (0.70814785110097658502e-9 + (0.40292553276632563925e-11 + 0.20145143075555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 43: {
double t = 2*y100 - 87;
return 0.10668502059865093318e0 + (0.20965479776148731610e-2 + (0.16444612377624983565e-4 + (0.11700717962026152749e-6 + (0.74967203250938418991e-9 + (0.42783716186085922176e-11 + 0.21385479360000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 44: {
double t = 2*y100 - 89;
return 0.11094484319386444474e0 + (0.21637548491908170841e-2 + (0.17164995035719657111e-4 + (0.12317915750735938089e-6 + (0.79376309831499633734e-9 + (0.45427901763106353914e-11 + 0.22696025653333333333e-13 * t) * t) * t) * t) * t) * t;
}
case 45: {
double t = 2*y100 - 91;
return 0.11534201115268804714e0 + (0.22339187474546420375e-2 + (0.17923489217504226813e-4 + (0.12971465288245997681e-6 + (0.84057834180389073587e-9 + (0.48233721206418027227e-11 + 0.24079890062222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 46: {
double t = 2*y100 - 93;
return 0.11988259392684094740e0 + (0.23071965691918689601e-2 + (0.18722342718958935446e-4 + (0.13663611754337957520e-6 + (0.89028385488493287005e-9 + (0.51210161569225846701e-11 + 0.25540227111111111111e-13 * t) * t) * t) * t) * t) * t;
}
case 47: {
double t = 2*y100 - 95;
return 0.12457298393509812907e0 + (0.23837544771809575380e-2 + (0.19563942105711612475e-4 + (0.14396736847739470782e-6 + (0.94305490646459247016e-9 + (0.54366590583134218096e-11 + 0.27080225920000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 48: {
double t = 2*y100 - 97;
return 0.12941991566142438816e0 + (0.24637684719508859484e-2 + (0.20450821127475879816e-4 + (0.15173366280523906622e-6 + (0.99907632506389027739e-9 + (0.57712760311351625221e-11 + 0.28703099555555555556e-13 * t) * t) * t) * t) * t) * t;
}
case 49: {
double t = 2*y100 - 99;
return 0.13443048593088696613e0 + (0.25474249981080823877e-2 + (0.21385669591362915223e-4 + (0.15996177579900443030e-6 + (0.10585428844575134013e-8 + (0.61258809536787882989e-11 + 0.30412080142222222222e-13 * t) * t) * t) * t) * t) * t;
}
case 50: {
double t = 2*y100 - 101;
return 0.13961217543434561353e0 + (0.26349215871051761416e-2 + (0.22371342712572567744e-4 + (0.16868008199296822247e-6 + (0.11216596910444996246e-8 + (0.65015264753090890662e-11 + 0.32210394506666666666e-13 * t) * t) * t) * t) * t) * t;
}
case 51: {
double t = 2*y100 - 103;
return 0.14497287157673800690e0 + (0.27264675383982439814e-2 + (0.23410870961050950197e-4 + (0.17791863939526376477e-6 + (0.11886425714330958106e-8 + (0.68993039665054288034e-11 + 0.34101266222222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 52: {
double t = 2*y100 - 105;
return 0.15052089272774618151e0 + (0.28222846410136238008e-2 + (0.24507470422713397006e-4 + (0.18770927679626136909e-6 + (0.12597184587583370712e-8 + (0.73203433049229821618e-11 + 0.36087889048888888890e-13 * t) * t) * t) * t) * t) * t;
}
case 53: {
double t = 2*y100 - 107;
return 0.15626501395774612325e0 + (0.29226079376196624949e-2 + (0.25664553693768450545e-4 + (0.19808568415654461964e-6 + (0.13351257759815557897e-8 + (0.77658124891046760667e-11 + 0.38173420035555555555e-13 * t) * t) * t) * t) * t) * t;
}
case 54: {
double t = 2*y100 - 109;
return 0.16221449434620737567e0 + (0.30276865332726475672e-2 + (0.26885741326534564336e-4 + (0.20908350604346384143e-6 + (0.14151148144240728728e-8 + (0.82369170665974313027e-11 + 0.40360957457777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 55: {
double t = 2*y100 - 111;
return 0.16837910595412130659e0 + (0.31377844510793082301e-2 + (0.28174873844911175026e-4 + (0.22074043807045782387e-6 + (0.14999481055996090039e-8 + (0.87348993661930809254e-11 + 0.42653528977777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 56: {
double t = 2*y100 - 113;
return 0.17476916455659369953e0 + (0.32531815370903068316e-2 + (0.29536024347344364074e-4 + (0.23309632627767074202e-6 + (0.15899007843582444846e-8 + (0.92610375235427359475e-11 + 0.45054073102222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 57: {
double t = 2*y100 - 115;
return 0.18139556223643701364e0 + (0.33741744168096996041e-2 + (0.30973511714709500836e-4 + (0.24619326937592290996e-6 + (0.16852609412267750744e-8 + (0.98166442942854895573e-11 + 0.47565418097777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 58: {
double t = 2*y100 - 117;
return 0.18826980194443664549e0 + (0.35010775057740317997e-2 + (0.32491914440014267480e-4 + (0.26007572375886319028e-6 + (0.17863299617388376116e-8 + (0.10403065638343878679e-10 + 0.50190265831111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 59: {
double t = 2*y100 - 119;
return 0.19540403413693967350e0 + (0.36342240767211326315e-2 + (0.34096085096200907289e-4 + (0.27479061117017637474e-6 + (0.18934228504790032826e-8 + (0.11021679075323598664e-10 + 0.52931171733333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 60: {
double t = 2*y100 - 121;
return 0.20281109560651886959e0 + (0.37739673859323597060e-2 + (0.35791165457592409054e-4 + (0.29038742889416172404e-6 + (0.20068685374849001770e-8 + (0.11673891799578381999e-10 + 0.55790523093333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 61: {
double t = 2*y100 - 123;
return 0.21050455062669334978e0 + (0.39206818613925652425e-2 + (0.37582602289680101704e-4 + (0.30691836231886877385e-6 + (0.21270101645763677824e-8 + (0.12361138551062899455e-10 + 0.58770520160000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 62: {
double t = 2*y100 - 125;
return 0.21849873453703332479e0 + (0.40747643554689586041e-2 + (0.39476163820986711501e-4 + (0.32443839970139918836e-6 + (0.22542053491518680200e-8 + (0.13084879235290858490e-10 + 0.61873153262222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 63: {
double t = 2*y100 - 127;
return 0.22680879990043229327e0 + (0.42366354648628516935e-2 + (0.41477956909656896779e-4 + (0.34300544894502810002e-6 + (0.23888264229264067658e-8 + (0.13846596292818514601e-10 + 0.65100183751111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 64: {
double t = 2*y100 - 129;
return 0.23545076536988703937e0 + (0.44067409206365170888e-2 + (0.43594444916224700881e-4 + (0.36268045617760415178e-6 + (0.25312606430853202748e-8 + (0.14647791812837903061e-10 + 0.68453122631111111110e-13 * t) * t) * t) * t) * t) * t;
}
case 65: {
double t = 2*y100 - 131;
return 0.24444156740777432838e0 + (0.45855530511605787178e-2 + (0.45832466292683085475e-4 + (0.38352752590033030472e-6 + (0.26819103733055603460e-8 + (0.15489984390884756993e-10 + 0.71933206364444444445e-13 * t) * t) * t) * t) * t) * t;
}
case 66: {
double t = 2*y100 - 133;
return 0.25379911500634264643e0 + (0.47735723208650032167e-2 + (0.48199253896534185372e-4 + (0.40561404245564732314e-6 + (0.28411932320871165585e-8 + (0.16374705736458320149e-10 + 0.75541379822222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 67: {
double t = 2*y100 - 135;
return 0.26354234756393613032e0 + (0.49713289477083781266e-2 + (0.50702455036930367504e-4 + (0.42901079254268185722e-6 + (0.30095422058900481753e-8 + (0.17303497025347342498e-10 + 0.79278273368888888890e-13 * t) * t) * t) * t) * t) * t;
}
case 68: {
double t = 2*y100 - 137;
return 0.27369129607732343398e0 + (0.51793846023052643767e-2 + (0.53350152258326602629e-4 + (0.45379208848865015485e-6 + (0.31874057245814381257e-8 + (0.18277905010245111046e-10 + 0.83144182364444444445e-13 * t) * t) * t) * t) * t) * t;
}
case 69: {
double t = 2*y100 - 139;
return 0.28426714781640316172e0 + (0.53983341916695141966e-2 + (0.56150884865255810638e-4 + (0.48003589196494734238e-6 + (0.33752476967570796349e-8 + (0.19299477888083469086e-10 + 0.87139049137777777779e-13 * t) * t) * t) * t) * t) * t;
}
case 70: {
double t = 2*y100 - 141;
return 0.29529231465348519920e0 + (0.56288077305420795663e-2 + (0.59113671189913307427e-4 + (0.50782393781744840482e-6 + (0.35735475025851713168e-8 + (0.20369760937017070382e-10 + 0.91262442613333333334e-13 * t) * t) * t) * t) * t) * t;
}
case 71: {
double t = 2*y100 - 143;
return 0.30679050522528838613e0 + (0.58714723032745403331e-2 + (0.62248031602197686791e-4 + (0.53724185766200945789e-6 + (0.37827999418960232678e-8 + (0.21490291930444538307e-10 + 0.95513539182222222221e-13 * t) * t) * t) * t) * t) * t;
}
case 72: {
double t = 2*y100 - 145;
return 0.31878680111173319425e0 + (0.61270341192339103514e-2 + (0.65564012259707640976e-4 + (0.56837930287837738996e-6 + (0.40035151353392378882e-8 + (0.22662596341239294792e-10 + 0.99891109760000000000e-13 * t) * t) * t) * t) * t) * t;
}
case 73: {
double t = 2*y100 - 147;
return 0.33130773722152622027e0 + (0.63962406646798080903e-2 + (0.69072209592942396666e-4 + (0.60133006661885941812e-6 + (0.42362183765883466691e-8 + (0.23888182347073698382e-10 + 0.10439349811555555556e-12 * t) * t) * t) * t) * t) * t;
}
case 74: {
double t = 2*y100 - 149;
return 0.34438138658041336523e0 + (0.66798829540414007258e-2 + (0.72783795518603561144e-4 + (0.63619220443228800680e-6 + (0.44814499336514453364e-8 + (0.25168535651285475274e-10 + 0.10901861383111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 75: {
double t = 2*y100 - 151;
return 0.35803744972380175583e0 + (0.69787978834882685031e-2 + (0.76710543371454822497e-4 + (0.67306815308917386747e-6 + (0.47397647975845228205e-8 + (0.26505114141143050509e-10 + 0.11376390933333333333e-12 * t) * t) * t) * t) * t) * t;
}
case 76: {
double t = 2*y100 - 153;
return 0.37230734890119724188e0 + (0.72938706896461381003e-2 + (0.80864854542670714092e-4 + (0.71206484718062688779e-6 + (0.50117323769745883805e-8 + (0.27899342394100074165e-10 + 0.11862637614222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 77: {
double t = 2*y100 - 155;
return 0.38722432730555448223e0 + (0.76260375162549802745e-2 + (0.85259785810004603848e-4 + (0.75329383305171327677e-6 + (0.52979361368388119355e-8 + (0.29352606054164086709e-10 + 0.12360253370666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 78: {
double t = 2*y100 - 157;
return 0.40282355354616940667e0 + (0.79762880915029728079e-2 + (0.89909077342438246452e-4 + (0.79687137961956194579e-6 + (0.55989731807360403195e-8 + (0.30866246101464869050e-10 + 0.12868841946666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 79: {
double t = 2*y100 - 159;
return 0.41914223158913787649e0 + (0.83456685186950463538e-2 + (0.94827181359250161335e-4 + (0.84291858561783141014e-6 + (0.59154537751083485684e-8 + (0.32441553034347469291e-10 + 0.13387957943111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 80: {
double t = 2*y100 - 161;
return 0.43621971639463786896e0 + (0.87352841828289495773e-2 + (0.10002929142066799966e-3 + (0.89156148280219880024e-6 + (0.62480008150788597147e-8 + (0.34079760983458878910e-10 + 0.13917107176888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 81: {
double t = 2*y100 - 163;
return 0.45409763548534330981e0 + (0.91463027755548240654e-2 + (0.10553137232446167258e-3 + (0.94293113464638623798e-6 + (0.65972492312219959885e-8 + (0.35782041795476563662e-10 + 0.14455745872000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 82: {
double t = 2*y100 - 165;
return 0.47282001668512331468e0 + (0.95799574408860463394e-2 + (0.11135019058000067469e-3 + (0.99716373005509038080e-6 + (0.69638453369956970347e-8 + (0.37549499088161345850e-10 + 0.15003280712888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 83: {
double t = 2*y100 - 167;
return 0.49243342227179841649e0 + (0.10037550043909497071e-1 + (0.11750334542845234952e-3 + (0.10544006716188967172e-5 + (0.73484461168242224872e-8 + (0.39383162326435752965e-10 + 0.15559069118222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 84: {
double t = 2*y100 - 169;
return 0.51298708979209258326e0 + (0.10520454564612427224e-1 + (0.12400930037494996655e-3 + (0.11147886579371265246e-5 + (0.77517184550568711454e-8 + (0.41283980931872622611e-10 + 0.16122419680000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 85: {
double t = 2*y100 - 171;
return 0.53453307979101369843e0 + (0.11030120618800726938e-1 + (0.13088741519572269581e-3 + (0.11784797595374515432e-5 + (0.81743383063044825400e-8 + (0.43252818449517081051e-10 + 0.16692592640000000000e-12 * t) * t) * t) * t) * t) * t;
}
case 86: {
double t = 2*y100 - 173;
return 0.55712643071169299478e0 + (0.11568077107929735233e-1 + (0.13815797838036651289e-3 + (0.12456314879260904558e-5 + (0.86169898078969313597e-8 + (0.45290446811539652525e-10 + 0.17268801084444444444e-12 * t) * t) * t) * t) * t) * t;
}
case 87: {
double t = 2*y100 - 175;
return 0.58082532122519320968e0 + (0.12135935999503877077e-1 + (0.14584223996665838559e-3 + (0.13164068573095710742e-5 + (0.90803643355106020163e-8 + (0.47397540713124619155e-10 + 0.17850211608888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 88: {
double t = 2*y100 - 177;
return 0.60569124025293375554e0 + (0.12735396239525550361e-1 + (0.15396244472258863344e-3 + (0.13909744385382818253e-5 + (0.95651595032306228245e-8 + (0.49574672127669041550e-10 + 0.18435945564444444444e-12 * t) * t) * t) * t) * t) * t;
}
case 89: {
double t = 2*y100 - 179;
return 0.63178916494715716894e0 + (0.13368247798287030927e-1 + (0.16254186562762076141e-3 + (0.14695084048334056083e-5 + (0.10072078109604152350e-7 + (0.51822304995680707483e-10 + 0.19025081422222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 90: {
double t = 2*y100 - 181;
return 0.65918774689725319200e0 + (0.14036375850601992063e-1 + (0.17160483760259706354e-3 + (0.15521885688723188371e-5 + (0.10601827031535280590e-7 + (0.54140790105837520499e-10 + 0.19616655146666666667e-12 * t) * t) * t) * t) * t) * t;
}
case 91: {
double t = 2*y100 - 183;
return 0.68795950683174433822e0 + (0.14741765091365869084e-1 + (0.18117679143520433835e-3 + (0.16392004108230585213e-5 + (0.11155116068018043001e-7 + (0.56530360194925690374e-10 + 0.20209663662222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 92: {
double t = 2*y100 - 185;
return 0.71818103808729967036e0 + (0.15486504187117112279e-1 + (0.19128428784550923217e-3 + (0.17307350969359975848e-5 + (0.11732656736113607751e-7 + (0.58991125287563833603e-10 + 0.20803065333333333333e-12 * t) * t) * t) * t) * t) * t;
}
case 93: {
double t = 2*y100 - 187;
return 0.74993321911726254661e0 + (0.16272790364044783382e-1 + (0.20195505163377912645e-3 + (0.18269894883203346953e-5 + (0.12335161021630225535e-7 + (0.61523068312169087227e-10 + 0.21395783431111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 94: {
double t = 2*y100 - 189;
return 0.78330143531283492729e0 + (0.17102934132652429240e-1 + (0.21321800585063327041e-3 + (0.19281661395543913713e-5 + (0.12963340087354341574e-7 + (0.64126040998066348872e-10 + 0.21986708942222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 95: {
double t = 2*y100 - 191;
return 0.81837581041023811832e0 + (0.17979364149044223802e-1 + (0.22510330592753129006e-3 + (0.20344732868018175389e-5 + (0.13617902941839949718e-7 + (0.66799760083972474642e-10 + 0.22574701262222222222e-12 * t) * t) * t) * t) * t) * t;
}
case 96: {
double t = 2*y100 - 193;
return 0.85525144775685126237e0 + (0.18904632212547561026e-1 + (0.23764237370371255638e-3 + (0.21461248251306387979e-5 + (0.14299555071870523786e-7 + (0.69543803864694171934e-10 + 0.23158593688888888889e-12 * t) * t) * t) * t) * t) * t;
}
case 97: {
double t = 2*y100 - 195;
return 0.89402868170849933734e0 + (0.19881418399127202569e-1 + (0.25086793128395995798e-3 + (0.22633402747585233180e-5 + (0.15008997042116532283e-7 + (0.72357609075043941261e-10 + 0.23737194737777777778e-12 * t) * t) * t) * t) * t) * t;
}
case 98: {
double t = 2*y100 - 197;
return 0.93481333942870796363e0 + (0.20912536329780368893e-1 + (0.26481403465998477969e-3 + (0.23863447359754921676e-5 + (0.15746923065472184451e-7 + (0.75240468141720143653e-10 + 0.24309291271111111111e-12 * t) * t) * t) * t) * t) * t;
}
case 99: {
double t = 2*y100 - 199;
return 0.97771701335885035464e0 + (0.22000938572830479551e-1 + (0.27951610702682383001e-3 + (0.25153688325245314530e-5 + (0.16514019547822821453e-7 + (0.78191526829368231251e-10 + 0.24873652355555555556e-12 * t) * t) * t) * t) * t) * t;
}
  }
  // we only get here if y = 1, i.e. |x| < 4*eps, in which case
  // erfcx is within 1e-15 of 1..
  return 1.0;
}

double FADDEEVA_RE(erfcx)(double x)
{
  if (x >= 0) {
    if (x > 50) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x > 5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x+0.5/(x+1/(x+1.5/(x+2/x))))  */
      return ispi*((x*x) * (x*x+4.5) + 2) / (x * ((x*x) * (x*x+5) + 3.75));
    }
    return erfcx_y100(400/(4+x));
  }
  else
    return x < -26.7 ? HUGE_VAL : (x < -6.1 ? 2*exp(x*x)
                                   : 2*exp(x*x) - erfcx_y100(400/(4-x)));
}

/////////////////////////////////////////////////////////////////////////
/* Compute a scaled Dawson integral
            FADDEEVA(w_im)(x) = 2*Dawson(x)/sqrt(pi)
   equivalent to the imaginary part w(x) for real x.

   Uses methods similar to the erfcx calculation above: continued fractions
   for large |x|, a lookup table of Chebyshev polynomials for smaller |x|,
   and finally a Taylor expansion for |x|<0.01.

   Steven G. Johnson, October 2012. */

/* Given y100=100*y, where y = 1/(1+x) for x >= 0, compute w_im(x).

   Uses a look-up table of 100 different Chebyshev polynomials
   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
   with the help of Maple and a little shell script.   This allows
   the Chebyshev polynomials to be of significantly lower degree (about 1/30)
   compared to fitting the whole [0,1] interval with a single polynomial. */
static double w_im_y100(double y100, double x) {
  switch ((int) y100) {
    case 0: {
      double t = 2*y100 - 1;
      return 0.28351593328822191546e-2 + (0.28494783221378400759e-2 + (0.14427470563276734183e-4 + (0.10939723080231588129e-6 + (0.92474307943275042045e-9 + (0.89128907666450075245e-11 + 0.92974121935111111110e-13 * t) * t) * t) * t) * t) * t;
    }
    case 1: {
      double t = 2*y100 - 3;
      return 0.85927161243940350562e-2 + (0.29085312941641339862e-2 + (0.15106783707725582090e-4 + (0.11716709978531327367e-6 + (0.10197387816021040024e-8 + (0.10122678863073360769e-10 + 0.10917479678400000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 2: {
      double t = 2*y100 - 5;
      return 0.14471159831187703054e-1 + (0.29703978970263836210e-2 + (0.15835096760173030976e-4 + (0.12574803383199211596e-6 + (0.11278672159518415848e-8 + (0.11547462300333495797e-10 + 0.12894535335111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 3: {
      double t = 2*y100 - 7;
      return 0.20476320420324610618e-1 + (0.30352843012898665856e-2 + (0.16617609387003727409e-4 + (0.13525429711163116103e-6 + (0.12515095552507169013e-8 + (0.13235687543603382345e-10 + 0.15326595042666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 4: {
      double t = 2*y100 - 9;
      return 0.26614461952489004566e-1 + (0.31034189276234947088e-2 + (0.17460268109986214274e-4 + (0.14582130824485709573e-6 + (0.13935959083809746345e-8 + (0.15249438072998932900e-10 + 0.18344741882133333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 5: {
      double t = 2*y100 - 11;
      return 0.32892330248093586215e-1 + (0.31750557067975068584e-2 + (0.18369907582308672632e-4 + (0.15761063702089457882e-6 + (0.15577638230480894382e-8 + (0.17663868462699097951e-10 + (0.22126732680711111111e-12 + 0.30273474177737853668e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 6: {
      double t = 2*y100 - 13;
      return 0.39317207681134336024e-1 + (0.32504779701937539333e-2 + (0.19354426046513400534e-4 + (0.17081646971321290539e-6 + (0.17485733959327106250e-8 + (0.20593687304921961410e-10 + (0.26917401949155555556e-12 + 0.38562123837725712270e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 7: {
      double t = 2*y100 - 15;
      return 0.45896976511367738235e-1 + (0.33300031273110976165e-2 + (0.20423005398039037313e-4 + (0.18567412470376467303e-6 + (0.19718038363586588213e-8 + (0.24175006536781219807e-10 + (0.33059982791466666666e-12 + 0.49756574284439426165e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 8: {
      double t = 2*y100 - 17;
      return 0.52640192524848962855e-1 + (0.34139883358846720806e-2 + (0.21586390240603337337e-4 + (0.20247136501568904646e-6 + (0.22348696948197102935e-8 + (0.28597516301950162548e-10 + (0.41045502119111111110e-12 + 0.65151614515238361946e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 9: {
      double t = 2*y100 - 19;
      return 0.59556171228656770456e-1 + (0.35028374386648914444e-2 + (0.22857246150998562824e-4 + (0.22156372146525190679e-6 + (0.25474171590893813583e-8 + (0.34122390890697400584e-10 + (0.51593189879111111110e-12 + 0.86775076853908006938e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 10: {
      double t = 2*y100 - 21;
      return 0.66655089485108212551e-1 + (0.35970095381271285568e-2 + (0.24250626164318672928e-4 + (0.24339561521785040536e-6 + (0.29221990406518411415e-8 + (0.41117013527967776467e-10 + (0.65786450716444444445e-12 + 0.11791885745450623331e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 11: {
      double t = 2*y100 - 23;
      return 0.73948106345519174661e-1 + (0.36970297216569341748e-2 + (0.25784588137312868792e-4 + (0.26853012002366752770e-6 + (0.33763958861206729592e-8 + (0.50111549981376976397e-10 + (0.85313857496888888890e-12 + 0.16417079927706899860e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 12: {
      double t = 2*y100 - 25;
      return 0.81447508065002963203e-1 + (0.38035026606492705117e-2 + (0.27481027572231851896e-4 + (0.29769200731832331364e-6 + (0.39336816287457655076e-8 + (0.61895471132038157624e-10 + (0.11292303213511111111e-11 + 0.23558532213703884304e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 13: {
      double t = 2*y100 - 27;
      return 0.89166884027582716628e-1 + (0.39171301322438946014e-2 + (0.29366827260422311668e-4 + (0.33183204390350724895e-6 + (0.46276006281647330524e-8 + (0.77692631378169813324e-10 + (0.15335153258844444444e-11 + 0.35183103415916026911e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 14: {
      double t = 2*y100 - 29;
      return 0.97121342888032322019e-1 + (0.40387340353207909514e-2 + (0.31475490395950776930e-4 + (0.37222714227125135042e-6 + (0.55074373178613809996e-8 + (0.99509175283990337944e-10 + (0.21552645758222222222e-11 + 0.55728651431872687605e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 15: {
      double t = 2*y100 - 31;
      return 0.10532778218603311137e0 + (0.41692873614065380607e-2 + (0.33849549774889456984e-4 + (0.42064596193692630143e-6 + (0.66494579697622432987e-8 + (0.13094103581931802337e-9 + (0.31896187409777777778e-11 + 0.97271974184476560742e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 16: {
      double t = 2*y100 - 33;
      return 0.11380523107427108222e0 + (0.43099572287871821013e-2 + (0.36544324341565929930e-4 + (0.47965044028581857764e-6 + (0.81819034238463698796e-8 + (0.17934133239549647357e-9 + (0.50956666166186293627e-11 + (0.18850487318190638010e-12 + 0.79697813173519853340e-14 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 17: {
      double t = 2*y100 - 35;
      return 0.12257529703447467345e0 + (0.44621675710026986366e-2 + (0.39634304721292440285e-4 + (0.55321553769873381819e-6 + (0.10343619428848520870e-7 + (0.26033830170470368088e-9 + (0.87743837749108025357e-11 + (0.34427092430230063401e-12 + 0.10205506615709843189e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 18: {
      double t = 2*y100 - 37;
      return 0.13166276955656699478e0 + (0.46276970481783001803e-2 + (0.43225026380496399310e-4 + (0.64799164020016902656e-6 + (0.13580082794704641782e-7 + (0.39839800853954313927e-9 + (0.14431142411840000000e-10 + 0.42193457308830027541e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 19: {
      double t = 2*y100 - 39;
      return 0.14109647869803356475e0 + (0.48088424418545347758e-2 + (0.47474504753352150205e-4 + (0.77509866468724360352e-6 + (0.18536851570794291724e-7 + (0.60146623257887570439e-9 + (0.18533978397305276318e-10 + (0.41033845938901048380e-13 - 0.46160680279304825485e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 20: {
      double t = 2*y100 - 41;
      return 0.15091057940548936603e0 + (0.50086864672004685703e-2 + (0.52622482832192230762e-4 + (0.95034664722040355212e-6 + (0.25614261331144718769e-7 + (0.80183196716888606252e-9 + (0.12282524750534352272e-10 + (-0.10531774117332273617e-11 - 0.86157181395039646412e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 21: {
      double t = 2*y100 - 43;
      return 0.16114648116017010770e0 + (0.52314661581655369795e-2 + (0.59005534545908331315e-4 + (0.11885518333915387760e-5 + (0.33975801443239949256e-7 + (0.82111547144080388610e-9 + (-0.12357674017312854138e-10 + (-0.24355112256914479176e-11 - 0.75155506863572930844e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 22: {
      double t = 2*y100 - 45;
      return 0.17185551279680451144e0 + (0.54829002967599420860e-2 + (0.67013226658738082118e-4 + (0.14897400671425088807e-5 + (0.40690283917126153701e-7 + (0.44060872913473778318e-9 + (-0.52641873433280000000e-10 - 0.30940587864543343124e-11 * t) * t) * t) * t) * t) * t) * t;
    }
    case 23: {
      double t = 2*y100 - 47;
      return 0.18310194559815257381e0 + (0.57701559375966953174e-2 + (0.76948789401735193483e-4 + (0.18227569842290822512e-5 + (0.41092208344387212276e-7 + (-0.44009499965694442143e-9 + (-0.92195414685628803451e-10 + (-0.22657389705721753299e-11 + 0.10004784908106839254e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 24: {
      double t = 2*y100 - 49;
      return 0.19496527191546630345e0 + (0.61010853144364724856e-2 + (0.88812881056342004864e-4 + (0.21180686746360261031e-5 + (0.30652145555130049203e-7 + (-0.16841328574105890409e-8 + (-0.11008129460612823934e-9 + (-0.12180794204544515779e-12 + 0.15703325634590334097e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 25: {
      double t = 2*y100 - 51;
      return 0.20754006813966575720e0 + (0.64825787724922073908e-2 + (0.10209599627522311893e-3 + (0.22785233392557600468e-5 + (0.73495224449907568402e-8 + (-0.29442705974150112783e-8 + (-0.94082603434315016546e-10 + (0.23609990400179321267e-11 + 0.14141908654269023788e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 26: {
      double t = 2*y100 - 53;
      return 0.22093185554845172146e0 + (0.69182878150187964499e-2 + (0.11568723331156335712e-3 + (0.22060577946323627739e-5 + (-0.26929730679360840096e-7 + (-0.38176506152362058013e-8 + (-0.47399503861054459243e-10 + (0.40953700187172127264e-11 + 0.69157730376118511127e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 27: {
      double t = 2*y100 - 55;
      return 0.23524827304057813918e0 + (0.74063350762008734520e-2 + (0.12796333874615790348e-3 + (0.18327267316171054273e-5 + (-0.66742910737957100098e-7 + (-0.40204740975496797870e-8 + (0.14515984139495745330e-10 + (0.44921608954536047975e-11 - 0.18583341338983776219e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 28: {
      double t = 2*y100 - 57;
      return 0.25058626331812744775e0 + (0.79377285151602061328e-2 + (0.13704268650417478346e-3 + (0.11427511739544695861e-5 + (-0.10485442447768377485e-6 + (-0.34850364756499369763e-8 + (0.72656453829502179208e-10 + (0.36195460197779299406e-11 - 0.84882136022200714710e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 29: {
      double t = 2*y100 - 59;
      return 0.26701724900280689785e0 + (0.84959936119625864274e-2 + (0.14112359443938883232e-3 + (0.17800427288596909634e-6 + (-0.13443492107643109071e-6 + (-0.23512456315677680293e-8 + (0.11245846264695936769e-9 + (0.19850501334649565404e-11 - 0.11284666134635050832e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 30: {
      double t = 2*y100 - 61;
      return 0.28457293586253654144e0 + (0.90581563892650431899e-2 + (0.13880520331140646738e-3 + (-0.97262302362522896157e-6 + (-0.15077100040254187366e-6 + (-0.88574317464577116689e-9 + (0.12760311125637474581e-9 + (0.20155151018282695055e-12 - 0.10514169375181734921e-12 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 31: {
      double t = 2*y100 - 63;
      return 0.30323425595617385705e0 + (0.95968346790597422934e-2 + (0.12931067776725883939e-3 + (-0.21938741702795543986e-5 + (-0.15202888584907373963e-6 + (0.61788350541116331411e-9 + (0.11957835742791248256e-9 + (-0.12598179834007710908e-11 - 0.75151817129574614194e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 32: {
      double t = 2*y100 - 65;
      return 0.32292521181517384379e0 + (0.10082957727001199408e-1 + (0.11257589426154962226e-3 + (-0.33670890319327881129e-5 + (-0.13910529040004008158e-6 + (0.19170714373047512945e-8 + (0.94840222377720494290e-10 + (-0.21650018351795353201e-11 - 0.37875211678024922689e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 33: {
      double t = 2*y100 - 67;
      return 0.34351233557911753862e0 + (0.10488575435572745309e-1 + (0.89209444197248726614e-4 + (-0.43893459576483345364e-5 + (-0.11488595830450424419e-6 + (0.28599494117122464806e-8 + (0.61537542799857777779e-10 - 0.24935749227658002212e-11 * t) * t) * t) * t) * t) * t) * t;
    }
    case 34: {
      double t = 2*y100 - 69;
      return 0.36480946642143669093e0 + (0.10789304203431861366e-1 + (0.60357993745283076834e-4 + (-0.51855862174130669389e-5 + (-0.83291664087289801313e-7 + (0.33898011178582671546e-8 + (0.27082948188277716482e-10 + (-0.23603379397408694974e-11 + 0.19328087692252869842e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 35: {
      double t = 2*y100 - 71;
      return 0.38658679935694939199e0 + (0.10966119158288804999e-1 + (0.27521612041849561426e-4 + (-0.57132774537670953638e-5 + (-0.48404772799207914899e-7 + (0.35268354132474570493e-8 + (-0.32383477652514618094e-11 + (-0.19334202915190442501e-11 + 0.32333189861286460270e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 36: {
      double t = 2*y100 - 73;
      return 0.40858275583808707870e0 + (0.11006378016848466550e-1 + (-0.76396376685213286033e-5 + (-0.59609835484245791439e-5 + (-0.13834610033859313213e-7 + (0.33406952974861448790e-8 + (-0.26474915974296612559e-10 + (-0.13750229270354351983e-11 + 0.36169366979417390637e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 37: {
      double t = 2*y100 - 75;
      return 0.43051714914006682977e0 + (0.10904106549500816155e-1 + (-0.43477527256787216909e-4 + (-0.59429739547798343948e-5 + (0.17639200194091885949e-7 + (0.29235991689639918688e-8 + (-0.41718791216277812879e-10 + (-0.81023337739508049606e-12 + 0.33618915934461994428e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 38: {
      double t = 2*y100 - 77;
      return 0.45210428135559607406e0 + (0.10659670756384400554e-1 + (-0.78488639913256978087e-4 + (-0.56919860886214735936e-5 + (0.44181850467477733407e-7 + (0.23694306174312688151e-8 + (-0.49492621596685443247e-10 + (-0.31827275712126287222e-12 + 0.27494438742721623654e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 39: {
      double t = 2*y100 - 79;
      return 0.47306491195005224077e0 + (0.10279006119745977570e-1 + (-0.11140268171830478306e-3 + (-0.52518035247451432069e-5 + (0.64846898158889479518e-7 + (0.17603624837787337662e-8 + (-0.51129481592926104316e-10 + (0.62674584974141049511e-13 + 0.20055478560829935356e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 40: {
      double t = 2*y100 - 81;
      return 0.49313638965719857647e0 + (0.97725799114772017662e-2 + (-0.14122854267291533334e-3 + (-0.46707252568834951907e-5 + (0.79421347979319449524e-7 + (0.11603027184324708643e-8 + (-0.48269605844397175946e-10 + (0.32477251431748571219e-12 + 0.12831052634143527985e-13 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 41: {
      double t = 2*y100 - 83;
      return 0.51208057433416004042e0 + (0.91542422354009224951e-2 + (-0.16726530230228647275e-3 + (-0.39964621752527649409e-5 + (0.88232252903213171454e-7 + (0.61343113364949928501e-9 + (-0.42516755603130443051e-10 + (0.47910437172240209262e-12 + 0.66784341874437478953e-14 * t) * t) * t) * t) * t) * t) * t) * t;
    }
    case 42: {
      double t = 2*y100 - 85;
      return 0.52968945458607484524e0 + (0.84400880445116786088e-2 + (-0.18908729783854258774e-3 + (-0.32725905467782951931e-5 + (0.91956190588652090659e-7 + (0.14593989152420122909e-9 + (-0.35239490687644444445e-10 + 0.54613829888448694898e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 43: {
      double t = 2*y100 - 87;
      return 0.54578857454330070965e0 + (0.76474155195880295311e-2 + (-0.20651230590808213884e-3 + (-0.25364339140543131706e-5 + (0.91455367999510681979e-7 + (-0.23061359005297528898e-9 + (-0.27512928625244444444e-10 + 0.54895806008493285579e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 44: {
      double t = 2*y100 - 89;
      return 0.56023851910298493910e0 + (0.67938321739997196804e-2 + (-0.21956066613331411760e-3 + (-0.18181127670443266395e-5 + (0.87650335075416845987e-7 + (-0.51548062050366615977e-9 + (-0.20068462174044444444e-10 + 0.50912654909758187264e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 45: {
      double t = 2*y100 - 91;
      return 0.57293478057455721150e0 + (0.58965321010394044087e-2 + (-0.22841145229276575597e-3 + (-0.11404605562013443659e-5 + (0.81430290992322326296e-7 + (-0.71512447242755357629e-9 + (-0.13372664928000000000e-10 + 0.44461498336689298148e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 46: {
      double t = 2*y100 - 93;
      return 0.58380635448407827360e0 + (0.49717469530842831182e-2 + (-0.23336001540009645365e-3 + (-0.51952064448608850822e-6 + (0.73596577815411080511e-7 + (-0.84020916763091566035e-9 + (-0.76700972702222222221e-11 + 0.36914462807972467044e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 47: {
      double t = 2*y100 - 95;
      return 0.59281340237769489597e0 + (0.40343592069379730568e-2 + (-0.23477963738658326185e-3 + (0.34615944987790224234e-7 + (0.64832803248395814574e-7 + (-0.90329163587627007971e-9 + (-0.30421940400000000000e-11 + 0.29237386653743536669e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 48: {
      double t = 2*y100 - 97;
      return 0.59994428743114271918e0 + (0.30976579788271744329e-2 + (-0.23308875765700082835e-3 + (0.51681681023846925160e-6 + (0.55694594264948268169e-7 + (-0.91719117313243464652e-9 + (0.53982743680000000000e-12 + 0.22050829296187771142e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 49: {
      double t = 2*y100 - 99;
      return 0.60521224471819875444e0 + (0.21732138012345456060e-2 + (-0.22872428969625997456e-3 + (0.92588959922653404233e-6 + (0.46612665806531930684e-7 + (-0.89393722514414153351e-9 + (0.31718550353777777778e-11 + 0.15705458816080549117e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 50: {
      double t = 2*y100 - 101;
      return 0.60865189969791123620e0 + (0.12708480848877451719e-2 + (-0.22212090111534847166e-3 + (0.12636236031532793467e-5 + (0.37904037100232937574e-7 + (-0.84417089968101223519e-9 + (0.49843180828444444445e-11 + 0.10355439441049048273e-12 * t) * t) * t) * t) * t) * t) * t;
    }
    case 51: {
      double t = 2*y100 - 103;
      return 0.61031580103499200191e0 + (0.39867436055861038223e-3 + (-0.21369573439579869291e-3 + (0.15339402129026183670e-5 + (0.29787479206646594442e-7 + (-0.77687792914228632974e-9 + (0.61192452741333333334e-11 + 0.60216691829459295780e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 52: {
      double t = 2*y100 - 105;
      return 0.61027109047879835868e0 + (-0.43680904508059878254e-3 + (-0.20383783788303894442e-3 + (0.17421743090883439959e-5 + (0.22400425572175715576e-7 + (-0.69934719320045128997e-9 + (0.67152759655111111110e-11 + 0.26419960042578359995e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 53: {
      double t = 2*y100 - 107;
      return 0.60859639489217430521e0 + (-0.12305921390962936873e-2 + (-0.19290150253894682629e-3 + (0.18944904654478310128e-5 + (0.15815530398618149110e-7 + (-0.61726850580964876070e-9 + 0.68987888999111111110e-11 * t) * t) * t) * t) * t) * t;
    }
    case 54: {
      double t = 2*y100 - 109;
      return 0.60537899426486075181e0 + (-0.19790062241395705751e-2 + (-0.18120271393047062253e-3 + (0.19974264162313241405e-5 + (0.10055795094298172492e-7 + (-0.53491997919318263593e-9 + (0.67794550295111111110e-11 - 0.17059208095741511603e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 55: {
      double t = 2*y100 - 111;
      return 0.60071229457904110537e0 + (-0.26795676776166354354e-2 + (-0.16901799553627508781e-3 + (0.20575498324332621581e-5 + (0.51077165074461745053e-8 + (-0.45536079828057221858e-9 + (0.64488005516444444445e-11 - 0.29311677573152766338e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 56: {
      double t = 2*y100 - 113;
      return 0.59469361520112714738e0 + (-0.33308208190600993470e-2 + (-0.15658501295912405679e-3 + (0.20812116912895417272e-5 + (0.93227468760614182021e-9 + (-0.38066673740116080415e-9 + (0.59806790359111111110e-11 - 0.36887077278950440597e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 57: {
      double t = 2*y100 - 115;
      return 0.58742228631775388268e0 + (-0.39321858196059227251e-2 + (-0.14410441141450122535e-3 + (0.20743790018404020716e-5 + (-0.25261903811221913762e-8 + (-0.31212416519526924318e-9 + (0.54328422462222222221e-11 - 0.40864152484979815972e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 58: {
      double t = 2*y100 - 117;
      return 0.57899804200033018447e0 + (-0.44838157005618913447e-2 + (-0.13174245966501437965e-3 + (0.20425306888294362674e-5 + (-0.53330296023875447782e-8 + (-0.25041289435539821014e-9 + (0.48490437205333333334e-11 - 0.42162206939169045177e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 59: {
      double t = 2*y100 - 119;
      return 0.56951968796931245974e0 + (-0.49864649488074868952e-2 + (-0.11963416583477567125e-3 + (0.19906021780991036425e-5 + (-0.75580140299436494248e-8 + (-0.19576060961919820491e-9 + (0.42613011928888888890e-11 - 0.41539443304115604377e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 60: {
      double t = 2*y100 - 121;
      return 0.55908401930063918964e0 + (-0.54413711036826877753e-2 + (-0.10788661102511914628e-3 + (0.19229663322982839331e-5 + (-0.92714731195118129616e-8 + (-0.14807038677197394186e-9 + (0.36920870298666666666e-11 - 0.39603726688419162617e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 61: {
      double t = 2*y100 - 123;
      return 0.54778496152925675315e0 + (-0.58501497933213396670e-2 + (-0.96582314317855227421e-4 + (0.18434405235069270228e-5 + (-0.10541580254317078711e-7 + (-0.10702303407788943498e-9 + (0.31563175582222222222e-11 - 0.36829748079110481422e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 62: {
      double t = 2*y100 - 125;
      return 0.53571290831682823999e0 + (-0.62147030670760791791e-2 + (-0.85782497917111760790e-4 + (0.17553116363443470478e-5 + (-0.11432547349815541084e-7 + (-0.72157091369041330520e-10 + (0.26630811607111111111e-11 - 0.33578660425893164084e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 63: {
      double t = 2*y100 - 127;
      return 0.52295422962048434978e0 + (-0.65371404367776320720e-2 + (-0.75530164941473343780e-4 + (0.16613725797181276790e-5 + (-0.12003521296598910761e-7 + (-0.42929753689181106171e-10 + (0.22170894940444444444e-11 - 0.30117697501065110505e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 64: {
      double t = 2*y100 - 129;
      return 0.50959092577577886140e0 + (-0.68197117603118591766e-2 + (-0.65852936198953623307e-4 + (0.15639654113906716939e-5 + (-0.12308007991056524902e-7 + (-0.18761997536910939570e-10 + (0.18198628922666666667e-11 - 0.26638355362285200932e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 65: {
      double t = 2*y100 - 131;
      return 0.49570040481823167970e0 + (-0.70647509397614398066e-2 + (-0.56765617728962588218e-4 + (0.14650274449141448497e-5 + (-0.12393681471984051132e-7 + (0.92904351801168955424e-12 + (0.14706755960177777778e-11 - 0.23272455351266325318e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 66: {
      double t = 2*y100 - 133;
      return 0.48135536250935238066e0 + (-0.72746293327402359783e-2 + (-0.48272489495730030780e-4 + (0.13661377309113939689e-5 + (-0.12302464447599382189e-7 + (0.16707760028737074907e-10 + (0.11672928324444444444e-11 - 0.20105801424709924499e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 67: {
      double t = 2*y100 - 135;
      return 0.46662374675511439448e0 + (-0.74517177649528487002e-2 + (-0.40369318744279128718e-4 + (0.12685621118898535407e-5 + (-0.12070791463315156250e-7 + (0.29105507892605823871e-10 + (0.90653314645333333334e-12 - 0.17189503312102982646e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 68: {
      double t = 2*y100 - 137;
      return 0.45156879030168268778e0 + (-0.75983560650033817497e-2 + (-0.33045110380705139759e-4 + (0.11732956732035040896e-5 + (-0.11729986947158201869e-7 + (0.38611905704166441308e-10 + (0.68468768305777777779e-12 - 0.14549134330396754575e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 69: {
      double t = 2*y100 - 139;
      return 0.43624909769330896904e0 + (-0.77168291040309554679e-2 + (-0.26283612321339907756e-4 + (0.10811018836893550820e-5 + (-0.11306707563739851552e-7 + (0.45670446788529607380e-10 + (0.49782492549333333334e-12 - 0.12191983967561779442e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 70: {
      double t = 2*y100 - 141;
      return 0.42071877443548481181e0 + (-0.78093484015052730097e-2 + (-0.20064596897224934705e-4 + (0.99254806680671890766e-6 + (-0.10823412088884741451e-7 + (0.50677203326904716247e-10 + (0.34200547594666666666e-12 - 0.10112698698356194618e-13 * t) * t) * t) * t) * t) * t) * t;
    }
    case 71: {
      double t = 2*y100 - 143;
      return 0.40502758809710844280e0 + (-0.78780384460872937555e-2 + (-0.14364940764532853112e-4 + (0.90803709228265217384e-6 + (-0.10298832847014466907e-7 + (0.53981671221969478551e-10 + (0.21342751381333333333e-12 - 0.82975901848387729274e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 72: {
      double t = 2*y100 - 145;
      return 0.38922115269731446690e0 + (-0.79249269708242064120e-2 + (-0.91595258799106970453e-5 + (0.82783535102217576495e-6 + (-0.97484311059617744437e-8 + (0.55889029041660225629e-10 + (0.10851981336888888889e-12 - 0.67278553237853459757e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 73: {
      double t = 2*y100 - 147;
      return 0.37334112915460307335e0 + (-0.79519385109223148791e-2 + (-0.44219833548840469752e-5 + (0.75209719038240314732e-6 + (-0.91848251458553190451e-8 + (0.56663266668051433844e-10 + (0.23995894257777777778e-13 - 0.53819475285389344313e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 74: {
      double t = 2*y100 - 149;
      return 0.35742543583374223085e0 + (-0.79608906571527956177e-2 + (-0.12530071050975781198e-6 + (0.68088605744900552505e-6 + (-0.86181844090844164075e-8 + (0.56530784203816176153e-10 + (-0.43120012248888888890e-13 - 0.42372603392496813810e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 75: {
      double t = 2*y100 - 151;
      return 0.34150846431979618536e0 + (-0.79534924968773806029e-2 + (0.37576885610891515813e-5 + (0.61419263633090524326e-6 + (-0.80565865409945960125e-8 + (0.55684175248749269411e-10 + (-0.95486860764444444445e-13 - 0.32712946432984510595e-14 * t) * t) * t) * t) * t) * t) * t;
    }
    case 76: {
      double t = 2*y100 - 153;
      return 0.32562129649136346824e0 + (-0.79313448067948884309e-2 + (0.72539159933545300034e-5 + (0.55195028297415503083e-6 + (-0.75063365335570475258e-8 + (0.54281686749699595941e-10 - 0.13545424295111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 77: {
      double t = 2*y100 - 155;
      return 0.30979191977078391864e0 + (-0.78959416264207333695e-2 + (0.10389774377677210794e-4 + (0.49404804463196316464e-6 + (-0.69722488229411164685e-8 + (0.52469254655951393842e-10 - 0.16507860650666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 78: {
      double t = 2*y100 - 157;
      return 0.29404543811214459904e0 + (-0.78486728990364155356e-2 + (0.13190885683106990459e-4 + (0.44034158861387909694e-6 + (-0.64578942561562616481e-8 + (0.50354306498006928984e-10 - 0.18614473550222222222e-12 * t) * t) * t) * t) * t) * t;
    }
    case 79: {
      double t = 2*y100 - 159;
      return 0.27840427686253660515e0 + (-0.77908279176252742013e-2 + (0.15681928798708548349e-4 + (0.39066226205099807573e-6 + (-0.59658144820660420814e-8 + (0.48030086420373141763e-10 - 0.20018995173333333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 80: {
      double t = 2*y100 - 161;
      return 0.26288838011163800908e0 + (-0.77235993576119469018e-2 + (0.17886516796198660969e-4 + (0.34482457073472497720e-6 + (-0.54977066551955420066e-8 + (0.45572749379147269213e-10 - 0.20852924954666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 81: {
      double t = 2*y100 - 163;
      return 0.24751539954181029717e0 + (-0.76480877165290370975e-2 + (0.19827114835033977049e-4 + (0.30263228619976332110e-6 + (-0.50545814570120129947e-8 + (0.43043879374212005966e-10 - 0.21228012028444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 82: {
      double t = 2*y100 - 165;
      return 0.23230087411688914593e0 + (-0.75653060136384041587e-2 + (0.21524991113020016415e-4 + (0.26388338542539382413e-6 + (-0.46368974069671446622e-8 + (0.40492715758206515307e-10 - 0.21238627815111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 83: {
      double t = 2*y100 - 167;
      return 0.21725840021297341931e0 + (-0.74761846305979730439e-2 + (0.23000194404129495243e-4 + (0.22837400135642906796e-6 + (-0.42446743058417541277e-8 + (0.37958104071765923728e-10 - 0.20963978568888888889e-12 * t) * t) * t) * t) * t) * t;
    }
    case 84: {
      double t = 2*y100 - 169;
      return 0.20239979200788191491e0 + (-0.73815761980493466516e-2 + (0.24271552727631854013e-4 + (0.19590154043390012843e-6 + (-0.38775884642456551753e-8 + (0.35470192372162901168e-10 - 0.20470131678222222222e-12 * t) * t) * t) * t) * t) * t;
    }
    case 85: {
      double t = 2*y100 - 171;
      return 0.18773523211558098962e0 + (-0.72822604530339834448e-2 + (0.25356688567841293697e-4 + (0.16626710297744290016e-6 + (-0.35350521468015310830e-8 + (0.33051896213898864306e-10 - 0.19811844544000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 86: {
      double t = 2*y100 - 173;
      return 0.17327341258479649442e0 + (-0.71789490089142761950e-2 + (0.26272046822383820476e-4 + (0.13927732375657362345e-6 + (-0.32162794266956859603e-8 + (0.30720156036105652035e-10 - 0.19034196304000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 87: {
      double t = 2*y100 - 175;
      return 0.15902166648328672043e0 + (-0.70722899934245504034e-2 + (0.27032932310132226025e-4 + (0.11474573347816568279e-6 + (-0.29203404091754665063e-8 + (0.28487010262547971859e-10 - 0.18174029063111111111e-12 * t) * t) * t) * t) * t) * t;
    }
    case 88: {
      double t = 2*y100 - 177;
      return 0.14498609036610283865e0 + (-0.69628725220045029273e-2 + (0.27653554229160596221e-4 + (0.92493727167393036470e-7 + (-0.26462055548683583849e-8 + (0.26360506250989943739e-10 - 0.17261211260444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 89: {
      double t = 2*y100 - 179;
      return 0.13117165798208050667e0 + (-0.68512309830281084723e-2 + (0.28147075431133863774e-4 + (0.72351212437979583441e-7 + (-0.23927816200314358570e-8 + (0.24345469651209833155e-10 - 0.16319736960000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 90: {
      double t = 2*y100 - 181;
      return 0.11758232561160626306e0 + (-0.67378491192463392927e-2 + (0.28525664781722907847e-4 + (0.54156999310046790024e-7 + (-0.21589405340123827823e-8 + (0.22444150951727334619e-10 - 0.15368675584000000000e-12 * t) * t) * t) * t) * t) * t;
    }
    case 91: {
      double t = 2*y100 - 183;
      return 0.10422112945361673560e0 + (-0.66231638959845581564e-2 + (0.28800551216363918088e-4 + (0.37758983397952149613e-7 + (-0.19435423557038933431e-8 + (0.20656766125421362458e-10 - 0.14422990012444444444e-12 * t) * t) * t) * t) * t) * t;
    }
    case 92: {
      double t = 2*y100 - 185;
      return 0.91090275493541084785e-1 + (-0.65075691516115160062e-2 + (0.28982078385527224867e-4 + (0.23014165807643012781e-7 + (-0.17454532910249875958e-8 + (0.18981946442680092373e-10 - 0.13494234691555555556e-12 * t) * t) * t) * t) * t) * t;
    }
    case 93: {
      double t = 2*y100 - 187;
      return 0.78191222288771379358e-1 + (-0.63914190297303976434e-2 + (0.29079759021299682675e-4 + (0.97885458059415717014e-8 + (-0.15635596116134296819e-8 + (0.17417110744051331974e-10 - 0.12591151763555555556e-12 * t) * t) * t) * t) * t) * t;
    }
    case 94: {
      double t = 2*y100 - 189;
      return 0.65524757106147402224e-1 + (-0.62750311956082444159e-2 + (0.29102328354323449795e-4 + (-0.20430838882727954582e-8 + (-0.13967781903855367270e-8 + (0.15958771833747057569e-10 - 0.11720175765333333333e-12 * t) * t) * t) * t) * t) * t;
    }
    case 95: {
      double t = 2*y100 - 191;
      return 0.53091065838453612773e-1 + (-0.61586898417077043662e-2 + (0.29057796072960100710e-4 + (-0.12597414620517987536e-7 + (-0.12440642607426861943e-8 + (0.14602787128447932137e-10 - 0.10885859114666666667e-12 * t) * t) * t) * t) * t) * t;
    }
    case 96: {
      double t = 2*y100 - 193;
      return 0.40889797115352738582e-1 + (-0.60426484889413678200e-2 + (0.28953496450191694606e-4 + (-0.21982952021823718400e-7 + (-0.11044169117553026211e-8 + (0.13344562332430552171e-10 - 0.10091231402844444444e-12 * t) * t) * t) * t) * t) * t;
    }
  case 97: case 98:
  case 99: case 100: { // use Taylor expansion for small x (|x| <= 0.0309...)
      //  (2/sqrt(pi)) * (x - 2/3 x^3  + 4/15 x^5  - 8/105 x^7 + 16/945 x^9)
      double x2 = x*x;
      return x * (1.1283791670955125739
                  - x2 * (0.75225277806367504925
                          - x2 * (0.30090111122547001970
                                  - x2 * (0.085971746064420005629
                                          - x2 * 0.016931216931216931217))));
    }
  }
  /* Since 0 <= y100 < 101, this is only reached if x is NaN,
     in which case we should return NaN. */
  return NaN;
}

double FADDEEVA(w_im)(double x)
{
  if (x >= 0) {
    if (x > 45) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x > 5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
    }
    return w_im_y100(100/(1+x), x);
  }
  else { // = -FADDEEVA(w_im)(-x)
    if (x < -45) { // continued-fraction expansion is faster
      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
      if (x < -5e7) // 1-term expansion, important to avoid overflow
        return ispi / x;
      /* 5-term expansion (rely on compiler for CSE), simplified from:
                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
    }
    return -w_im_y100(100/(1-x), -x);
  }
}

/////////////////////////////////////////////////////////////////////////

// Compile with -DTEST_FADDEEVA to compile a little test program
#ifdef TEST_FADDEEVA

#ifdef __cplusplus
#  include <cstdio>
#else
#  include <stdio.h>
#endif

// compute relative error |b-a|/|a|, handling case of NaN and Inf,
static double relerr(double a, double b) {
  if (isnan(a) || isnan(b) || isinf(a) || isinf(b)) {
    if ((isnan(a) && !isnan(b)) || (!isnan(a) && isnan(b)) ||
        (isinf(a) && !isinf(b)) || (!isinf(a) && isinf(b)) ||
        (isinf(a) && isinf(b) && a*b < 0))
      return Inf; // "infinite" error
    return 0; // matching infinity/nan results counted as zero error
  }
  if (a == 0)
    return b == 0 ? 0 : Inf;
  else
    return fabs((b-a) / a);
}

int main(void) {
  double errmax_all = 0;
  {
    printf("############# w(z) tests #############\n");
#define NTST 57 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(624.2,-0.26123),
      C(-0.4,3.),
      C(0.6,2.),
      C(-1.,1.),
      C(-1.,-9.),
      C(-1.,9.),
      C(-0.0000000234545,1.1234),
      C(-3.,5.1),
      C(-53,30.1),
      C(0.0,0.12345),
      C(11,1),
      C(-22,-2),
      C(9,-28),
      C(21,-33),
      C(1e5,1e5),
      C(1e14,1e14),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(-6.01,0.01),
      C(-0.7,-0.7),
      C(2.611780000000000e+01, 4.540909610972489e+03),
      C(0.8e7,0.3e7),
      C(-20,-19.8081),
      C(1e-16,-1.1e-16),
      C(2.3e-8,1.3e-8),
      C(6.3,-1e-13),
      C(6.3,1e-20),
      C(1e-20,6.3),
      C(1e-20,16.3),
      C(9,1e-300),
      C(6.01,0.11),
      C(8.01,1.01e-10),
      C(28.01,1e-300),
      C(10.01,1e-200),
      C(10.01,-1e-200),
      C(10.01,0.99e-10),
      C(10.01,-0.99e-10),
      C(1e-20,7.01),
      C(-1,7.01),
      C(5.99,7.01),
      C(1,0),
      C(55,0),
      C(-0.1,0),
      C(1e-20,0),
      C(0,5e-14),
      C(0,51),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN)
    };
    cmplx w[NTST] = { /* w(z), computed with WolframAlpha
                                   ... note that WolframAlpha is problematic
                                   some of the above inputs, so I had to
                                   use the continued-fraction expansion
                                   in WolframAlpha in some cases, or switch
                                   to Maple */
      C(-3.78270245518980507452677445620103199303131110e-7,
        0.000903861276433172057331093754199933411710053155),
      C(0.1764906227004816847297495349730234591778719532788,
        -0.02146550539468457616788719893991501311573031095617),
      C(0.2410250715772692146133539023007113781272362309451,
        0.06087579663428089745895459735240964093522265589350),
      C(0.30474420525691259245713884106959496013413834051768,
        -0.20821893820283162728743734725471561394145872072738),
      C(7.317131068972378096865595229600561710140617977e34,
        8.321873499714402777186848353320412813066170427e34),
      C(0.0615698507236323685519612934241429530190806818395,
        -0.00676005783716575013073036218018565206070072304635),
      C(0.3960793007699874918961319170187598400134746631,
        -5.593152259116644920546186222529802777409274656e-9),
      C(0.08217199226739447943295069917990417630675021771804,
        -0.04701291087643609891018366143118110965272615832184),
      C(0.00457246000350281640952328010227885008541748668738,
        -0.00804900791411691821818731763401840373998654987934),
      C(0.8746342859608052666092782112565360755791467973338452,
        0.),
      C(0.00468190164965444174367477874864366058339647648741,
        0.0510735563901306197993676329845149741675029197050),
      C(-0.0023193175200187620902125853834909543869428763219,
        -0.025460054739731556004902057663500272721780776336),
      C(9.11463368405637174660562096516414499772662584e304,
        3.97101807145263333769664875189354358563218932e305),
      C(-4.4927207857715598976165541011143706155432296e281,
        -2.8019591213423077494444700357168707775769028e281),
      C(2.820947917809305132678577516325951485807107151e-6,
        2.820947917668257736791638444590253942253354058e-6),
      C(2.82094791773878143474039725787438662716372268e-15,
        2.82094791773878143474039725773333923127678361e-15),
      C(-0.0000563851289696244350147899376081488003110150498,
        -0.000169211755126812174631861529808288295454992688),
      C(-5.586035480670854326218608431294778077663867e-162,
        5.586035480670854326218608431294778077663867e-161),
      C(0.00016318325137140451888255634399123461580248456,
        -0.095232456573009287370728788146686162555021209999),
      C(0.69504753678406939989115375989939096800793577783885,
        -1.8916411171103639136680830887017670616339912024317),
      C(0.0001242418269653279656612334210746733213167234822,
        7.145975826320186888508563111992099992116786763e-7),
      C(2.318587329648353318615800865959225429377529825e-8,
        6.182899545728857485721417893323317843200933380e-8),
      C(-0.0133426877243506022053521927604277115767311800303,
        -0.0148087097143220769493341484176979826888871576145),
      C(1.00000000000000012412170838050638522857747934,
        1.12837916709551279389615890312156495593616433e-16),
      C(0.9999999853310704677583504063775310832036830015,
        2.595272024519678881897196435157270184030360773e-8),
      C(-1.4731421795638279504242963027196663601154624e-15,
        0.090727659684127365236479098488823462473074709),
      C(5.79246077884410284575834156425396800754409308e-18,
        0.0907276596841273652364790985059772809093822374),
      C(0.0884658993528521953466533278764830881245144368,
        1.37088352495749125283269718778582613192166760e-22),
      C(0.0345480845419190424370085249304184266813447878,
        2.11161102895179044968099038990446187626075258e-23),
      C(6.63967719958073440070225527042829242391918213e-36,
        0.0630820900592582863713653132559743161572639353),
      C(0.00179435233208702644891092397579091030658500743634,
        0.0951983814805270647939647438459699953990788064762),
      C(9.09760377102097999924241322094863528771095448e-13,
        0.0709979210725138550986782242355007611074966717),
      C(7.2049510279742166460047102593255688682910274423e-304,
        0.0201552956479526953866611812593266285000876784321),
      C(3.04543604652250734193622967873276113872279682e-44,
        0.0566481651760675042930042117726713294607499165),
      C(3.04543604652250734193622967873276113872279682e-44,
        0.0566481651760675042930042117726713294607499165),
      C(0.5659928732065273429286988428080855057102069081e-12,
        0.056648165176067504292998527162143030538756683302),
      C(-0.56599287320652734292869884280802459698927645e-12,
        0.0566481651760675042929985271621430305387566833029),
      C(0.0796884251721652215687859778119964009569455462,
        1.11474461817561675017794941973556302717225126e-22),
      C(0.07817195821247357458545539935996687005781943386550,
        -0.01093913670103576690766705513142246633056714279654),
      C(0.04670032980990449912809326141164730850466208439937,
        0.03944038961933534137558064191650437353429669886545),
      C(0.36787944117144232159552377016146086744581113103176,
        0.60715770584139372911503823580074492116122092866515),
      C(0,
        0.010259688805536830986089913987516716056946786526145),
      C(0.99004983374916805357390597718003655777207908125383,
        -0.11208866436449538036721343053869621153527769495574),
      C(0.99999999999999999999999999999999999999990000,
        1.12837916709551257389615890312154517168802603e-20),
      C(0.999999999999943581041645226871305192054749891144158,
        0),
      C(0.0110604154853277201542582159216317923453996211744250,
        0),
      C(0,0),
      C(0,0),
      C(0,0),
      C(Inf,0),
      C(0,0),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,0),
      C(NaN,NaN),
      C(NaN,NaN)
    };
    double errmax = 0;
    for (int i = 0; i < NTST; ++i) {
      cmplx fw = FADDEEVA(w)(z[i],0.);
      double re_err = relerr(creal(w[i]), creal(fw));
      double im_err = relerr(cimag(w[i]), cimag(fw));
      printf("w(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n",
             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]),
             re_err, im_err);
      if (re_err > errmax) errmax = re_err;
      if (im_err > errmax) errmax = im_err;
    }
    if (errmax > 1e-13) {
      printf("FAILURE -- relative error %g too large!\n", errmax);
      return 1;
    }
    printf("SUCCESS (max relative error = %g)\n", errmax);
    if (errmax > errmax_all) errmax_all = errmax;
  }
  {
#undef NTST
#define NTST 41 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(1,2),
      C(-1,2),
      C(1,-2),
      C(-1,-2),
      C(9,-28),
      C(21,-33),
      C(1e3,1e3),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(5.1e-3, 1e-8),
      C(-4.9e-3, 4.95e-3),
      C(4.9e-3, 0.5),
      C(4.9e-4, -0.5e1),
      C(-4.9e-5, -0.5e2),
      C(5.1e-3, 0.5),
      C(5.1e-4, -0.5e1),
      C(-5.1e-5, -0.5e2),
      C(1e-6,2e-6),
      C(0,2e-6),
      C(0,2),
      C(0,20),
      C(0,200),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(1e-3,NaN),
      C(7e-2,7e-2),
      C(7e-2,-7e-4),
      C(-9e-2,7e-4),
      C(-9e-2,9e-2),
      C(-7e-4,9e-2),
      C(7e-2,0.9e-2),
      C(7e-2,1.1e-2)
    };
    cmplx w[NTST] = { // erf(z[i]), evaluated with Maple
      C(-0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553),
      C(0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553),
      C(-0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553),
      C(0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553),
      C(0.3359473673830576996788000505817956637777e304,
        -0.1999896139679880888755589794455069208455e304),
      C(0.3584459971462946066523939204836760283645e278,
        0.3818954885257184373734213077678011282505e280),
      C(0.9996020422657148639102150147542224526887,
        0.00002801044116908227889681753993542916894856),
      C(-1, 0),
      C(1, 0),
      C(0.005754683859034800134412990541076554934877,
        0.1128349818335058741511924929801267822634e-7),
      C(-0.005529149142341821193633460286828381876955,
        0.005585388387864706679609092447916333443570),
      C(0.007099365669981359632319829148438283865814,
        0.6149347012854211635026981277569074001219),
      C(0.3981176338702323417718189922039863062440e8,
        -0.8298176341665249121085423917575122140650e10),
      C(-Inf,
        -Inf),
      C(0.007389128308257135427153919483147229573895,
        0.6149332524601658796226417164791221815139),
      C(0.4143671923267934479245651547534414976991e8,
        -0.8298168216818314211557046346850921446950e10),
      C(-Inf,
        -Inf),
      C(0.1128379167099649964175513742247082845155e-5,
        0.2256758334191777400570377193451519478895e-5),
      C(0,
        0.2256758334194034158904576117253481476197e-5),
      C(0,
        18.56480241457555259870429191324101719886),
      C(0,
        0.1474797539628786202447733153131835124599e173),
      C(0,
        Inf),
      C(1,0),
      C(-1,0),
      C(0,Inf),
      C(0,-Inf),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(NaN,NaN),
      C(0.07924380404615782687930591956705225541145,
        0.07872776218046681145537914954027729115247),
      C(0.07885775828512276968931773651224684454495,
        -0.0007860046704118224342390725280161272277506),
      C(-0.1012806432747198859687963080684978759881,
        0.0007834934747022035607566216654982820299469),
      C(-0.1020998418798097910247132140051062512527,
        0.1010030778892310851309082083238896270340),
      C(-0.0007962891763147907785684591823889484764272,
        0.1018289385936278171741809237435404896152),
      C(0.07886408666470478681566329888615410479530,
        0.01010604288780868961492224347707949372245),
      C(0.07886723099940260286824654364807981336591,
        0.01235199327873258197931147306290916629654)
    };
#define TST(f,isc)                                                      \
    printf("############# " #f "(z) tests #############\n");            \
    double errmax = 0;                                                  \
    for (int i = 0; i < NTST; ++i) {                                    \
      cmplx fw = FADDEEVA(f)(z[i],0.);                  \
      double re_err = relerr(creal(w[i]), creal(fw));                   \
      double im_err = relerr(cimag(w[i]), cimag(fw));                   \
      printf(#f "(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n", \
             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]), \
             re_err, im_err);                                           \
      if (re_err > errmax) errmax = re_err;                             \
      if (im_err > errmax) errmax = im_err;                             \
    }                                                                   \
    if (errmax > 1e-13) {                                               \
      printf("FAILURE -- relative error %g too large!\n", errmax);      \
      return 1;                                                         \
    }                                                                   \
    printf("Checking " #f "(x) special case...\n");                     \
    for (int i = 0; i < 10000; ++i) {                                   \
      double x = pow(10., -300. + i * 600. / (10000 - 1));              \
      double re_err = relerr(FADDEEVA_RE(f)(x),                         \
                             creal(FADDEEVA(f)(C(x,x*isc),0.)));        \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(-x),                               \
                      creal(FADDEEVA(f)(C(-x,x*isc),0.)));              \
      if (re_err > errmax) errmax = re_err;                             \
    }                                                                   \
    {                                                                   \
      double re_err = relerr(FADDEEVA_RE(f)(Inf),                       \
                             creal(FADDEEVA(f)(C(Inf,0.),0.))); \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(-Inf),                             \
                      creal(FADDEEVA(f)(C(-Inf,0.),0.)));               \
      if (re_err > errmax) errmax = re_err;                             \
      re_err = relerr(FADDEEVA_RE(f)(NaN),                              \
                      creal(FADDEEVA(f)(C(NaN,0.),0.)));                \
      if (re_err > errmax) errmax = re_err;                             \
    }                                                                   \
    if (errmax > 1e-13) {                                               \
      printf("FAILURE -- relative error %g too large!\n", errmax);      \
      return 1;                                                         \
    }                                                                   \
    printf("SUCCESS (max relative error = %g)\n", errmax);              \
    if (errmax > errmax_all) errmax_all = errmax

    TST(erf, 1e-20);
  }
  {
    // since erfi just calls through to erf, just one test should
    // be sufficient to make sure I didn't screw up the signs or something
#undef NTST
#define NTST 1 // define instead of const for C compatibility
    cmplx z[NTST] = { C(1.234,0.5678) };
    cmplx w[NTST] = { // erfi(z[i]), computed with Maple
      C(1.081032284405373149432716643834106923212,
        1.926775520840916645838949402886591180834)
    };
    TST(erfi, 0);
  }
  {
    // since erfcx just calls through to w, just one test should
    // be sufficient to make sure I didn't screw up the signs or something
#undef NTST
#define NTST 1 // define instead of const for C compatibility
    cmplx z[NTST] = { C(1.234,0.5678) };
    cmplx w[NTST] = { // erfcx(z[i]), computed with Maple
      C(0.3382187479799972294747793561190487832579,
        -0.1116077470811648467464927471872945833154)
    };
    TST(erfcx, 0);
  }
  {
#undef NTST
#define NTST 30 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(1,2),
      C(-1,2),
      C(1,-2),
      C(-1,-2),
      C(9,-28),
      C(21,-33),
      C(1e3,1e3),
      C(-3001,-1000),
      C(1e160,-1e159),
      C(5.1e-3, 1e-8),
      C(0,2e-6),
      C(0,2),
      C(0,20),
      C(0,200),
      C(2e-6,0),
      C(2,0),
      C(20,0),
      C(200,0),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(88,0)
    };
    cmplx w[NTST] = { // erfc(z[i]), evaluated with Maple
      C(1.536643565778565033991795559314192749442,
        5.049143703447034669543036958614140565553),
      C(0.4633564342214349660082044406858072505579,
        5.049143703447034669543036958614140565553),
      C(1.536643565778565033991795559314192749442,
        -5.049143703447034669543036958614140565553),
      C(0.4633564342214349660082044406858072505579,
        -5.049143703447034669543036958614140565553),
      C(-0.3359473673830576996788000505817956637777e304,
        0.1999896139679880888755589794455069208455e304),
      C(-0.3584459971462946066523939204836760283645e278,
        -0.3818954885257184373734213077678011282505e280),
      C(0.0003979577342851360897849852457775473112748,
        -0.00002801044116908227889681753993542916894856),
      C(2, 0),
      C(0, 0),
      C(0.9942453161409651998655870094589234450651,
        -0.1128349818335058741511924929801267822634e-7),
      C(1,
        -0.2256758334194034158904576117253481476197e-5),
      C(1,
        -18.56480241457555259870429191324101719886),
      C(1,
        -0.1474797539628786202447733153131835124599e173),
      C(1, -Inf),
      C(0.9999977432416658119838633199332831406314,
        0),
      C(0.004677734981047265837930743632747071389108,
        0),
      C(0.5395865611607900928934999167905345604088e-175,
        0),
      C(0, 0),
      C(0, 0),
      C(2, 0),
      C(1, -Inf),
      C(1, Inf),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, 0),
      C(1, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(0,0)
    };
    TST(erfc, 1e-20);
  }
  {
#undef NTST
#define NTST 48 // define instead of const for C compatibility
    cmplx z[NTST] = {
      C(2,1),
      C(-2,1),
      C(2,-1),
      C(-2,-1),
      C(-28,9),
      C(33,-21),
      C(1e3,1e3),
      C(-1000,-3001),
      C(1e-8, 5.1e-3),
      C(4.95e-3, -4.9e-3),
      C(5.1e-3, 5.1e-3),
      C(0.5, 4.9e-3),
      C(-0.5e1, 4.9e-4),
      C(-0.5e2, -4.9e-5),
      C(0.5e3, 4.9e-6),
      C(0.5, 5.1e-3),
      C(-0.5e1, 5.1e-4),
      C(-0.5e2, -5.1e-5),
      C(1e-6,2e-6),
      C(2e-6,0),
      C(2,0),
      C(20,0),
      C(200,0),
      C(0,4.9e-3),
      C(0,-5.1e-3),
      C(0,2e-6),
      C(0,-2),
      C(0,20),
      C(0,-200),
      C(Inf,0),
      C(-Inf,0),
      C(0,Inf),
      C(0,-Inf),
      C(Inf,Inf),
      C(Inf,-Inf),
      C(NaN,NaN),
      C(NaN,0),
      C(0,NaN),
      C(NaN,Inf),
      C(Inf,NaN),
      C(39, 6.4e-5),
      C(41, 6.09e-5),
      C(4.9e7, 5e-11),
      C(5.1e7, 4.8e-11),
      C(1e9, 2.4e-12),
      C(1e11, 2.4e-14),
      C(1e13, 2.4e-16),
      C(1e300, 2.4e-303)
    };
    cmplx w[NTST] = { // dawson(z[i]), evaluated with Maple
      C(0.1635394094345355614904345232875688576839,
        -0.1531245755371229803585918112683241066853),
      C(-0.1635394094345355614904345232875688576839,
        -0.1531245755371229803585918112683241066853),
      C(0.1635394094345355614904345232875688576839,
        0.1531245755371229803585918112683241066853),
      C(-0.1635394094345355614904345232875688576839,
        0.1531245755371229803585918112683241066853),
      C(-0.01619082256681596362895875232699626384420,
        -0.005210224203359059109181555401330902819419),
      C(0.01078377080978103125464543240346760257008,
        0.006866888783433775382193630944275682670599),
      C(-0.5808616819196736225612296471081337245459,
        0.6688593905505562263387760667171706325749),
      C(Inf,
        -Inf),
      C(0.1000052020902036118082966385855563526705e-7,
        0.005100088434920073153418834680320146441685),
      C(0.004950156837581592745389973960217444687524,
        -0.004899838305155226382584756154100963570500),
      C(0.005100176864319675957314822982399286703798,
        0.005099823128319785355949825238269336481254),
      C(0.4244534840871830045021143490355372016428,
        0.002820278933186814021399602648373095266538),
      C(-0.1021340733271046543881236523269967674156,
        -0.00001045696456072005761498961861088944159916),
      C(-0.01000200120119206748855061636187197886859,
        0.9805885888237419500266621041508714123763e-8),
      C(0.001000002000012000023960527532953151819595,
        -0.9800058800588007290937355024646722133204e-11),
      C(0.4244549085628511778373438768121222815752,
        0.002935393851311701428647152230552122898291),
      C(-0.1021340732357117208743299813648493928105,
        -0.00001088377943049851799938998805451564893540),
      C(-0.01000200120119126652710792390331206563616,
        0.1020612612857282306892368985525393707486e-7),
      C(0.1000000000007333333333344266666666664457e-5,
        0.2000000000001333333333323199999999978819e-5),
      C(0.1999999999994666666666675199999999990248e-5,
        0),
      C(0.3013403889237919660346644392864226952119,
        0),
      C(0.02503136792640367194699495234782353186858,
        0),
      C(0.002500031251171948248596912483183760683918,
        0),
      C(0,0.004900078433419939164774792850907128053308),
      C(0,-0.005100088434920074173454208832365950009419),
      C(0,0.2000000000005333333333341866666666676419e-5),
      C(0,-48.16001211429122974789822893525016528191),
      C(0,0.4627407029504443513654142715903005954668e174),
      C(0,-Inf),
      C(0,0),
      C(-0,0),
      C(0, Inf),
      C(0, -Inf),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(NaN, 0),
      C(0, NaN),
      C(NaN, NaN),
      C(NaN, NaN),
      C(0.01282473148489433743567240624939698290584,
        -0.2105957276516618621447832572909153498104e-7),
      C(0.01219875253423634378984109995893708152885,
        -0.1813040560401824664088425926165834355953e-7),
      C(0.1020408163265306334945473399689037886997e-7,
        -0.1041232819658476285651490827866174985330e-25),
      C(0.9803921568627452865036825956835185367356e-8,
        -0.9227220299884665067601095648451913375754e-26),
      C(0.5000000000000000002500000000000000003750e-9,
        -0.1200000000000000001800000188712838420241e-29),
      C(5.00000000000000000000025000000000000000000003e-12,
        -1.20000000000000000000018000000000000000000004e-36),
      C(5.00000000000000000000000002500000000000000000e-14,
        -1.20000000000000000000000001800000000000000000e-42),
      C(5e-301, 0)
    };
    TST(Dawson, 1e-20);
  }
  printf("#####################################\n");
  printf("SUCCESS (max relative error = %g)\n", errmax_all);
}

#endif

#endif

//end file: faddeeva_mit.h


#endif /* XFIELDS_FADDEEVA_H */


// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2023.                   //
// ########################################### //

#ifndef XFIELDS_BIGAUSSIAN_H
#define XFIELDS_BIGAUSSIAN_H


// for quick test with gcc
//#include "constants.h" //only_for_context none
//#include "faddeeva.h" //only_for_context none
//#include "complex_error_function.h" //only_for_context none
//#include "compute_gx_gy.h" //only_for_context none

//from file: compute_gx_gy.h

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_COMPUTE_GX_GY
#define XFIELDS_COMPUTE_GX_GY

 static inline void compute_Gx_Gy(
        const double x,
        const double y,
        const double sigma_x,
        const double sigma_y,
        const double min_sigma_diff,
        const double Ex,
        const double Ey,
        double* Gx_ptr,
        double* Gy_ptr) {

    double Gx, Gy;

    if (fabs(sigma_x-sigma_y) < min_sigma_diff) {
        const double sigma = 0.5 * (sigma_x+sigma_y);
        if ((x*x + y*y) < 1e-14) {
            Gx = 1./(8 * PI * EPSILON_0 * sigma * sigma);
            Gy = Gx;
        }
	    else {
            Gx = 1/(2.*(x*x+y*y))*(y*Ey-x*Ex+1./(2*PI*EPSILON_0*sigma*sigma)
                    *x*x*exp(-(x*x+y*y)/(2.*sigma*sigma)));
            Gy = 1./(2*(x*x+y*y))*(x*Ex-y*Ey+1./(2*PI*EPSILON_0*sigma*sigma)
                    *y*y*exp(-(x*x+y*y)/(2.*sigma*sigma)));
	    }
    }
    else {
        const double Sig_11 = sigma_x*sigma_x;
        const double Sig_33 = sigma_y*sigma_y;

        Gx = -1./(2*(Sig_11-Sig_33))*(x*Ex+y*Ey+1./(2*PI*EPSILON_0)
                *(sigma_y/sigma_x*exp(-x*x/(2*Sig_11)-y*y/(2*Sig_33))-1.));
        Gy = 1./(2*(Sig_11-Sig_33))*(x*Ex+y*Ey+1./(2*PI*EPSILON_0)*
                (sigma_x/sigma_y*exp(-x*x/(2*Sig_11)-y*y/(2*Sig_33))-1.));

    }

    *Gx_ptr = Gx;
    *Gy_ptr = Gy;
}

#endif //XFIELDS_COMPUTE_GX_GY

//end file: compute_gx_gy.h


 static inline
void get_charge_density(const double x,
                      const double y,
                      const double sigma_x,
                      const double sigma_y,
                      double* rho)
{

  // this is a PDF
  double factor = 1 / (2*PI*sigma_x*sigma_y);
  double exp_x = exp(-x*x/(2*sigma_x*sigma_x));
  double exp_y = exp(-y*y/(2*sigma_y*sigma_y));
  *rho = factor * exp_x * exp_y;  // [m^-2]
}

 static inline
void get_transv_field_gauss_round(
    double sigma, double Delta_x, double Delta_y,
    double x, double y,
    double* Ex,
    double* Ey)
{
  double r2, temp;

  r2 = (x-Delta_x)*(x-Delta_x)+(y-Delta_y)*(y-Delta_y);
  if (r2<1e-20) temp = sqrt(r2)/(2.*PI*EPSILON_0*sigma); //linearised
  else          temp = (1-exp(-0.5*r2/(sigma*sigma)))/(2.*PI*EPSILON_0*r2);

  (*Ex) = temp * (x-Delta_x);
  (*Ey) = temp * (y-Delta_y);
}

 static inline
void get_transv_field_gauss_ellip(
        double sigma_x,  double sigma_y,
        double Delta_x,  double Delta_y,
        const double x,
	const double y,
        double* Ex_out,
        double* Ey_out)
{
  double sigmax = sigma_x;
  double sigmay = sigma_y;

  // I always go to the first quadrant and then apply the signs a posteriori
  // numerically more stable (see http://inspirehep.net/record/316705/files/slac-pub-5582.pdf)

  double abx = fabs(x - Delta_x);
  double aby = fabs(y - Delta_y);

  double S, factBE, Ex, Ey;
  double etaBE_re, etaBE_im, zetaBE_re, zetaBE_im;
  double w_etaBE_re, w_etaBE_im, w_zetaBE_re, w_zetaBE_im;
  double expBE;


  if (sigmax>sigmay){
    S = sqrt(2.*(sigmax*sigmax-sigmay*sigmay));
    factBE = 1./(2.*EPSILON_0*SQRT_PI*S);

    etaBE_re = sigmay/sigmax*abx;
    etaBE_im = sigmax/sigmay*aby;

    zetaBE_re = abx;
    zetaBE_im = aby;

    //w_zetaBE_re, w_zetaBE_im = wfun(zetaBE_re/S, zetaBE_im/S)
    faddeeva_w(zetaBE_re/S, zetaBE_im/S , &(w_zetaBE_re), &(w_zetaBE_im));

    //w_etaBE_re, w_etaBE_im = wfun(etaBE_re/S, etaBE_im/S)
    faddeeva_w(etaBE_re/S, etaBE_im/S , &(w_etaBE_re), &(w_etaBE_im));

    expBE = exp(-abx*abx/(2*sigmax*sigmax)-aby*aby/(2*sigmay*sigmay));

    Ex = factBE*(w_zetaBE_im - w_etaBE_im*expBE);
    Ey = factBE*(w_zetaBE_re - w_etaBE_re*expBE);

  }
  else if (sigmax<sigmay){
    S = sqrt(2.*(sigmay*sigmay-sigmax*sigmax));
    factBE = 1./(2.*EPSILON_0*SQRT_PI*S);

    etaBE_re = sigmax/sigmay*aby;
    etaBE_im = sigmay/sigmax*abx;

    zetaBE_re = aby;
    zetaBE_im = abx;

    //w_zetaBE_re, w_zetaBE_im = wfun(zetaBE_re/S, zetaBE_im/S)
    faddeeva_w(zetaBE_re/S, zetaBE_im/S , &(w_zetaBE_re), &(w_zetaBE_im));

    //w_etaBE_re, w_etaBE_im = wfun(etaBE_re/S, etaBE_im/S)
    faddeeva_w(etaBE_re/S, etaBE_im/S , &(w_etaBE_re), &(w_etaBE_im));

    expBE = exp(-aby*aby/(2*sigmay*sigmay)-abx*abx/(2*sigmax*sigmax));

    Ey = factBE*(w_zetaBE_im - w_etaBE_im*expBE);
    Ex = factBE*(w_zetaBE_re - w_etaBE_re*expBE);

  }
  else{
    Ex = Ey = 0.;
  }

  if((x - Delta_x)<0) Ex=-Ex;
  if((y - Delta_y)<0) Ey=-Ey;

  (*Ex_out) = Ex;
  (*Ey_out) = Ey;
}

 static inline
void get_Ex_Ey_gauss(
             const double  x,
             const double  y,
             const double  sigma_x,
             const double  sigma_y,
             const double  min_sigma_diff,
             double* Ex_ptr,
             double* Ey_ptr){

        // round beam
	if (fabs(sigma_x-sigma_y)< min_sigma_diff){
	    double sigma = 0.5*(sigma_x+sigma_y);
	    	get_transv_field_gauss_round(sigma, 0., 0., x, y, Ex_ptr, Ey_ptr);
	}

        // elliptical beam
	else{
	    get_transv_field_gauss_ellip(
	            sigma_x, sigma_y, 0., 0., x, y, Ex_ptr, Ey_ptr);

	}
}

#endif // XFIELDS_BIGAUSSIAN_H

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_BEAMBEAM3D_TRASPORT_SIGMAS_H
#define XFIELDS_BEAMBEAM3D_TRASPORT_SIGMAS_H

#if !defined(mysign)
    #define mysign(a) (((a) >= 0) - ((a) < 0))
#endif

 static inline
void Sigmas_propagate(
        double const Sig_11_0,
        double const Sig_12_0,
        double const Sig_13_0,
        double const Sig_14_0,
        double const Sig_22_0,
        double const Sig_23_0,
        double const Sig_24_0,
        double const Sig_33_0,
        double const Sig_34_0,
        double const Sig_44_0,
        double const S,
        double const threshold_singular,
        int64_t const handle_singularities,
        double* Sig_11_hat_ptr,
        double* Sig_33_hat_ptr,
        double* costheta_ptr,
        double* sintheta_ptr,
        double* dS_Sig_11_hat_ptr,
        double* dS_Sig_33_hat_ptr,
        double* dS_costheta_ptr,
        double* dS_sintheta_ptr)
{

    // Propagate sigma matrix
    double const Sig_11 = Sig_11_0 + 2.*Sig_12_0*S+Sig_22_0*S*S;
    double const Sig_33 = Sig_33_0 + 2.*Sig_34_0*S+Sig_44_0*S*S;
    double const Sig_13 = Sig_13_0 + (Sig_14_0+Sig_23_0)*S+Sig_24_0*S*S;

    double const Sig_12 = Sig_12_0 + Sig_22_0*S;
    double const Sig_14 = Sig_14_0 + Sig_24_0*S;
    double const Sig_22 = Sig_22_0 + 0.*S;
    double const Sig_23 = Sig_23_0 + Sig_24_0*S;
    double const Sig_24 = Sig_24_0 + 0.*S;
    double const Sig_34 = Sig_34_0 + Sig_44_0*S;
    double const Sig_44 = Sig_44_0 + 0.*S;

    double const R = Sig_11-Sig_33;
    double const W = Sig_11+Sig_33;
    double const T = R*R+4*Sig_13*Sig_13;

    //evaluate derivatives
    double const dS_R = 2.*(Sig_12_0-Sig_34_0)+2*S*(Sig_22_0-Sig_44_0);
    double const dS_W = 2.*(Sig_12_0+Sig_34_0)+2*S*(Sig_22_0+Sig_44_0);
    double const dS_Sig_13 = Sig_14_0 + Sig_23_0 + 2*Sig_24_0*S;
    double const dS_T = 2*R*dS_R+8.*Sig_13*dS_Sig_13;

    double Sig_11_hat, Sig_33_hat, costheta, sintheta, dS_Sig_11_hat,
           dS_Sig_33_hat, dS_costheta, dS_sintheta, cos2theta, dS_cos2theta;

    double const signR = mysign(R);


    if (T<threshold_singular && handle_singularities){
        double const a = Sig_12-Sig_34;
        double const b = Sig_22-Sig_44;
        double const c = Sig_14+Sig_23;
        double const d = Sig_24;

        double sqrt_a2_c2 = sqrt(a*a+c*c);

        if (sqrt_a2_c2*sqrt_a2_c2*sqrt_a2_c2 < threshold_singular){
        //equivalent to: if np.abs(c)<threshold_singular and np.abs(a)<threshold_singular:

            if (fabs(d)> threshold_singular){
                cos2theta = fabs(b)/sqrt(b*b+4*d*d);
                }
            else{
                cos2theta = 1.;
                } // Decoupled beam

            costheta = sqrt(0.5*(1.+cos2theta));
            sintheta = mysign(b)*mysign(d)*sqrt(0.5*(1.-cos2theta));

            dS_costheta = 0.;
            dS_sintheta = 0.;

            Sig_11_hat = 0.5*W;
            Sig_33_hat = 0.5*W;

            dS_Sig_11_hat = 0.5*dS_W;
            dS_Sig_33_hat = 0.5*dS_W;
        }
        else{
            sqrt_a2_c2 = sqrt(a*a+c*c); //repeated?
            cos2theta = fabs(2.*a)/(2*sqrt_a2_c2);
            costheta = sqrt(0.5*(1.+cos2theta));
            sintheta = mysign(a)*mysign(c)*sqrt(0.5*(1.-cos2theta));

            dS_cos2theta = mysign(a)*(0.5*b/sqrt_a2_c2-a*(a*b+2.*c*d)/(2.*sqrt_a2_c2*sqrt_a2_c2*sqrt_a2_c2));

            dS_costheta = 1./(4.*costheta)*dS_cos2theta;
            if (fabs(sintheta)>threshold_singular){
            //equivalent to: if np.abs(c)>threshold_singular:
                dS_sintheta = -1./(4.*sintheta)*dS_cos2theta;
            }
            else{
                dS_sintheta = d/(2.*a);
            }

            Sig_11_hat = 0.5*W;
            Sig_33_hat = 0.5*W;

            dS_Sig_11_hat = 0.5*dS_W + mysign(a)*sqrt_a2_c2;
            dS_Sig_33_hat = 0.5*dS_W - mysign(a)*sqrt_a2_c2;
        }
    }
    else{
        double const sqrtT = sqrt(T);
        cos2theta = signR*R/sqrtT;
        costheta = sqrt(0.5*(1.+cos2theta));
        sintheta = signR*mysign(Sig_13)*sqrt(0.5*(1.-cos2theta));

        //in sixtrack this line seems to be different
        // sintheta = -mysign((Sig_11-Sig_33))*np.sqrt(0.5*(1.-cos2theta))
       Sig_11_hat = 0.5*(W+signR*sqrtT);
       Sig_33_hat = 0.5*(W-signR*sqrtT);

        dS_cos2theta = signR*(dS_R/sqrtT - R/(2*sqrtT*sqrtT*sqrtT)*dS_T);
        dS_costheta = 1./(4.*costheta)*dS_cos2theta;

        if (fabs(sintheta)<threshold_singular && handle_singularities){
        //equivalent to to np.abs(Sig_13)<threshold_singular
            dS_sintheta = (Sig_14+Sig_23)/R;
        }
        else{
            dS_sintheta = -1./(4.*sintheta)*dS_cos2theta;
        }

        dS_Sig_11_hat = 0.5*(dS_W + signR*0.5/sqrtT*dS_T);
        dS_Sig_33_hat = 0.5*(dS_W - signR*0.5/sqrtT*dS_T);
    }

    *Sig_11_hat_ptr = Sig_11_hat;
    *Sig_33_hat_ptr = Sig_33_hat;
    *costheta_ptr = costheta;
    *sintheta_ptr = sintheta;
    *dS_Sig_11_hat_ptr = dS_Sig_11_hat;
    *dS_Sig_33_hat_ptr = dS_Sig_33_hat;
    *dS_costheta_ptr = dS_costheta;
    *dS_sintheta_ptr = dS_sintheta;

}

#endif

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_BEAMBEAM3D_REF_FRAME_CHANGES_H
#define XFIELDS_BEAMBEAM3D_REF_FRAME_CHANGES_H


 static inline
void boost_coordinates(
        double const sphi,
        double const cphi,
        double const tphi,
        double const salpha,
        double const calpha,
        double* x_star,
        double* px_star,
        double* y_star,
        double* py_star,
        double* sigma_star,
        double* delta_star){


    double const x = *x_star;
    double const px = *px_star;
    double const y = *y_star;
    double const py = *py_star ;
    double const sigma = *sigma_star;
    double const delta = *delta_star ;

    double const h = delta + 1. - sqrt((1.+delta)*(1.+delta)-px*px-py*py);


    double const px_st = px/cphi-h*calpha*tphi/cphi;
    double const py_st = py/cphi-h*salpha*tphi/cphi;
    double const delta_st = delta -px*calpha*tphi-py*salpha*tphi+h*tphi*tphi;

    double const pz_st =
        sqrt((1.+delta_st)*(1.+delta_st)-px_st*px_st-py_st*py_st);

    double const hx_st = px_st/pz_st;
    double const hy_st = py_st/pz_st;
    double const hsigma_st = 1.-(delta_st+1)/pz_st;

    double const L11 = 1.+hx_st*calpha*sphi;
    double const L12 = hx_st*salpha*sphi;
    double const L13 = calpha*tphi;

    double const L21 = hy_st*calpha*sphi;
    double const L22 = 1.+hy_st*salpha*sphi;
    double const L23 = salpha*tphi;

    double const L31 = hsigma_st*calpha*sphi;
    double const L32 = hsigma_st*salpha*sphi;
    double const L33 = 1./cphi;

    double const x_st = L11*x + L12*y + L13*sigma;
    double const y_st = L21*x + L22*y + L23*sigma;
    double const sigma_st = L31*x + L32*y + L33*sigma;

    *x_star = x_st;
    *px_star = px_st;
    *y_star = y_st;
    *py_star = py_st;
    *sigma_star = sigma_st;
    *delta_star = delta_st;

}

 static inline
void boost_coordinates_inv(
        double const sphi,
        double const cphi,
        double const tphi,
        double const salpha,
        double const calpha,
        double* x,
        double* px,
        double* y,
        double* py,
        double* sigma,
        double* delta){

    double const x_st = *x;
    double const px_st = *px;
    double const y_st = *y;
    double const py_st = *py ;
    double const sigma_st = *sigma;
    double const delta_st = *delta ;

    double const pz_st = sqrt((1.+delta_st)*(1.+delta_st)-px_st*px_st-py_st*py_st);
    double const hx_st = px_st/pz_st;
    double const hy_st = py_st/pz_st;
    double const hsigma_st = 1.-(delta_st+1)/pz_st;

    double const Det_L =
        1./cphi + (hx_st*calpha + hy_st*salpha-hsigma_st*sphi)*tphi;

    double const Linv_11 =
        (1./cphi + salpha*tphi*(hy_st-hsigma_st*salpha*sphi))/Det_L;

    double const Linv_12 =
        (salpha*tphi*(hsigma_st*calpha*sphi-hx_st))/Det_L;

    double const Linv_13 =
        -tphi*(calpha - hx_st*salpha*salpha*sphi + hy_st*calpha*salpha*sphi)/Det_L;

    double const Linv_21 =
        (calpha*tphi*(-hy_st + hsigma_st*salpha*sphi))/Det_L;

    double const Linv_22 =
        (1./cphi + calpha*tphi*(hx_st-hsigma_st*calpha*sphi))/Det_L;

    double const Linv_23 =
        -tphi*(salpha - hy_st*calpha*calpha*sphi + hx_st*calpha*salpha*sphi)/Det_L;

    double const Linv_31 = -hsigma_st*calpha*sphi/Det_L;
    double const Linv_32 = -hsigma_st*salpha*sphi/Det_L;
    double const Linv_33 = (1. + hx_st*calpha*sphi + hy_st*salpha*sphi)/Det_L;

    double const x_i = Linv_11*x_st + Linv_12*y_st + Linv_13*sigma_st;
    double const y_i = Linv_21*x_st + Linv_22*y_st + Linv_23*sigma_st;
    double const sigma_i = Linv_31*x_st + Linv_32*y_st + Linv_33*sigma_st;

    double const h = (delta_st+1.-pz_st)*cphi*cphi;

    double const px_i = px_st*cphi+h*calpha*tphi;
    double const py_i = py_st*cphi+h*salpha*tphi;

    double const delta_i = delta_st + px_i*calpha*tphi + py_i*salpha*tphi - h*tphi*tphi;


    *x = x_i;
    *px = px_i;
    *y = y_i;
    *py = py_i;
    *sigma = sigma_i;
    *delta = delta_i;

}

 static inline
void change_ref_frame_coordinates(
        double* x, double* px, double* y, double* py, double* zeta, double* pzeta,
        double const shift_x, double const shift_px,
        double const shift_y, double const shift_py,
        double const shift_zeta, double const shift_pzeta,
        double const sin_phi, double const cos_phi, double const tan_phi,
        double const sin_alpha, double const cos_alpha){

    // Change reference frame
    double x_star =     *x     - shift_x;
    double px_star =    *px    - shift_px;
    double y_star =     *y     - shift_y;
    double py_star =    *py    - shift_py;
    double zeta_star =  *zeta  - shift_zeta;
    double pzeta_star = *pzeta - shift_pzeta;

    // Boost coordinates of the weak beam
    boost_coordinates(
        sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha,
        &x_star, &px_star, &y_star, &py_star,
        &zeta_star, &pzeta_star);

    *x = x_star;
    *px = px_star;
    *y = y_star;
    *py = py_star;
    *zeta = zeta_star;
    *pzeta = pzeta_star;
    }

 static inline
void change_back_ref_frame_and_subtract_dipolar_coordinates(
        double* x, double* px,
        double* y, double* py,
        double* zeta, double* pzeta,
        double const shift_x, double const shift_px,
        double const shift_y, double const shift_py,
        double const shift_zeta, double const shift_pzeta,
        double const post_subtract_x, double const post_subtract_px,
        double const post_subtract_y, double const post_subtract_py,
        double const post_subtract_zeta, double const post_subtract_pzeta,
        double const sin_phi, double const cos_phi, double const tan_phi,
        double const sin_alpha, double const cos_alpha){

    // Inverse boost on the coordinates of the weak beam
    boost_coordinates_inv(
        sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha,
        x, px, y, py, zeta, pzeta);

    // Go back to original reference frame and remove dipolar effect
    *x =     *x     + shift_x     - post_subtract_x;
    *px =    *px    + shift_px    - post_subtract_px;
    *y =     *y     + shift_y     - post_subtract_y;
    *py =    *py    + shift_py    - post_subtract_py;
    *zeta =  *zeta  + shift_zeta  - post_subtract_zeta;
    *pzeta = *pzeta + shift_pzeta - post_subtract_pzeta;

    }

#endif

#ifndef XFIELDS_BEAMSTRAHLUNG_SPECTRUM_H
#define XFIELDS_BEAMSTRAHLUNG_SPECTRUM_H

#define SQRT3 1.732050807568877
#define ALPHA_EM 0.0072973525693


 static inline
int beamstrahlung_0(LocalParticle *part,
             double energy,     // [eV] primary electron energy
             double dz,         // [m] z slice half width
             double rho_inv,    // [1/m] inverse local bending radius, changes after each photon emission
             double* e_photon,  // [GeV] emitted BS photon energy
             double* ecrit      // [GeV] critical energy of emitted BS photon
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/guinea_pig.c#L1894
    and
    K. Yokoya: A COMPUTER SIMULATION CODE FOR THE BEAM-BEAM INTERACTION IN LINEAR COLLIDERS
    https://inis.iaea.org/collection/NCLCollectionStore/_Public/18/033/18033162.pdf?r=1
    ----
    return 0: no photon
    return 1: emit 1 photon, energy stored in e_photon
    */

    // constants for approximating beamstrahlung spectrum
    const double g1_a[5] = {1.0, -0.8432885317, 0.1835132767, -0.0527949659, 0.0156489316};
    const double g2_a[5] = {0.4999456517, -0.5853467515, 0.3657833336, -0.0695055284, 0.019180386};
    const double g1_b[7] = {2.066603927, -0.5718025331, 0.04243170587, -0.9691386396, 5.651947051, -0.6903991322, 1.0};
    const double g2_b[7] = {1.8852203645, -0.5176616313, 0.03812218492, -0.49158806, 6.1800441958, -0.6524469236, 1.0};
    const double g1_c[4] = {1.0174394594, 0.5831679349, 0.9949036186, 1.0};
    const double g2_c[4] = {0.2847316689, 0.58306846, 0.3915531539, 1.0};

    double c1 = 1.5*HBAR_GEVS / pow(MELECTRON_GEV, 3.0) * C_LIGHT;  // [c^4/Gev^2] 2.22e-6 = 1.5*hbar*cst.c/e0**3

    double xcrit = c1 * pow(energy*1e-9, 2.0) * rho_inv; // [1] ecrit/E magnitude of quantum correction, in guineapig: xcrit (C) = xi (doc) = upsbar (C++)
    (*ecrit) = xcrit * energy*1e-9; // [GeV]
    //double omega_crit = (*ecrit)/HBAR_GEVS;  // [1/s] = 1.5 * gamma**3 * cst.c / rho
    //double upsilon = 2.0/3.0 * (*ecrit) / (energy*1e-9);  // [1] beamstrahlung parameter for single macropart
    double p0 = 25.4 * energy*1e-9 * dz * rho_inv;  // [1]  Fr * dz, specific for 1 macropart
 
    // eliminate region A in p0*g-v plane (=normalize with p0 = reject 1-p0 (p0<1) fraction of cases = y axis of p0*g-v plane is now spanning 0--p0=1
    if (RandomUniform_generate(part) > p0){return 0;}

    // 2 random numbers to calculate g(v, xcrit)
    double p = RandomUniform_generate(part);  // if this is 1, then it corresponds to p0 on original p0*g-v plane
    double v;
    while((v=RandomUniform_generate(part))==0); // draw a nonzero random number, variable of the beamstrahlung spectrum
    double v2 = v*v;
    double v3 = v2*v;
    double y = v3 / (1.0 - v3);
    double denom = 1.0 - ( 1.0 - xcrit ) * v3;

    // calculate beamstrahlung spectrum coefficients, depending the value of y
    double g1, g2;
    if (y <= 1.54){
        g1 = pow(y, -2.0/3.0) * (g1_a[0] + g1_a[1]*pow(y, 2.0/3.0) + g1_a[2]*pow(y, 2.0) + g1_a[3]*pow(y, 10.0/3.0) + g1_a[4]*pow(y, 4.0));
        g2 = pow(y, -2.0/3.0) * (g2_a[0] + g2_a[1]*pow(y, 4.0/3.0) + g2_a[2]*pow(y, 2.0) + g2_a[3]*pow(y, 10.0/3.0) + g2_a[4]*pow(y, 4.0));
    }else if (y <= 4.48){
        g1 = ( g1_b[0] + g1_b[1]*y + g1_b[2]*pow(y, 2.0) ) / ( g1_b[3] + g1_b[4]*y + g1_b[5]*pow(y, 2.0) + g1_b[6]*pow(y, 3.0) );
        g2 = ( g2_b[0] + g2_b[1]*y + g2_b[2]*pow(y, 2.0) ) / ( g2_b[3] + g2_b[4]*y + g2_b[5]*pow(y, 2.0) + g2_b[6]*pow(y, 3.0) );
    }else if (y <= 165.0){
        g1 = exp(-y)/sqrt(y) * ( g1_c[0] + g1_c[1]*y ) / ( g1_c[2] + g1_c[3]*y );
        g2 = exp(-y)/sqrt(y) * ( g2_c[0] + g2_c[1]*y ) / ( g2_c[2] + g2_c[3]*y );
    }else{
        // no radiation, y too high
        return 0;
    }
        
    // g normalized (g(v=0, xcrit)=1), g(v, xcrit) gives the no. of emitted photons in a given delta v interval
    double g = v2 / pow(denom, 2.0) * ( g1 + ( pow(xcrit, 2.0) * pow(y, 2.0) ) / ( 1.0 + xcrit * y ) * g2 );  // g (w.o. normalization above) splits the unit rectangle p0*g-v to A,B,C regions
   
    // region C (emit photon) if p<p0*g, region B (no photon) if p>=p0*g, p0=1 bc. of normalization above
    if (p<g){
        (*e_photon) = (*ecrit) * v3 / denom;
        return 1;
    }else{
        (*e_photon) = 0.0;
        return 0;
    }
}


 static inline
double beamstrahlung_avg(LocalParticle *part, BeamBeamBiGaussian3DRecordData beamstrahlung_record, RecordIndex beamstrahlung_table_index, BeamstrahlungTableData beamstrahlung_table,
        const double n_bb, // [1] strong slice bunch intensity
        const double sigma_x, const double sigma_y, const double sigma_z  // [m] unboosted strong slice RMS
){
    /*
    Based on:
    K. Yokoya: Beam-Beam Phenomena In Linear Colliders
    https://doi.org/10.1007/3-540-55250-2_37
    ----
    n_bb and sigma_z are scaled with the (same) slice weights
    n_avg ~ n_bb -> 1/num_slices less photons per mp in 1 slice
    delta_avg ~ n_bb^2/sigma_z -> 1/num_slices less rel. E loss per mp in 1 slice
    e_photon_avg = delta_avg / n_avg -> avg. photon energy is the same in 1 slice
    */

    // beam properties
    const double m0             = LocalParticle_get_mass0(part); // [eV/c] beam particle mass
    const double initial_energy = LocalParticle_get_energy0(part) + LocalParticle_get_ptau(part)*LocalParticle_get_p0c(part); // [eV]
    const double gamma          = initial_energy / m0; // [1] 

    // constants
    const double r  = pow(QELEM, 2.0)/(4.0* PI * EPSILON_0 * MELECTRON_KG * pow(C_LIGHT, 2.0));      // [m] electron radius
    const double c1 = 2.59 * ( 5.0/ 6.0) * (    r*r) / REDUCED_COMPTON_WAVELENGTH_ELECTRON;          // [m]
    const double c2 =  1.2 * (25.0/36.0) * (r*r*r*r) / REDUCED_COMPTON_WAVELENGTH_ELECTRON * 137.0;  // [m^3]

    // compute averaged quantities
    double n_avg        = c1 * n_bb/(sigma_x + sigma_y);  // [1] avg. number of emitted photons from 1 macroparticle in one slice collision
    double delta_avg    = c2 * gamma/sigma_z * (n_bb/(sigma_x + sigma_y))*(n_bb/(sigma_x + sigma_y));  // [1] avg. rel. E loss for 1 macroparticle in one slice collision
    double U_BS         = delta_avg*initial_energy;  // [eV] avg. energy loss per macropart in one slice collision
    double u_avg        = delta_avg/n_avg;           // [1] avg. rel. photon energy normalized to initial electron energy
    double e_photon_avg = u_avg*initial_energy;      // [eV] avg. photon energy
    LocalParticle_add_to_energy(part, -U_BS, 0);
    double energy_loss = -U_BS;  // <0

    if (beamstrahlung_record){
        // Get a slot in the record (this is thread safe)
        int64_t i_slot = RecordIndex_get_slot(beamstrahlung_table_index);
        // The returned slot id is negative if record is NULL or if record is full
        if (i_slot>=0){
            BeamstrahlungTableData_set_particle_id(   beamstrahlung_table, i_slot, LocalParticle_get_particle_id(part));
            BeamstrahlungTableData_set_photon_energy( beamstrahlung_table, i_slot, e_photon_avg);
            BeamstrahlungTableData_set_delta_avg(     beamstrahlung_table, i_slot, delta_avg);
            BeamstrahlungTableData_set_n_avg(         beamstrahlung_table, i_slot, n_avg);
            BeamstrahlungTableData_set_primary_energy(beamstrahlung_table, i_slot, initial_energy);
        }
    }

    return energy_loss;
}


 static inline
double beamstrahlung(LocalParticle *part, BeamBeamBiGaussian3DRecordData beamstrahlung_record, RecordIndex beamstrahlung_table_index, BeamstrahlungTableData beamstrahlung_table,
     	double Fr,  // [1] radial force sqrt[(px' - px)^2 + (py' - py)^2]/Dt, Dt=1
	double dz   // [m] z slice half width: step between 2 slices ((z_max - z_min) / 2)
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/guinea_pig.c#L1962
    */

    // beam properties
    const double m0       = LocalParticle_get_mass0(part); // particle mass [eV/c]
    double initial_energy = LocalParticle_get_energy0(part) + LocalParticle_get_ptau(part)*LocalParticle_get_p0c(part); // [eV]
    double energy         = initial_energy;  // [eV]
    double gamma          = energy / m0;     // [1]

    // single macroparticle trajectory 
    double rho_inv  = Fr / dz;  // [1/m] macropart inverse bending radius
    double tmp      = 25.4 * energy*1e-9 * dz * rho_inv;  // [1] p0, specific for 1 macropart, 1e-9 to convert [eV] to [GeV]
    int max_photons = (int)(tmp*10.0)+1;  // [1]
    dz /= (double)max_photons;  // photons are emitted uniformly in space along dz (between 2 slice interactions)

    // BS photon counter and BS photon energy buffer
    int j = 0;
    double e_photon_array[1000];
    for (int i=0; i<max_photons; i++){
   
        double e_photon, ecrit;  // [GeV] BS photon energy and critical energy
        if (beamstrahlung_0(part, energy, dz, rho_inv, &e_photon, &ecrit)){  // see if quantum photon can be emitted
            e_photon_array[j] = e_photon;  // [GeV]
           
            if (beamstrahlung_record){
                // Get a slot in the record (this is thread safe)
                int64_t i_slot = RecordIndex_get_slot(beamstrahlung_table_index);
                // The returned slot id is negative if record is NULL or if record is full
                if (i_slot>=0){
                    BeamstrahlungTableData_set_particle_id(           beamstrahlung_table, i_slot, LocalParticle_get_particle_id(part));
                    BeamstrahlungTableData_set_photon_id(             beamstrahlung_table, i_slot, j);
                    BeamstrahlungTableData_set_photon_energy(         beamstrahlung_table, i_slot, e_photon*1e9);
                    BeamstrahlungTableData_set_photon_critical_energy(beamstrahlung_table, i_slot, ecrit*1e9);
                    BeamstrahlungTableData_set_primary_energy(        beamstrahlung_table, i_slot, energy);
                    BeamstrahlungTableData_set_rho_inv(               beamstrahlung_table, i_slot, rho_inv);
                }
            }

            // update bending radius, primary macropart energy and gamma
            rho_inv *= energy/(energy - e_photon*1e9);
            energy  -= e_photon*1e9;
            gamma   *= (energy - e_photon*1e9)/energy;

            // some error handling
            if (e_photon_array[j]<=0.0){
                printf("photon emitted with negative energy: E_photon=%g [eV], E_macropart=%g [eV], photon ID: %d, max_photons: %d\n", e_photon*1e9, energy, j, max_photons);
            }

            // increment photon counter
            j++;

            // break loop and flag macroparticle as dead
            if (j>=1000){
                printf("[%d] too many photons produced by one particle (photon ID: %d), Fr: %.12e, dz: %.12e\n", (int)part->ipart, j, Fr, dz);
                //exit(-1);  // doesnt work on GPU
                LocalParticle_set_state(part, XF_TOO_MANY_PHOTONS); // used to flag this kind of loss
                break;
            }

        }
    }

    // update primary macroparticle energy
    if (energy == 0.0){
        LocalParticle_set_state(part, XT_LOST_ALL_E_IN_SYNRAD); // used to flag this kind of loss
    }else{
       LocalParticle_add_to_energy(part, energy-initial_energy, 0);
    }
    double energy_loss = energy - initial_energy;  // <0

    return energy_loss;
}

#endif /* XFIELDS_BEAMSTRAHLUNG_SPECTRUM_H */

#ifndef XFIELDS_BHABHA_SPECTRUM_H
#define XFIELDS_BHABHA_SPECTRUM_H

/************************************************************************************/
/* Subroutines for the generation of the equivalent virtual photons for one primary */
/* Adapted from GUINEA-PIG                                                          */
/************************************************************************************/

 static inline
double rndm_sincos(LocalParticle *part, double *theta)
{
    const double twopi=2.0*PI;
    double r1;
    r1 = RandomUniform_generate(part);
    *theta = cos(twopi*r1);
    if (r1 > 0.5)
        return sqrt(1.0- *theta * *theta);
    else
        return -sqrt(1.0- *theta * *theta);
}


 static inline
float requiv(LocalParticle *part, const double e_primary, const double compt_x_min){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/guinea_pig.c#L1205
    ----
    Returns the number of equivalent virtual (macro)photons for a single primary macroparticle of the beam.
    */
    const double emass2=MELECTRON_GEV*MELECTRON_GEV;
    double lnxmin, s4, xmin, lns4, r_photons, n_photons;

    s4 = e_primary*e_primary;  // [GeV^2] mandelstam s divided by 4: s/4
    xmin = compt_x_min * emass2 / s4;  // [1] virtual photon's energy fraction compared to primary energy

    if (xmin>=1.0) return 0.0;

    lnxmin=-log(xmin);
    lns4 = log(s4 / (MELECTRON_GEV*MELECTRON_GEV));

    r_photons = .00232461*lnxmin*(lnxmin + lns4);  // alpha/pi = 0.00232461

    // account for noninteger photon by randomly emitting n+1 sometimes
    n_photons = (int)floor(r_photons);
    r_photons -= n_photons;
    if(RandomUniform_generate(part) < r_photons) n_photons += 1.0;

    return n_photons;
}


 static inline
void mequiv (LocalParticle *part,
             const double e_primary,    // [GeV] other beam slice energy
             const double compt_x_min,  // [1] scaling factor in the minimum energy cutoff
             double *xmin,              // [1] cutoff x from where to integrate number density
             double *e_photon,          // [GeV] single equivalent virtual photon energy
             double *q2,                // [GeV^2] single equivalent virtual photon virtuality
             double *one_m_x            // [1] 1 - x
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/guinea_pig.c#L1248
    ----
    Sets the energy and virtuality of a single virtual photon.
    */
    const double emass2=MELECTRON_GEV*MELECTRON_GEV;
    double s4, q2max, q2min, lnx, x, lnxmin, lns4;
  
    s4 = e_primary*e_primary;  // [GeV^2] mandelstam s divided by 4: s/4
    *xmin = compt_x_min * emass2 / s4;  // [1] virtual photon's energy fraction compared to primary energy
  
    lnxmin = -log(*xmin);
    lns4 = log(s4 / (MELECTRON_GEV*MELECTRON_GEV));
  
    // set energy fraction and virtuality boundaires
    if(RandomUniform_generate(part) < lnxmin / (lnxmin + lns4)){
        lnx   = -sqrt(RandomUniform_generate(part)) * lnxmin;
        x     = exp(lnx);
        q2min = x*x*emass2;
        q2max = emass2;
    }
    else{
        lnx   = -RandomUniform_generate(part) * lnxmin;
        x     = exp(lnx);
        q2min = emass2;
        q2max = s4;
    }
  
    // set virtual photon energy and virtuality
    if((1.0 + (1.0 - x) * (1.0 - x)) * 0.5 < RandomUniform_generate(part)){
        *e_photon = 0.0;
        *q2  = 0.0;
    }
    else{
        *e_photon = e_primary * x;
        *q2 = q2min * pow(q2max / q2min, RandomUniform_generate(part));
    }
  
    if (*q2 * (1.0 - x) < x*x*emass2) *e_photon = 0.0;
    *one_m_x = 1.0 - x;
  
    return;
  
}

 static inline
double compt_tot(double s  // [GeV^2] center of mass energy of the macroparticle - virtual photon Compton scattering
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L350
    and
    https://doi.org/10.1016/0167-5087(84)90128-5
    ----
    Total Compton cross section.
    */
    const double sig0 = PI*RE*RE;
    double xi, xp, xip, ln, sigc, x_compt;

    x_compt = s/(MELECTRON_GEV*MELECTRON_GEV);
    xi  = 1.0 / x_compt; 
    xp  = 1.0 + x_compt;
    xip = 1.0 / xp;
    ln  = log(xp);

    sigc = 2.0*sig0*xi*((1.0 - xi*(4.0 + 8.0*xi))*ln + 0.5 + 8.0*xi - 0.5*xip*xip);

    return sigc;  // [m^2]
}


 static inline
double compt_diff(double y,              // [1] virtual photon energy fraction compared to primary energy
                  const double x_compt   // [1] normalized cm energy of virtual photon - electron compton scattering
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L364
    ----
    Differential Compton energy spectrum.
    */
    double r, yp;
    yp = 1.0 - y;
    r = y / (x_compt*yp);
    return 1.0/yp + yp - 4.0*r*(1.0 - r);  // [m^2]
}


 static inline
double compt_int(double y,             // [1] virtual photon energy fraction compared to primary energy
                 const double x_compt  // [1] normalized cm energy of virtual photon - electron compton scattering
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L373
    ----
    Integrated Compton energy spectrum.
    */
    double yp, lny, xi;

    yp = 1.0 - y;
    xi = 1.0 / x_compt;
    lny = -log(yp);

    return lny*(1.0-4.0*xi-8.0*xi*xi) + y - y*y*0.5 + 4.0*y*xi + 4.0*y*xi*xi + 4.0/(x_compt*x_compt*yp);  // [m^2]
}


/***********************************************************************************/
/* Subroutines for Compton scattering of the virtual photon and the opposite slice */
/* Adapted from GUINEA-PIG                                                         */
/***********************************************************************************/

 static inline
void equal_newton(
                  double xmin,              // left boundary of domain
                  double xmax,              // right boundary of domain
                  double y,                 // random sample on y axis
                  double *x,                // initial guess for root (inverse CDF sampling)
                  const double x_compt      // [1] normalized cm energy of virtual photon - electron compton scattering

){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L23
    ----
    Uses the Newton-Raphson root finding method for inverse CDF sampling of the given spectrum.
    */
    double eps=1e-6;
    double ytry,xtry;
    int i=0;
    xtry=*x;
    ytry=compt_int(xtry, x_compt);
    while (fabs(ytry-y)>(fabs(ytry)+fabs(y))*eps
           && (xmax-xmin)>eps) {
        i++;
        xtry-=(ytry-y)/compt_diff(xtry, x_compt);
        if ((xtry>=xmax)||(xtry<=xmin)) {
            xtry=0.5*(xmax+xmin);
        }
        ytry=compt_int(xtry, x_compt);
        if(ytry<y) {
            xmin=xtry;
        }
        else {
            xmax=xtry;
        }
    }
    *x=xtry;
}



 static inline
double compt_select(LocalParticle *part,
                    double s  // [GeV^2] center of mass energy of the macroparticle - virtual photon Compton scattering
){
    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L397
    ----
    Given an input CM energy, returns a generated scattered Compton photon energy (y = hbar*omega/E0)
    s: center of mass energy of electron-virtual photon system, s=(x+1)*(m_e*c**2)**2
    returns a randomly sampled scattered photon energy fraction drawn from the Compton energy ditribution
    */
    double cmin, cmax, c, y, ym;
    const double x_compt = s / (MELECTRON_GEV*MELECTRON_GEV);

    //x_compt = x;
    ym = x_compt / (x_compt + 1.0);  // [1] y_max, maximum energy fraction (right edge of domain on x axis of the spectrum)
    cmin = compt_int(0.0, x_compt);  // [m^2] min of range of CDF 
    cmax = compt_int(ym, x_compt);   // [m^2] max of range of CDF

    y = RandomUniform_generate(part);
    c = cmin + (cmax - cmin)*y;  // [m^2] this is the random sample in the inverse CDF
    y *= ym;                     // [1] this is the initial guess on the domain axis 
    equal_newton(0.0, ym, c, &y, x_compt);  // find root: y=sigma^-1(c) i.e. do the inverse CDF sampling
  
    return y;  // [1]
}


 static inline
void compt_do(LocalParticle *part, BeamBeamBiGaussian3DRecordData bhabha_record, RecordIndex bhabha_table_index, BhabhaTableData bhabha_table,
              double e_photon,           // [GeV] single equivalent virtual photon energy before Compton scattering
              const double compt_x_min,  // [1] scaling factor in the minimum energy cutoff
              double q2,                 // [GeV^2] single equivalent virtual photon virtuality
              double vx_photon,          // [1] transverse x momentum component of virtual photon (vx = dx/ds/p0)
              double vy_photon,          // [1] transverse y momentum component of virtual photon (vy = dy/ds/p0)
              double vzeta_photon,       // [1] zeta momentum component of virtual photon
              double wgt,                // [m^-2] int. luminosity
              double *vx,                // [1] normalized momenta of the primary macroparticle
              double *vy,
              double *vzeta, 
              double q0             // [e] charge of primary macroparticle
){

    /*
    Based on:
    GUINEA-PIG
    https://gitlab.cern.ch/clic-software/guinea-pig-legacy/-/blob/master/background.c#L420
    and
    https://doi.org/10.1016/0167-5087(84)90128-5
    and
    https://doi.org/10.1016/0031-9163(63)90351-2
    ----
    Compton scatter one vitrual macrophoton on one macroparticle. Potentially emit a real Bhabha photon. 
    */

    double e_ref = LocalParticle_get_energy0(part)*1e-9;  // [GeV] reference beam energy
    double e_primary = (LocalParticle_get_energy0(part) + LocalParticle_get_ptau(part)*LocalParticle_get_p0c(part))*1e-9;  // [GeV] 
    double beta_ref = LocalParticle_get_beta0(part);         // [1] reference beta
    double part_per_mpart = LocalParticle_get_weight(part);  // [e] num charges represented by 1 macropart

    int n, i;                        // [1]
    double tmp, scal, s, x, y;       // [m^2, m^2, GeV^2, 1, 1]
    double theta_g, theta_e, phi_e;  // [rad] scattering angles
    double e_e_prime, px_e_prime, py_e_prime, pzeta_e_prime, ps_e_prime, pt_e_prime;  // [GeV, 1, 1, 1, 1, 1] scattered primary
    double e_photon_prime, px_photon_prime, py_photon_prime, pzeta_photon_prime;      // [GeV, 1, 1, 1] scattered (real) Compton photon
    double e_loss_primary;            // [GeV] energy lost from one emission
    double e_loss_primary_tot = 0.0;  // [GeV] total energy lost by the macroparticle

    double eps = 0.0;                 // 1e-5 in guinea
    const double compt_scale = 1;       // [1]
    const double compt_emax = 200;      // [GeV] upper cutoff from guineapig
    const double pair_ecut = 0.005;  // [GeV] lower cutoff from guineapig
    double r1, r2;  // [1] uniform random numbers

    if (q2 > MELECTRON_GEV*MELECTRON_GEV) return;  // global upper cut on virtuality; eliminates "constant" part of q2 spectrum i.e. the hadronic virtual photons

    s = 4.0*e_photon*e_primary;  // approximated center of mass energy of primary - photon Compton scattering
    if (q2 > s) return;          // event specific upper cut on virtuality; check against max allowed virtuality to be absorbed in the event

    if (s < compt_x_min * MELECTRON_GEV*MELECTRON_GEV*4.0) return;  // event specific lower cut on x; check against user defined compt_x_min

    tmp = compt_tot(s)*wgt*compt_scale;   // [1] this determines the number of real Compton scattering events
    n = (int)floor(tmp)+1;                // [1] round up e.g. tmp=5.4 will mean n=6 events
    scal = tmp/n;                         // [1] fractional part of event count
    x = s/(MELECTRON_GEV*MELECTRON_GEV);  // [1]

    for (i=0; i<n; i++) {
      y = compt_select(part, s);  // [1] draw compton scattered photon energy

      if (scal > eps){
        double one_m_y = 1 - y;  // + e_photon / e_primary;

        e_e_prime = one_m_y * e_primary;  // + e_photon; neglected. [GeV] scattered electron energy: E_e' = E_e + E_p - E_p' but E_p is negligible compared to other terms
        e_photon_prime = y*e_primary;     // [GeV] scattered photon energy

        // get scattered angle for photon and beam primary
        theta_g = MELECTRON_GEV / e_primary * sqrt((x - (x + 1.0) * y) / y);
        theta_e = theta_g * e_photon_prime / (e_primary - e_photon_prime);  // + e_photon; neglected

        // save computations for tracking: energies below are lost anyways, energies above compt_emax have negligible e loss from bhabha
        if ((e_e_prime < compt_emax) && (e_e_prime > pair_ecut)) {

          // compute scattered primary momenta
          // adjust magnitude
          px_e_prime = *vx * e_e_prime;  // / e_primary;
          py_e_prime = *vy * e_e_prime;  // / e_primary;

          // adjust direction
          pt_e_prime = theta_e * e_e_prime;  // [1] transverse azimuthal momentum
          phi_e = 2.0 * PI * RandomUniform_generate(part);
          px_e_prime  += pt_e_prime * sin(phi_e);
          py_e_prime  += pt_e_prime * cos(phi_e);
          ps_e_prime   = sqrt(e_e_prime*e_e_prime - px_e_prime*px_e_prime - py_e_prime*py_e_prime - MELECTRON_GEV*MELECTRON_GEV);  // [1] longitudinal momentum

          pzeta_e_prime = (e_e_prime - e_ref) / (beta_ref * beta_ref * e_ref);

          // compute scattered photon momenta from momentum conservation
          px_photon_prime    = (*vx  + vx_photon) * e_primary - px_e_prime;
          py_photon_prime    = (*vy  + vy_photon) * e_primary - py_e_prime;
          pzeta_photon_prime = (*vzeta + vzeta_photon) * e_primary - pzeta_e_prime;

          // account for the event weight
          r1 = RandomUniform_generate(part);
          if (r1 < scal) {

            if (bhabha_record){
              // Get a slot in the record (this is thread safe)
              int64_t i_slot = RecordIndex_get_slot(bhabha_table_index);
              // The returned slot id is negative if record is NULL or if record is full
              if (i_slot>=0){
                  BhabhaTableData_set_particle_id(   bhabha_table, i_slot, LocalParticle_get_particle_id(part));
                  BhabhaTableData_set_primary_energy(bhabha_table, i_slot, e_primary);
                  BhabhaTableData_set_photon_id(     bhabha_table, i_slot, n);
                  BhabhaTableData_set_photon_energy( bhabha_table, i_slot, e_photon_prime*1e9);
                  BhabhaTableData_set_photon_px(     bhabha_table, i_slot, px_photon_prime);
                  BhabhaTableData_set_photon_py(     bhabha_table, i_slot, py_photon_prime);
                  BhabhaTableData_set_photon_pzeta(  bhabha_table, i_slot, pzeta_photon_prime);
                  BhabhaTableData_set_theta_e(       bhabha_table, i_slot, theta_e);
                  BhabhaTableData_set_theta_g(       bhabha_table, i_slot, theta_g);
              }
            }

            // scattered photons are real so affect a macropart with a probability
            r2 = RandomUniform_generate(part);
            if (r2 < 1.0 / part_per_mpart){
              e_loss_primary = e_e_prime - e_primary;  // [GeV], <0, loss from a single photon emission

              if (e_loss_primary == 0.0){
                printf("0 energy loss: %g", e_loss_primary);
              }else{
                printf("[%d] lost %g [GeV]\n", (int)part->ipart, e_loss_primary);
                if (-1.0 * e_loss_primary >= e_primary){  // macropart dies
                  LocalParticle_set_state(part, XT_LOST_ALL_E_IN_SYNRAD); // used to flag this kind of loss
                  return;
                }else{  // macropart doesnt die
                  *vx    = px_e_prime / e_e_prime;
                  *vy    = py_e_prime / e_e_prime;
                  *vzeta = pzeta_e_prime / e_e_prime;
                  e_primary += e_loss_primary;
                  LocalParticle_update_pzeta(part, *vzeta);  // changes energy vars
                  LocalParticle_add_to_energy(part, e_loss_primary*1e9, 0);  // changes pzeta
                }
              }
            }
          }

        }
      }
    }
}
#endif /* XFIELDS_BHABHA_SPECTRUM_H */

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_BEAMBEAM3D_H
#define XFIELDS_BEAMBEAM3D_H

#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#endif

 static inline
void synchrobeam_kick(
        BeamBeamBiGaussian3DData el, LocalParticle *part,
        const int i_slice,
        double const q0, double const p0c,
        double* x_star,
        double* px_star,
        double* y_star,
        double* py_star,
        double* zeta_star,
        double* pzeta_star){

    // Get data from memory
    double const scale_strength = BeamBeamBiGaussian3DData_get_scale_strength(el);
    const double q0_bb  = scale_strength*BeamBeamBiGaussian3DData_get_other_beam_q0(el);
    const double min_sigma_diff = BeamBeamBiGaussian3DData_get_min_sigma_diff(el);
    const double threshold_singular = BeamBeamBiGaussian3DData_get_threshold_singular(el);

    double const Sig_11_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(el, i_slice);
    double const Sig_12_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(el, i_slice);
    double const Sig_13_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(el, i_slice);
    double const Sig_14_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(el, i_slice);
    double const Sig_22_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(el, i_slice);
    double const Sig_23_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(el, i_slice);
    double const Sig_24_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(el, i_slice);
    double const Sig_33_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(el, i_slice);
    double const Sig_34_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(el, i_slice);
    double const Sig_44_0 = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(el, i_slice);

    double const num_part_slice = BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(el, i_slice);

    // no kick if not sufficient macroparticles; should be taken care of when slicing
    if (num_part_slice == 0){
        return;
    }

    const double x_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(el, i_slice);
    const double y_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(el, i_slice);
    const double px_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(el, i_slice);
    const double py_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(el, i_slice);
    const double zeta_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(el, i_slice);
    const double pzeta_slice_star = BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(el, i_slice);

    const double P0 = p0c/C_LIGHT*QELEM;

    //Compute force scaling factor
    const double Ksl = num_part_slice*QELEM*q0_bb*QELEM*q0/(P0 * C_LIGHT);

    //Identify the Collision Point (CP)
    #ifdef XFIELDS_BEAMBEAM3D_FORCE_CP0
    const double S = 0.0;
    #else
    const double S = 0.5*(*zeta_star - zeta_slice_star);
    #endif
    //fflush(stdout);

    // Propagate sigma matrix
    double Sig_11_hat_star, Sig_33_hat_star, costheta, sintheta;
    double dS_Sig_11_hat_star, dS_Sig_33_hat_star, dS_costheta, dS_sintheta;

    // Get strong beam shape at the CP
    Sigmas_propagate(
            Sig_11_0,
            Sig_12_0,
            Sig_13_0,
            Sig_14_0,
            Sig_22_0,
            Sig_23_0,
            Sig_24_0,
            Sig_33_0,
            Sig_34_0,
            Sig_44_0,
            S, threshold_singular, 1,
            &Sig_11_hat_star, &Sig_33_hat_star,
            &costheta, &sintheta,
            &dS_Sig_11_hat_star, &dS_Sig_33_hat_star,
            &dS_costheta, &dS_sintheta);

    // Evaluate transverse coordinates of the weak baem w.r.t. the strong beam centroid
    const double x_bar_star = *x_star + *px_star * S - x_slice_star + px_slice_star * S;
    const double y_bar_star = *y_star + *py_star * S - y_slice_star + py_slice_star * S;

    // Move to the uncoupled reference frame
    const double x_bar_hat_star = x_bar_star*costheta + y_bar_star * sintheta;
    const double y_bar_hat_star = -x_bar_star*sintheta + y_bar_star * costheta;

    // Compute derivatives of the transformation
    const double dS_x_bar_hat_star = x_bar_star * dS_costheta + y_bar_star * dS_sintheta;
    const double dS_y_bar_hat_star = -x_bar_star * dS_sintheta + y_bar_star * dS_costheta;

    // Get transverse fields
    double Ex, Ey;
    get_Ex_Ey_gauss(x_bar_hat_star, y_bar_hat_star,
        sqrt(Sig_11_hat_star), sqrt(Sig_33_hat_star),
        min_sigma_diff,
        &Ex, &Ey);

    //compute Gs
    double Gx, Gy;
    compute_Gx_Gy(x_bar_hat_star, y_bar_hat_star,
          sqrt(Sig_11_hat_star), sqrt(Sig_33_hat_star),
                      min_sigma_diff, Ex, Ey, &Gx, &Gy);

    // Compute kicks
    double Fx_hat_star = Ksl*Ex;
    double Fy_hat_star = Ksl*Ey;
    double Gx_hat_star = Ksl*Gx;
    double Gy_hat_star = Ksl*Gy;

    // Move kicks to coupled reference frame
    double Fx_star = Fx_hat_star*costheta - Fy_hat_star*sintheta;
    double Fy_star = Fx_hat_star*sintheta + Fy_hat_star*costheta;

    // Compute longitudinal kick
    double Fz_star = 0.5*(Fx_hat_star*dS_x_bar_hat_star  + Fy_hat_star*dS_y_bar_hat_star+
                   Gx_hat_star*dS_Sig_11_hat_star + Gy_hat_star*dS_Sig_33_hat_star);

    double rho, wgt;

    // calculate luminosity
    const int64_t flag_luminosity = BeamBeamBiGaussian3DData_get_flag_luminosity(el);
    if (flag_luminosity == 1){

        // gaussian charge density: at x, y density given by the 2D gaussian, local lumi depending on x y, total lumi sum of all
        get_charge_density(x_bar_hat_star, y_bar_hat_star, sqrt(Sig_11_hat_star), sqrt(Sig_33_hat_star), &rho);
        wgt =  LocalParticle_get_weight(part) * num_part_slice * rho;  // [m^-2] integrated lumi of a single electron colliding with the opposing slice

        // init record table
        BeamBeamBiGaussian3DRecordData lumi_record = NULL;
        LumiTableData lumi_table                   = NULL;
        RecordIndex lumi_table_index               = NULL;
        lumi_record = BeamBeamBiGaussian3DData_getp_internal_record(el, part);
        if (lumi_record){
            lumi_table       = BeamBeamBiGaussian3DRecordData_getp_lumitable(lumi_record);
            lumi_table_index =                      LumiTableData_getp__index(lumi_table);

        const int at_turn = LocalParticle_get_at_turn(part);
          double* lumi_address = LumiTableData_getp1_luminosity(lumi_table, at_turn);
        atomicAdd(lumi_address, wgt);
        }
    }

    // emit bhabha photons from single macropart
    #ifndef XFIELDS_BB3D_NO_BHABHA
    const int64_t flag_bhabha = BeamBeamBiGaussian3DData_get_flag_bhabha(el);
    if (flag_bhabha == 1) {

        // init record table
        BeamBeamBiGaussian3DRecordData bhabha_record = NULL;
        BhabhaTableData bhabha_table                 = NULL;
        RecordIndex bhabha_table_index               = NULL;
        bhabha_record = BeamBeamBiGaussian3DData_getp_internal_record(el, part);
        if (bhabha_record){
            bhabha_table       = BeamBeamBiGaussian3DRecordData_getp_bhabhatable(bhabha_record);
            bhabha_table_index =                      BhabhaTableData_getp__index(bhabha_table);
        }

        // switch for beam size effect
        const int64_t flag_beamsize_effect = BeamBeamBiGaussian3DData_get_flag_beamsize_effect(el);

        // gaussian charge density, we are centered at the strong slice centroid
        if (flag_luminosity != 1 && flag_beamsize_effect == 0){
          get_charge_density(x_bar_hat_star, y_bar_hat_star, sqrt(Sig_11_hat_star), sqrt(Sig_33_hat_star), &rho);
          wgt =  LocalParticle_get_weight(part) * num_part_slice * rho;  // [m^-2] integrated lumi of a single electron colliding with the opposing slice
        }

        LocalParticle_update_pzeta(part, *pzeta_star);  // update energy vars with boost and/or last kick
    
        const double other_beam_slice_energy =  LocalParticle_get_energy0(part)*(1 + pzeta_slice_star) * 1e-9;  // [GeV] for now betastar is 1; later change to other beam E0    

        const double compt_x_min = BeamBeamBiGaussian3DData_get_compt_x_min(el);
        int n_photons = requiv(part, other_beam_slice_energy, compt_x_min);  // generate virtual photons of the opposite slice using the average energy of the opposite slice
    
        // generate virtual photons of the opposite slice
        double xmin, e_photon, q2, one_m_x, x_photon, y_photon, px_photon, py_photon, pzeta_photon, radius, theta;
        for (int i_phot=0; i_phot<n_photons; i_phot++){
    
          mequiv(part, other_beam_slice_energy, compt_x_min, &xmin, &e_photon, &q2, &one_m_x);  // here again use opposite slice energy average
    
          // apply beam size effect here (affects x and y only)
          switch(flag_beamsize_effect){
          case 0:  // this is w.r.t of the strong slice centroid
              radius = 0.0;
              x_photon = 0.0;
              y_photon = 0.0;
              break;
          case 1:  // photons distributed on a disc around centroid
              radius = HBAR_GEVS*C_LIGHT / sqrt(q2*one_m_x);  // [m]
              //printf("radius: %.6e\n", radius);
              radius = min(radius, 1e5);
              x_photon = rndm_sincos(part, &theta) * radius;
              y_photon = theta * radius;

              // resample charge density at randomized photon location
              get_charge_density(x_bar_hat_star+x_photon, y_bar_hat_star+y_photon, sqrt(Sig_11_hat_star), sqrt(Sig_33_hat_star), &rho);
              wgt =  LocalParticle_get_weight(part) * num_part_slice * rho;  // [m^-2] integrated lumi of a single electron colliding with the opposing slice
              break;
          }

          // virtual photons are located at the opposite slice centroid

          px_photon = px_slice_star;
          py_photon = py_slice_star; 
          pzeta_photon = pzeta_slice_star;
          
          //if (radius < sqrt(Sig_33_hat_star)){
            // for each virtual photon get compton scatterings; updates pzeta and energy vars inside
            compt_do(part, bhabha_record, bhabha_table_index, bhabha_table,
              e_photon, compt_x_min, q2, px_photon, py_photon, pzeta_photon, wgt, px_star, py_star, pzeta_star, q0);
    
            // reload pzeta since they changed from compton; px and py are changed only locally
            *pzeta_star = LocalParticle_get_pzeta(part);  // bhabha rescales energy vars, so load again before kick
         // }
        }
    }
    #endif

    // emit beamstrahlung photons from single macropart
    #ifndef XFIELDS_BB3D_NO_BEAMSTR
    const int64_t flag_beamstrahlung = BeamBeamBiGaussian3DData_get_flag_beamstrahlung(el);
    if(flag_beamstrahlung!=0){

        // init record table
        BeamBeamBiGaussian3DRecordData beamstrahlung_record = NULL;
        BeamstrahlungTableData beamstrahlung_table          = NULL;
        RecordIndex beamstrahlung_table_index               = NULL;
        beamstrahlung_record = BeamBeamBiGaussian3DData_getp_internal_record(el, part);
        if (beamstrahlung_record){
            beamstrahlung_table       = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(beamstrahlung_record);
            beamstrahlung_table_index =                      BeamstrahlungTableData_getp__index(beamstrahlung_table);
        }

        LocalParticle_update_pzeta(part, *pzeta_star);  // update energy vars with boost and/or last kick
        if(flag_beamstrahlung==1){

            // get unboosted strong slice RMS [m]
            double sqrtSigma_11 = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(el, i_slice);
            double sqrtSigma_33 = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(el, i_slice);
            double sqrtSigma_55 = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(el, i_slice);
            beamstrahlung_avg(part, beamstrahlung_record, beamstrahlung_table_index, beamstrahlung_table,
                num_part_slice, sqrtSigma_11, sqrtSigma_33, sqrtSigma_55); 
        } else if (flag_beamstrahlung==2){
            double const Fr = hypot(Fx_star, Fy_star) * LocalParticle_get_rpp(part); // radial kick [1]
            double const dz = .5*BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(el, i_slice);  // half slice width [m]
            beamstrahlung(part, beamstrahlung_record, beamstrahlung_table_index, beamstrahlung_table, Fr, dz);
        }
        *pzeta_star = LocalParticle_get_pzeta(part);  // BS rescales energy vars, so load again before kick
    }
    #endif

    // Apply the kicks (Hirata's synchro-beam)
    *pzeta_star = *pzeta_star + Fz_star + 0.5*(
                Fx_star*(*px_star+0.5*Fx_star + px_slice_star)+
                Fy_star*(*py_star+0.5*Fy_star + py_slice_star));
    *x_star = *x_star - S*Fx_star;
    *px_star = *px_star + Fx_star;
    *y_star = *y_star - S*Fy_star;
    *py_star = *py_star + Fy_star;
}

 static inline
void BeamBeamBiGaussian3D_track_local_particle(BeamBeamBiGaussian3DData el, LocalParticle* part0){

    // Get data from memory
    double const sin_phi = BeamBeamBiGaussian3DData_get__sin_phi(el);
    double const cos_phi = BeamBeamBiGaussian3DData_get__cos_phi(el);
    double const tan_phi = BeamBeamBiGaussian3DData_get__tan_phi(el);
    double const sin_alpha = BeamBeamBiGaussian3DData_get__sin_alpha(el);
    double const cos_alpha = BeamBeamBiGaussian3DData_get__cos_alpha(el);

    const int N_slices = BeamBeamBiGaussian3DData_get_num_slices_other_beam(el);

    const double shift_x = BeamBeamBiGaussian3DData_get_ref_shift_x(el)
                           + BeamBeamBiGaussian3DData_get_other_beam_shift_x(el);
    const double shift_px = BeamBeamBiGaussian3DData_get_ref_shift_px(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_px(el);
    const double shift_y = BeamBeamBiGaussian3DData_get_ref_shift_y(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_y(el);
    const double shift_py = BeamBeamBiGaussian3DData_get_ref_shift_py(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_py(el);
    const double shift_zeta = BeamBeamBiGaussian3DData_get_ref_shift_zeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(el);
    const double shift_pzeta = BeamBeamBiGaussian3DData_get_ref_shift_pzeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(el);

    double const scale_strength = BeamBeamBiGaussian3DData_get_scale_strength(el);
    const double post_subtract_x = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_x(el);
    const double post_subtract_px = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_px(el);
    const double post_subtract_y = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_y(el);
    const double post_subtract_py = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_py(el);
    const double post_subtract_zeta = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_zeta(el);
    const double post_subtract_pzeta = scale_strength*BeamBeamBiGaussian3DData_get_post_subtract_pzeta(el);


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        double x = LocalParticle_get_x(part);
        double px = LocalParticle_get_px(part);
        double y = LocalParticle_get_y(part);
        double py = LocalParticle_get_py(part);
        double zeta = LocalParticle_get_zeta(part);
        double pzeta = LocalParticle_get_pzeta(part);

        const double q0 = LocalParticle_get_q0(part);
        const double p0c = LocalParticle_get_p0c(part); // eV

        // Change reference frame
        change_ref_frame_coordinates(
            &x, &px, &y, &py, &zeta, &pzeta,
            shift_x, shift_px, shift_y, shift_py, shift_zeta, shift_pzeta,
            sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha);

        // Synchro beam
        for (int i_slice=0; i_slice<N_slices; i_slice++)
        {
                synchrobeam_kick(
                             el, part,
                             i_slice, q0, p0c,
                             &x,
                             &px,
                             &y,
                             &py,
                             &zeta,
                             &pzeta);
        }

        // Go back to original reference frame and remove dipolar effect
        change_back_ref_frame_and_subtract_dipolar_coordinates(
            &x, &px, &y, &py, &zeta, &pzeta,
            shift_x, shift_px, shift_y, shift_py, shift_zeta, shift_pzeta,
            post_subtract_x, post_subtract_px,
            post_subtract_y, post_subtract_py,
            post_subtract_zeta, post_subtract_pzeta,
            sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha);

        // Store
        LocalParticle_set_x(part, x);
        LocalParticle_set_px(part, px);
        LocalParticle_set_y(part, y);
        LocalParticle_set_py(part, py);
        LocalParticle_set_zeta(part, zeta);
        LocalParticle_update_pzeta(part, pzeta);


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}



#endif

// copyright ################################# //
// This file is part of the Xfields Package.   //
// Copyright (c) CERN, 2021.                   //
// ########################################### //

#ifndef XFIELDS_BEAMBEAM3D_METHODS_FOR_STRONGSTRONG_H
#define XFIELDS_BEAMBEAM3D_METHODS_FOR_STRONGSTRONG_H


 static inline
void BeamBeamBiGaussian3D_change_ref_frame_local_particle(
        BeamBeamBiGaussian3DData el, LocalParticle* part0){

    // Get data from memory
    double const sin_phi = BeamBeamBiGaussian3DData_get__sin_phi(el);
    double const cos_phi = BeamBeamBiGaussian3DData_get__cos_phi(el);
    double const tan_phi = BeamBeamBiGaussian3DData_get__tan_phi(el);
    double const sin_alpha = BeamBeamBiGaussian3DData_get__sin_alpha(el);
    double const cos_alpha = BeamBeamBiGaussian3DData_get__cos_alpha(el);

    const double shift_x = BeamBeamBiGaussian3DData_get_ref_shift_x(el)
                           + BeamBeamBiGaussian3DData_get_other_beam_shift_x(el);
    const double shift_px = BeamBeamBiGaussian3DData_get_ref_shift_px(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_px(el);
    const double shift_y = BeamBeamBiGaussian3DData_get_ref_shift_y(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_y(el);
    const double shift_py = BeamBeamBiGaussian3DData_get_ref_shift_py(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_py(el);
    const double shift_zeta = BeamBeamBiGaussian3DData_get_ref_shift_zeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(el);
    const double shift_pzeta = BeamBeamBiGaussian3DData_get_ref_shift_pzeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(el);


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        double x = LocalParticle_get_x(part);
        double px = LocalParticle_get_px(part);
        double y = LocalParticle_get_y(part);
        double py = LocalParticle_get_py(part);
        double zeta = LocalParticle_get_zeta(part);
        double pzeta = LocalParticle_get_pzeta(part);

        // Change reference frame
        change_ref_frame_coordinates(
            &x, &px, &y, &py, &zeta, &pzeta,
            shift_x, shift_px, shift_y, shift_py, shift_zeta, shift_pzeta,
            sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha);

        // Store
        LocalParticle_set_x(part, x);
        LocalParticle_set_px(part, px);
        LocalParticle_set_y(part, y);
        LocalParticle_set_py(part, py);
        LocalParticle_set_zeta(part, zeta);
        LocalParticle_update_pzeta(part, pzeta);


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}

 static inline
void BeamBeamBiGaussian3D_change_back_ref_frame_and_subtract_dipolar_local_particle(
        BeamBeamBiGaussian3DData el, LocalParticle* part0){

    // Get data from memory
    double const sin_phi = BeamBeamBiGaussian3DData_get__sin_phi(el);
    double const cos_phi = BeamBeamBiGaussian3DData_get__cos_phi(el);
    double const tan_phi = BeamBeamBiGaussian3DData_get__tan_phi(el);
    double const sin_alpha = BeamBeamBiGaussian3DData_get__sin_alpha(el);
    double const cos_alpha = BeamBeamBiGaussian3DData_get__cos_alpha(el);

    const double shift_x = BeamBeamBiGaussian3DData_get_ref_shift_x(el)
                           + BeamBeamBiGaussian3DData_get_other_beam_shift_x(el);
    const double shift_px = BeamBeamBiGaussian3DData_get_ref_shift_px(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_px(el);
    const double shift_y = BeamBeamBiGaussian3DData_get_ref_shift_y(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_y(el);
    const double shift_py = BeamBeamBiGaussian3DData_get_ref_shift_py(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_py(el);
    const double shift_zeta = BeamBeamBiGaussian3DData_get_ref_shift_zeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(el);
    const double shift_pzeta = BeamBeamBiGaussian3DData_get_ref_shift_pzeta(el)
                            + BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(el);

    const double post_subtract_x = BeamBeamBiGaussian3DData_get_post_subtract_x(el);
    const double post_subtract_px = BeamBeamBiGaussian3DData_get_post_subtract_px(el);
    const double post_subtract_y = BeamBeamBiGaussian3DData_get_post_subtract_y(el);
    const double post_subtract_py = BeamBeamBiGaussian3DData_get_post_subtract_py(el);
    const double post_subtract_zeta = BeamBeamBiGaussian3DData_get_post_subtract_zeta(el);
    const double post_subtract_pzeta = BeamBeamBiGaussian3DData_get_post_subtract_pzeta(el);


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        double x = LocalParticle_get_x(part);
        double px = LocalParticle_get_px(part);
        double y = LocalParticle_get_y(part);
        double py = LocalParticle_get_py(part);
        double zeta = LocalParticle_get_zeta(part);
        double pzeta = LocalParticle_get_pzeta(part);


        // Go back to original reference frame and remove dipolar effect
        change_back_ref_frame_and_subtract_dipolar_coordinates(
            &x, &px, &y, &py, &zeta, &pzeta,
            shift_x, shift_px, shift_y, shift_py, shift_zeta, shift_pzeta,
            post_subtract_x, post_subtract_px,
            post_subtract_y, post_subtract_py,
            post_subtract_zeta, post_subtract_pzeta,
            sin_phi, cos_phi, tan_phi, sin_alpha, cos_alpha);

        // Store
        LocalParticle_set_x(part, x);
        LocalParticle_set_px(part, px);
        LocalParticle_set_y(part, y);
        LocalParticle_set_py(part, py);
        LocalParticle_set_zeta(part, zeta);
        LocalParticle_update_pzeta(part, pzeta);


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}


 static inline
void BeamBeam3D_selective_apply_synchrobeam_kick_local_particle(BeamBeamBiGaussian3DData el,
                LocalParticle* part0,
                  int64_t* i_slice_for_particles){


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp


        const int64_t i_slice = i_slice_for_particles[part->ipart];
        const int64_t N_slices = BeamBeamBiGaussian3DData_get_num_slices_other_beam(el);

        if (i_slice >= 0 && i_slice < N_slices){

            double x_star = LocalParticle_get_x(part);
            double px_star = LocalParticle_get_px(part);
            double y_star = LocalParticle_get_y(part);
            double py_star = LocalParticle_get_py(part);
            double zeta_star = LocalParticle_get_zeta(part);
            double pzeta_star = LocalParticle_get_pzeta(part);

            const double q0 = LocalParticle_get_q0(part);
            const double p0c = LocalParticle_get_p0c(part); // eV
            synchrobeam_kick(
                el, part,
                i_slice, q0, p0c,
                &x_star,
                &px_star,
                &y_star,
                &py_star,
                &zeta_star,
                &pzeta_star);

            LocalParticle_set_x(part, x_star);
            LocalParticle_set_px(part, px_star);
            LocalParticle_set_y(part, y_star);
            LocalParticle_set_py(part, py_star);
            LocalParticle_set_zeta(part, zeta_star);
            LocalParticle_update_pzeta(part, pzeta_star);

        }


//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }


}

#endif


             
            void BeamBeamBiGaussian3D_track_particles(
               BeamBeamBiGaussian3DData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              BeamBeamBiGaussian3D_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }


             
            void synchro_beam_kick(
               BeamBeamBiGaussian3DData el,

                             ParticlesData particles,
    int64_t* i_slice_for_particles, 
                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              BeamBeam3D_selective_apply_synchrobeam_kick_local_particle(el, &lpart, i_slice_for_particles);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }


             
            void change_ref_frame(
               BeamBeamBiGaussian3DData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              BeamBeamBiGaussian3D_change_ref_frame_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }


             
            void change_back_ref_frame_and_subtract_dipolar(
               BeamBeamBiGaussian3DData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              BeamBeamBiGaussian3D_change_back_ref_frame_and_subtract_dipolar_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_MultipoleData
#define XOBJ_TYPEDEF_MultipoleData
typedef   struct MultipoleData_s * MultipoleData;
 static inline MultipoleData MultipoleData_getp(MultipoleData restrict  obj){
  int64_t offset=0;
  return (MultipoleData)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_get_order(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_order(MultipoleData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=8;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* MultipoleData_getp_order(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=8;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double MultipoleData_get_inv_factorial_order(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_inv_factorial_order(MultipoleData restrict  obj, double value){
  int64_t offset=0;
  offset+=16;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp_inv_factorial_order(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return ( double*)(( char*) obj+offset);
}
 static inline double MultipoleData_get_length(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_length(MultipoleData restrict  obj, double value){
  int64_t offset=0;
  offset+=24;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp_length(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=24;
  return ( double*)(( char*) obj+offset);
}
 static inline double MultipoleData_get_hxl(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_hxl(MultipoleData restrict  obj, double value){
  int64_t offset=0;
  offset+=32;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp_hxl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=32;
  return ( double*)(( char*) obj+offset);
}
 static inline double MultipoleData_get_hyl(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_hyl(MultipoleData restrict  obj, double value){
  int64_t offset=0;
  offset+=40;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp_hyl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=40;
  return ( double*)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_get_radiation_flag(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_radiation_flag(MultipoleData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=48;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* MultipoleData_getp_radiation_flag(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=48;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline double MultipoleData_get_delta_taper(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_delta_taper(MultipoleData restrict  obj, double value){
  int64_t offset=0;
  offset+=56;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp_delta_taper(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=56;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 MultipoleData_getp_knl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=88;
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_len_knl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=88;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double MultipoleData_get_knl(const MultipoleData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=88;
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_knl(MultipoleData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=88;
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp1_knl(MultipoleData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=88;
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline ArrNFloat64 MultipoleData_getp_ksl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  return (ArrNFloat64)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_len_ksl(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline double MultipoleData_get_ksl(const MultipoleData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return *( double*)(( char*) obj+offset);
}
 static inline void MultipoleData_set_ksl(MultipoleData restrict  obj, int64_t i0, double value){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  *( double*)(( char*) obj+offset)=value;
}
 static inline  double* MultipoleData_getp1_ksl(MultipoleData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+80);
  offset+=16+i0*8;
  return ( double*)(( char*) obj+offset);
}
 static inline RecordIdentifier MultipoleData_getp__internal_record_id(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return (RecordIdentifier)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_get__internal_record_id_buffer_id(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void MultipoleData_set__internal_record_id_buffer_id(MultipoleData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=64;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* MultipoleData_getp__internal_record_id_buffer_id(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=64;
  return ( int64_t*)(( char*) obj+offset);
}
 static inline int64_t MultipoleData_get__internal_record_id_offset(const MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline void MultipoleData_set__internal_record_id_offset(MultipoleData restrict  obj, int64_t value){
  int64_t offset=0;
  offset+=72;
  *( int64_t*)(( char*) obj+offset)=value;
}
 static inline  int64_t* MultipoleData_getp__internal_record_id_offset(MultipoleData restrict  obj){
  int64_t offset=0;
  offset+=72;
  return ( int64_t*)(( char*) obj+offset);
}
#endif
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_FUNCTIONS_H
#define XTRACK_FUNCTIONS_H

 static inline
void kill_all_particles(LocalParticle* part0, int64_t kill_state) {

    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        LocalParticle_kill_particle(part, kill_state);

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}


 static inline
int8_t assert_tracking(LocalParticle* part, int64_t kill_state){
    // Whenever we are not tracking, e.g. in a twiss, the particle will be at_turn < 0.
    // We test this to distinguish genuine tracking from twiss.
    if (LocalParticle_get_at_turn(part) < 0){
        LocalParticle_kill_particle(part, kill_state);
        return 0;
    }
    return 1;
}

#endif /* XTRACK_FUNCTIONS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2023.                 //
// ######################################### //

#ifndef XTRACK_PARTICLE_STATES_H
#define XTRACK_PARTICLE_STATES_H

#define  XT_LOST_ON_APERTURE       0
#define  XT_LOST_ON_LONG_CUT      -2
#define  XT_LOST_ALL_E_IN_SYNRAD -10
#define  RNG_ERR_SEEDS_NOT_SET   -20
#define  RNG_ERR_INVALID_TRACK   -21
#define  RNG_ERR_RUTH_NOT_SET    -22

#endif /* XTRACK_PARTICLE_STATES_H */


 static inline
SynchrotronRadiationRecordData MultipoleData_getp_internal_record(MultipoleData el, LocalParticle* part){
    RecordIdentifier record_id = MultipoleData_getp__internal_record_id(el);
    if (RecordIdentifier_get_buffer_id(record_id) <= 0){
        return NULL;
    }
    else{
        return (SynchrotronRadiationRecordData) RecordIdentifier_getp_record(record_id, part);
    }
    }
    
// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_CONSTANTS_H
#define XTRACK_CONSTANTS_H

#if !defined( C_LIGHT )
    #define   C_LIGHT ( 299792458.0 )
#endif /* !defined( C_LIGHT ) */

#if !defined( EPSILON_0 )
    #define   EPSILON_0 (8.854187817620e-12)
#endif /* !defined( EPSILON_0 ) */

#if !defined( PI )
    #define PI (3.1415926535897932384626433832795028841971693993751)
#endif /* !defined( PI ) */

#if !defined( MU_0 )
    #define MU_0 (PI*4.0e-7)
#endif /* !defined( MU_0 ) */

#if !defined( DEG2RAD )
    #define DEG2RAD (0.0174532925199432957692369076848861271344287188854)
#endif /* !defiend( DEG2RAD ) */

#if !defined( RAD2DEG )
    #define RAD2DEG (57.29577951308232087679815481410517033240547246656442)
#endif /* !defiend( RAD2DEG ) */

#if !defined( SQRT_PI )
    #define SQRT_PI (1.7724538509055160272981674833411451827975494561224)
#endif /* !defined( SQRT_PI ) */

#if !defined( QELEM )
    #define QELEM (1.60217662e-19)
#endif /* !defined( QELEM ) */

#if !defined( DBL_MAX )
    #define DBL_MAX (1.7976931348623158e+308)
#endif /* !defined( DBL_MAX ) */

#if !defined( DBL_MIN )
    #define DBL_MIN (2.2250738585072014e-308)
#endif /* !defined( DBL_MIN ) */

#if !defined( DBL_EPSILON )
    #define DBL_EPSILON (2.2204460492503131e-16)
#endif /* !defined( DBL_EPSILON ) */

#endif /* XTRACK_CONSTANTS_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_SYNRAD_SPECTRUM_H
#define XTRACK_SYNRAD_SPECTRUM_H

#define SQRT3 1.732050807568877
#define ALPHA_EM 0.0072973525693

 static inline
void synrad_average_kick(LocalParticle* part, double curv, double lpath,
                         double* dp_record, double* dpx_record, double* dpy_record
                        ){
    double const gamma0  = LocalParticle_get_gamma0(part);
    double const mass0 = LocalParticle_get_mass0(part);
    double const q0 = LocalParticle_get_q0(part);

    double const Q0_coulomb = q0 * QELEM;
    double const mass0_kg = mass0 / C_LIGHT / C_LIGHT * QELEM;

    double const delta  = LocalParticle_get_delta(part);
    double const gamma = gamma0 * (1 + delta); // Ultra-relativistic approximation

    double const P0_J = LocalParticle_get_p0c(part) / C_LIGHT * QELEM;
    double const B_T = curv * P0_J / (Q0_coulomb);
    double const r0_m = Q0_coulomb * Q0_coulomb/  (4 * PI * EPSILON_0 * mass0_kg * C_LIGHT * C_LIGHT);

    double const Ps_W = 2 * r0_m * C_LIGHT * Q0_coulomb * Q0_coulomb * gamma * gamma * B_T * B_T / (3 * mass0_kg);
    double const Delta_E_eV = Ps_W * lpath / C_LIGHT / QELEM;
    double f_t = 1 - Delta_E_eV / (gamma0 * mass0 * (1 + delta));

    #ifdef XTRACK_SYNRAD_SCALE_SAME_AS_FIRST
    if (part -> ipart == 0){
      *dp_record = f_t;
    }
    else{
      f_t = *dp_record;
    }
    #endif

    #ifdef XTRACK_SYNRAD_KICK_SAME_AS_FIRST
    if (part -> ipart == 0){
      *dp_record = LocalParticle_get_delta(part);
      *dpx_record = LocalParticle_get_px(part);
      *dpy_record = LocalParticle_get_py(part);
    }
    else{
      f_t = 1.0;
    }
    #endif

    LocalParticle_update_delta(part, (delta+1) * f_t - 1);
    LocalParticle_scale_px(part, f_t);
    LocalParticle_scale_py(part, f_t);

    #ifdef XTRACK_SYNRAD_KICK_SAME_AS_FIRST
    if (part -> ipart == 0){
      *dp_record = LocalParticle_get_delta(part) - *dp_record;
      *dpx_record = LocalParticle_get_px(part) - *dpx_record;
      *dpy_record = LocalParticle_get_py(part) - *dpy_record;
    }
    else{
      LocalParticle_update_delta(part, LocalParticle_get_delta(part) + *dp_record);
      LocalParticle_add_to_px(part, *dpx_record);
      LocalParticle_add_to_py(part, *dpy_record);
    }
    #endif
}

 static inline
double SynRad(double x)
{
  // x :    energy normalized to the critical energy
  // returns function value _SynRadC   photon spectrum dn/dx
  // (integral of modified 1/3 order Bessel function)
  // principal: Chebyshev series see H.H.Umstaetter CERN/PS/SM/81-13 10-3-1981
  // see also my LEP Note 632 of 12/1990
  // converted to C++, H.Burkhardt 21-4-1996    */
  double synrad = 0.;
  if(x>0. && x<800.) {	// otherwise result synrad remains 0
    if(x<6.) {
      double a,b,z;
      z=x*x/16.-2.;
      b=          .00000000000000000012;
      a=z*b  +    .00000000000000000460;
      b=z*a-b+    .00000000000000031738;
      a=z*b-a+    .00000000000002004426;
      b=z*a-b+    .00000000000111455474;
      a=z*b-a+    .00000000005407460944;
      b=z*a-b+    .00000000226722011790;
      a=z*b-a+    .00000008125130371644;
      b=z*a-b+    .00000245751373955212;
      a=z*b-a+    .00006181256113829740;
      b=z*a-b+    .00127066381953661690;
      a=z*b-a+    .02091216799114667278;
      b=z*a-b+    .26880346058164526514;
      a=z*b-a+   2.61902183794862213818;
      b=z*a-b+  18.65250896865416256398;
      a=z*b-a+  92.95232665922707542088;
      b=z*a-b+ 308.15919413131586030542;
      a=z*b-a+ 644.86979658236221700714;
      double p;
      p=.5*z*a-b+  414.56543648832546975110;
      a=          .00000000000000000004;
      b=z*a+      .00000000000000000289;
      a=z*b-a+    .00000000000000019786;
      b=z*a-b+    .00000000000001196168;
      a=z*b-a+    .00000000000063427729;
      b=z*a-b+    .00000000002923635681;
      a=z*b-a+    .00000000115951672806;
      b=z*a-b+    .00000003910314748244;
      a=z*b-a+    .00000110599584794379;
      b=z*a-b+    .00002581451439721298;
      a=z*b-a+    .00048768692916240683;
      b=z*a-b+    .00728456195503504923;
      a=z*b-a+    .08357935463720537773;
      b=z*a-b+    .71031361199218887514;
      a=z*b-a+   4.26780261265492264837;
      b=z*a-b+  17.05540785795221885751;
      a=z*b-a+  41.83903486779678800040;
      double q;
      q=.5*z*a-b+28.41787374362784178164;
      double y;
      y=pow(x,2./3.);
      synrad=(p/y-q*y-1.)*1.81379936423421784215530788143;

    } else {// 6 < x < 174

      double a,b,z;
      z=20./x-2.;
      a=      .00000000000000000001;
      b=z*a  -.00000000000000000002;
      a=z*b-a+.00000000000000000006;
      b=z*a-b-.00000000000000000020;
      a=z*b-a+.00000000000000000066;
      b=z*a-b-.00000000000000000216;
      a=z*b-a+.00000000000000000721;
      b=z*a-b-.00000000000000002443;
      a=z*b-a+.00000000000000008441;
      b=z*a-b-.00000000000000029752;
      a=z*b-a+.00000000000000107116;
      b=z*a-b-.00000000000000394564;
      a=z*b-a+.00000000000001489474;
      b=z*a-b-.00000000000005773537;
      a=z*b-a+.00000000000023030657;
      b=z*a-b-.00000000000094784973;
      a=z*b-a+.00000000000403683207;
      b=z*a-b-.00000000001785432348;
      a=z*b-a+.00000000008235329314;
      b=z*a-b-.00000000039817923621;
      a=z*b-a+.00000000203088939238;
      b=z*a-b-.00000001101482369622;
      a=z*b-a+.00000006418902302372;
      b=z*a-b-.00000040756144386809;
      a=z*b-a+.00000287536465397527;
      b=z*a-b-.00002321251614543524;
      a=z*b-a+.00022505317277986004;
      b=z*a-b-.00287636803664026799;
      a=z*b-a+.06239591359332750793;
      double p;
      p=.5*z*a-b    +1.06552390798340693166;
      synrad=p*sqrt(0.5*PI/x)/exp(x);
    }
  }
  return synrad;
}

 static inline
double synrad_gen_photon_energy_normalized(LocalParticle *part)
{
  // initialize constants used in the approximate expressions
  // for SYNRAD   (integral over the modified Bessel function K5/3)
  //  xmin = 0.;
  double const xlow = 1.;
  double const a1 = 2.149528241534391; // Synrad(1.e-38)/pow(1.e-38,-2./3.);
  double const a2 = 1.770750801624037; // Synrad(xlow)/exp(-xlow);
  double const c1 = 0.; //
  double const ratio = 0.908250405131381;
  double appr, exact, result;
  do {
    if (RandomUniform_generate(part) < ratio) { // use low energy approximation
      result=c1+(1.-c1)*RandomUniform_generate(part);
      double tmp = result*result;
      result*=tmp;  	// take to 3rd power;
      exact=SynRad(result);
      appr=a1/tmp;
    } else {				// use high energy approximation
      result=xlow-log(RandomUniform_generate(part));
      exact=SynRad(result);
      appr=a2*exp(-result);
    }
  } while (exact < appr*RandomUniform_generate(part));	// reject in proportion of approx
  return result; // result now exact spectrum with unity weight
}

 static inline
double synrad_average_number_of_photons(
                          double beta0_gamma0, double curv, double lpath){
    double const kick = curv * lpath;
    return 2.5/SQRT3*ALPHA_EM*beta0_gamma0*fabs(kick);
}

 static inline
int64_t synrad_emit_photons(LocalParticle *part, double curv /* 1/m */,
                            double lpath /* m */,
                            RecordIndex record_index,
                            SynchrotronRadiationRecordData record
                            ){

    if (fabs(curv) < 1e-15)
        return 0;

    int64_t nphot = 0;

    // TODO Introduce effect of chi and mass_ratio!!!
    double const m0 = LocalParticle_get_mass0(part); // eV
    double const gamma0  = LocalParticle_get_gamma0(part);
    double const beta0  = LocalParticle_get_beta0(part);

    double const initial_energy = LocalParticle_get_energy0(part)
	                          + LocalParticle_get_ptau(part)*LocalParticle_get_p0c(part); // eV
    double energy = initial_energy;
    double gamma = energy / m0; //
    //double beta_gamma = sqrt(gamma*gamma-1); //
    double n = RandomExponential_generate(part); // path_length / mean_free_path;
    // printf("curv = %e\n gamma0 = %e\n lpath = %e\n", curv, gamma0, lpath);
    // printf("Average_number_of_photons = %e\n", synrad_average_number_of_photons(beta0 * gamma0, curv, lpath));
    while (n < synrad_average_number_of_photons(beta0 * gamma0, curv, lpath)) {
        nphot++;
        double const c1 = 1.5 * 1.973269804593025e-07; // hbar * c = 1.973269804593025e-07 eV * m
        double const energy_critical = c1 * (gamma*gamma*gamma0) * curv; // eV
        double const energy_loss = synrad_gen_photon_energy_normalized(part) * energy_critical; // eV
        if (energy_loss >= energy) {
            energy = 0.0; // eV
            break;
        }
        energy -= energy_loss; // eV
        gamma = energy / m0; //
        // beta_gamma = sqrt(gamma*gamma-1); // that's how beta gamma is
        n += RandomExponential_generate(part);
        if (record){
          int64_t i_slot = RecordIndex_get_slot(record_index);
          // The returned slot id is negative if record is NULL or if record is full

          if (i_slot>=0){
              SynchrotronRadiationRecordData_set_photon_energy(record, i_slot,
                                                               energy_loss);
              SynchrotronRadiationRecordData_set_at_element(record, i_slot,
                                          LocalParticle_get_at_element(part));
              SynchrotronRadiationRecordData_set_at_turn(record, i_slot,
                                          LocalParticle_get_at_turn(part));
              SynchrotronRadiationRecordData_set_particle_id(record, i_slot,
                                          LocalParticle_get_particle_id(part));
              SynchrotronRadiationRecordData_set_particle_delta(record, i_slot,
                                          LocalParticle_get_delta(part));
          }
        }
    }

    if (energy <= 0.0)
      LocalParticle_set_state(part, XT_LOST_ALL_E_IN_SYNRAD); // used to flag this kind of loss
    else{
      //LocalParticle_add_to_energy(part, energy-initial_energy, 0);
      double f_t = energy/initial_energy;
      LocalParticle_update_delta(part, (LocalParticle_get_delta(part)+1) * f_t - 1);
      LocalParticle_scale_px(part, f_t);
      LocalParticle_scale_py(part, f_t);
    }

    return nphot;
}

#endif /* XTRACK_SYNRAD_SPECTRUM_H */

// copyright ############################### //
// This file is part of the Xtrack Package.  //
// Copyright (c) CERN, 2021.                 //
// ######################################### //

#ifndef XTRACK_MULTIPOLE_H
#define XTRACK_MULTIPOLE_H

 static inline
void Multipole_track_local_particle(MultipoleData el, LocalParticle* part0){

    #ifndef XTRACK_MULTIPOLE_NO_SYNRAD
    int64_t radiation_flag = MultipoleData_get_radiation_flag(el);

    // Extract record and record_index
    SynchrotronRadiationRecordData record = NULL;
    RecordIndex record_index = NULL;
    if (radiation_flag==2){
        record = (SynchrotronRadiationRecordData) MultipoleData_getp_internal_record(el, part0);
        if (record){
            record_index = SynchrotronRadiationRecordData_getp__index(record);
        }
    }
    double dp_record_entry = 0.;
    double dpx_record_entry = 0.;
    double dpy_record_entry = 0.;
    double dp_record_exit = 0.;
    double dpx_record_exit = 0.;
    double dpy_record_exit = 0.;
    #endif

    #ifdef XTRACK_MULTIPOLE_NO_SYNRAD
    #define delta_taper (0)
    #else
        #ifndef XTRACK_MULTIPOLE_TAPER
        double const delta_taper = MultipoleData_get_delta_taper(el);
        #endif
    #endif


    {
//    const int64_t start_idx = part0->ipart; //only_for_context cpu_openmp
//    const int64_t end_idx = part0->endpart; //only_for_context cpu_openmp

    const int64_t start_idx = 0;                                            //only_for_context cpu_serial
    const int64_t end_idx = LocalParticle_get__num_active_particles(part0); //only_for_context cpu_serial

    //#pragma omp simd // TODO: currently does not work, needs investigating
    for (int64_t ii=start_idx; ii<end_idx; ii++) { //only_for_context cpu_openmp cpu_serial

        LocalParticle lpart = *part0;  //only_for_context cpu_serial cpu_openmp
        LocalParticle* part = &lpart;  //only_for_context cpu_serial cpu_openmp
        part->ipart = ii;              //only_for_context cpu_serial cpu_openmp

//        LocalParticle* part = part0;   //only_for_context opencl cuda

//        if (LocalParticle_get_state(part) > 0) {  //only_for_context cpu_openmp

        int64_t order = MultipoleData_get_order(el);
        int64_t index = order;

        double inv_factorial = MultipoleData_get_inv_factorial_order(el);

        double dpx = MultipoleData_get_knl(el, index) * inv_factorial;
        double dpy = MultipoleData_get_ksl(el, index) * inv_factorial;

        #ifdef XSUITE_BACKTRACK
        dpx = -dpx;
        dpy = -dpy;
        #endif

        #ifdef XTRACK_MULTIPOLE_TAPER
        double const delta_taper = LocalParticle_get_delta(part);
        #endif
        dpx = dpx * (1 + delta_taper);
        dpy = dpy * (1 + delta_taper);

        double const x   = LocalParticle_get_x(part);
        double const y   = LocalParticle_get_y(part);
        double const chi = LocalParticle_get_chi(part);

        #ifndef XSUITE_BACKTRACK
        double const hxl = MultipoleData_get_hxl(el);
        double const hyl = MultipoleData_get_hyl(el);
        #else
        double const hxl = -MultipoleData_get_hxl(el);
        double const hyl = -MultipoleData_get_hyl(el);
        #endif

        while( index > 0 )
        {
            double const zre = dpx * x - dpy * y;
            double const zim = dpx * y + dpy * x;

            inv_factorial *= index;
            index -= 1;

            double this_knl = MultipoleData_get_knl(el, index);
            double this_ksl = MultipoleData_get_ksl(el, index);

            #ifdef XSUITE_BACKTRACK
            this_knl = -this_knl;
            this_ksl = -this_ksl;
            #endif

            this_knl = this_knl * (1 + delta_taper);
            this_ksl = this_ksl * (1 + delta_taper);

            dpx = this_knl*inv_factorial + zre;
            dpy = this_ksl*inv_factorial + zim;
        }

        #ifndef XSUITE_BACKTRACK
        double const length = MultipoleData_get_length(el); // m
        #else
        double const length = -MultipoleData_get_length(el); // m
        #endif

        #ifndef XTRACK_MULTIPOLE_NO_SYNRAD
        // Radiation at entrance
        double const curv = sqrt(dpx*dpx + dpy*dpy) / length;
        if (radiation_flag > 0 && length > 0){
            double const L_path = 0.5 * length * (1 + (hxl*x - hyl*y)/length);
            if (radiation_flag == 1){
                synrad_average_kick(part, curv, L_path,
                        &dp_record_entry, &dpx_record_entry, &dpy_record_entry);
            }
            else if (radiation_flag == 2){
                synrad_emit_photons(part, curv, L_path, record_index, record);
            }
        }
        #endif

        dpx = -chi * dpx; // rad
        dpy =  chi * dpy; // rad

        if( ( hxl > 0) || ( hyl > 0) || ( hxl < 0 ) || ( hyl < 0 ) )
        {
            double const delta  = LocalParticle_get_delta(part);

            double const hxlx   = x * hxl;
            double const hyly   = y * hyl;

            double const rv0v = 1./LocalParticle_get_rvv(part);

            dpx += (hxl + hxl * delta);
            dpy -= (hyl + hyl * delta);

            if( length != 0)
            {
                double b1l = chi * MultipoleData_get_knl(el, 0 );
                double a1l = chi * MultipoleData_get_ksl(el, 0 );

                #ifdef XSUITE_BACKTRACK
                b1l = -b1l;
                a1l = -a1l;
                #endif

                b1l = b1l * (1 + delta_taper);
                a1l = a1l * (1 + delta_taper);

                dpx -= b1l * hxlx / length;
                dpy -= a1l * hyly / length;
            }

            LocalParticle_add_to_zeta(part, rv0v*chi * ( hyly - hxlx ) );
        }

        LocalParticle_add_to_px(part, dpx);
        LocalParticle_add_to_py(part, dpy);

        // Radiation at exit
        #ifndef XTRACK_MULTIPOLE_NO_SYNRAD
        if (radiation_flag > 0 && length > 0){
            double const L_path = 0.5*length * (1 + (hxl*x - hyl*y)/length);
            if (radiation_flag == 1){
                synrad_average_kick(part, curv, L_path,
                        &dp_record_exit, &dpx_record_exit, &dpy_record_exit);
            }
            else if (radiation_flag == 2){
                // printf("L_path = %e curv = %e\n", L_path, curv);
                synrad_emit_photons(part, curv, L_path, record_index, record);
            }
        }
        #endif

//        }  //only_for_context cpu_openmp
    }  //only_for_context cpu_serial cpu_openmp
    }

}

#endif


             
            void Multipole_track_particles(
               MultipoleData el,

                             ParticlesData particles,

                             int64_t flag_increment_at_element,
                  int8_t* io_buffer){
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int64_t batch_id = 0; batch_id < num_threads; batch_id++) {               //only_for_context cpu_openmp
                LocalParticle lpart;
                lpart.io_buffer = io_buffer;
//                int64_t part_id = batch_id * chunk_size;                                       //only_for_context cpu_openmp
//                int64_t end_id = (batch_id + 1) * chunk_size;                                  //only_for_context cpu_openmp
//                if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

                int64_t part_id = 0;                    //only_for_context cpu_serial
//                int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x; //only_for_context cuda
//                int64_t part_id = get_global_id(0);                    //only_for_context opencl
                int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

                int64_t part_capacity = ParticlesData_get__capacity(particles);
                if (part_id<part_capacity){
                    Particles_to_LocalParticle(particles, &lpart, part_id, end_id);
                    if (check_is_active(&lpart)>0){
              Multipole_track_local_particle(el, &lpart);

                    }
                    if (check_is_active(&lpart)>0 && flag_increment_at_element){
                            increment_at_element(&lpart, 1);
                    }
                }
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }

#ifndef XOBJ_TYPEDEF_ElementRefClass
#define XOBJ_TYPEDEF_ElementRefClass
typedef   struct ElementRefClass_s * ElementRefClass;
enum ElementRefClass_e{ElementRefClass_BeamBeamBiGaussian2DData_t,ElementRefClass_BeamBeamBiGaussian3DData_t,ElementRefClass_CavityData_t,ElementRefClass_DipoleEdgeData_t,ElementRefClass_DriftData_t,ElementRefClass_MarkerData_t,ElementRefClass_MultipoleData_t,ElementRefClass_ParticlesMonitorData_t,ElementRefClass_SRotationData_t};
 static inline ElementRefClass ElementRefClass_getp(ElementRefClass restrict  obj){
  int64_t offset=0;
  return (ElementRefClass)(( char*) obj+offset);
}
 static inline int64_t ElementRefClass_typeid(const ElementRefClass restrict  obj){
  int64_t offset=0;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline  void* ElementRefClass_member(const ElementRefClass restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset);
 return ( void*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_ArrNElementRefClass
#define XOBJ_TYPEDEF_ArrNElementRefClass
typedef   struct ArrNElementRefClass_s * ArrNElementRefClass;
 static inline ArrNElementRefClass ArrNElementRefClass_getp(ArrNElementRefClass restrict  obj){
  int64_t offset=0;
  return (ArrNElementRefClass)(( char*) obj+offset);
}
 static inline int64_t ArrNElementRefClass_len(ArrNElementRefClass restrict  obj){
  int64_t offset=0;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline ElementRefClass ArrNElementRefClass_getp1(ArrNElementRefClass restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*16;
  return (ElementRefClass)(( char*) obj+offset);
}
 static inline int64_t ArrNElementRefClass_typeid(const ArrNElementRefClass restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*16;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline  void* ArrNElementRefClass_member(const ArrNElementRefClass restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16+i0*16;
  offset+=*( int64_t*)(( char*) obj+offset);
 return ( void*)(( char*) obj+offset);
}
#endif
#ifndef XOBJ_TYPEDEF_ElementRefData
#define XOBJ_TYPEDEF_ElementRefData
typedef   struct ElementRefData_s * ElementRefData;
 static inline ElementRefData ElementRefData_getp(ElementRefData restrict  obj){
  int64_t offset=0;
  return (ElementRefData)(( char*) obj+offset);
}
 static inline ArrNElementRefClass ElementRefData_getp_elements(ElementRefData restrict  obj){
  int64_t offset=0;
  offset+=16;
  return (ArrNElementRefClass)(( char*) obj+offset);
}
 static inline int64_t ElementRefData_len_elements(ElementRefData restrict  obj){
  int64_t offset=0;
  offset+=16;
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline ElementRefClass ElementRefData_getp1_elements(ElementRefData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16;
  offset+=16+i0*16;
  return (ElementRefClass)(( char*) obj+offset);
}
 static inline int64_t ElementRefData_typeid_elements(const ElementRefData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16;
  offset+=16+i0*16;
  offset+=8;
  return *( int64_t*)(( char*) obj+offset);
}
 static inline  void* ElementRefData_member_elements(const ElementRefData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=16;
  offset+=16+i0*16;
  offset+=*( int64_t*)(( char*) obj+offset);
 return ( void*)(( char*) obj+offset);
}
 static inline ArrNString ElementRefData_getp_names(ElementRefData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  return (ArrNString)(( char*) obj+offset);
}
 static inline int64_t ElementRefData_len_names(ElementRefData restrict  obj){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
   int64_t* arr = ( int64_t*)(( char*) obj+offset);
  return arr[1];
}
 static inline  char* ElementRefData_getp1_names(ElementRefData restrict  obj, int64_t i0){
  int64_t offset=0;
  offset+=*( int64_t*)(( char*) obj+offset+8);
  offset=*( int64_t*)(( char*) obj+offset+16+i0*8);
  return ( char*)(( char*) obj+offset);
}
#endif

             
            void track_line(
                  int8_t* buffer,
                             ElementRefData elem_ref_data,
                             ParticlesData particles,
                             int num_turns,
                             int ele_start,
                             int num_ele_track,
                             int flag_end_turn_actions,
                             int flag_reset_s_at_end_turn,
                             int flag_monitor,
                             int num_ele_line,
                             double line_length,
                  int8_t* buffer_tbt_monitor,
                             int64_t offset_tbt_monitor,
                  int8_t* io_buffer){

//            const int64_t capacity = ParticlesData_get__capacity(particles);               //only_for_context cpu_openmp
//            const int num_threads = omp_get_max_threads();                                 //only_for_context cpu_openmp
//            const int64_t chunk_size = (capacity + num_threads - 1)/num_threads; // ceil division  //only_for_context cpu_openmp
//            #pragma omp parallel for                                                       //only_for_context cpu_openmp
//            for (int chunk = 0; chunk < num_threads; chunk++) {                            //only_for_context cpu_openmp
//            int64_t part_id = chunk * chunk_size;                                          //only_for_context cpu_openmp
//            int64_t end_id = (chunk + 1) * chunk_size;                                     //only_for_context cpu_openmp
//            if (end_id > capacity) end_id = capacity;                                      //only_for_context cpu_openmp

            int64_t part_id = 0;                                      //only_for_context cpu_serial
//            int64_t part_id = blockDim.x * blockIdx.x + threadIdx.x;  //only_for_context cuda
//            int64_t part_id = get_global_id(0);                       //only_for_context opencl
            int64_t end_id = 0; // unused outside of openmp  //only_for_context cpu_serial cuda opencl

            LocalParticle lpart;
            lpart.io_buffer = io_buffer;

              int8_t* tbt_mon_pointer =
                            buffer_tbt_monitor + offset_tbt_monitor;
            ParticlesMonitorData tbt_monitor =
                            (ParticlesMonitorData) tbt_mon_pointer;

            int64_t part_capacity = ParticlesData_get__capacity(particles);
            if (part_id<part_capacity){
            Particles_to_LocalParticle(particles, &lpart, part_id, end_id);

            int64_t isactive = check_is_active(&lpart);

            for (int64_t iturn=0; iturn<num_turns; iturn++){

                if (!isactive){
                    break;
                }

                int64_t const ele_stop = ele_start + num_ele_track;

                #ifndef XSUITE_BACKTRACK
                if (flag_monitor==1){
                    ParticlesMonitor_track_local_particle(tbt_monitor, &lpart);
                }
                int64_t elem_idx = ele_start;
                int64_t const increm = 1;
                #else
                int64_t elem_idx = ele_stop - 1;
                int64_t const increm = -1;
                if (flag_end_turn_actions>0){
                    increment_at_turn_backtrack(&lpart, flag_reset_s_at_end_turn,
                                                line_length, num_ele_line);
                }
                #endif

                for (; ((elem_idx >= ele_start) && (elem_idx < ele_stop)); elem_idx+=increm){
                        if (flag_monitor==2){
                            ParticlesMonitor_track_local_particle(tbt_monitor, &lpart);
                        }

                        // Get the pointer to and the type id of the `elem_idx`th
                        // element in `element_ref_data.elements`:
                          void* el = ElementRefData_member_elements(elem_ref_data, elem_idx);
                        int64_t elem_type = ElementRefData_typeid_elements(elem_ref_data, elem_idx);

                        switch(elem_type){
        

                        case 0:


                            BeamBeamBiGaussian2D_track_local_particle((BeamBeamBiGaussian2DData) el, &lpart);
                            break;

                        case 1:


                            BeamBeamBiGaussian3D_track_local_particle((BeamBeamBiGaussian3DData) el, &lpart);
                            break;

                        case 2:


                            Cavity_track_local_particle((CavityData) el, &lpart);
                            break;

                        case 3:


                            DipoleEdge_track_local_particle((DipoleEdgeData) el, &lpart);
                            break;

                        case 4:


                            #ifdef XTRACK_GLOBAL_XY_LIMIT
                            global_aperture_check(&lpart);
                            #endif

                            

                            Drift_track_local_particle((DriftData) el, &lpart);
                            break;

                        case 5:


                            Marker_track_local_particle((MarkerData) el, &lpart);
                            break;

                        case 6:


                            Multipole_track_local_particle((MultipoleData) el, &lpart);
                            break;

                        case 7:


                            ParticlesMonitor_track_local_particle((ParticlesMonitorData) el, &lpart);
                            break;

                        case 8:


                            SRotation_track_local_particle((SRotationData) el, &lpart);
                            break;

                        } //switch

                    // Setting the below flag will break particle losses
                    #ifndef DANGER_SKIP_ACTIVE_CHECK_AND_SWAPS

                    isactive = check_is_active(&lpart);
                    if (!isactive){
                        break;
                    }

                    #ifndef XSUITE_BACKTRACK
                        increment_at_element(&lpart, 1);
                    #else
                        increment_at_element(&lpart, -1);
                    #endif //XSUITE_BACKTRACK

                    #endif //DANGER_SKIP_ACTIVE_CHECK_AND_SWAPS

                } // for elements

                if (flag_monitor==2){
                    // End of turn (element-by-element mode)
                    ParticlesMonitor_track_local_particle(tbt_monitor, &lpart);
                }

                #ifndef XSUITE_BACKTRACK
                if (flag_end_turn_actions>0){
                    if (isactive){
                        increment_at_turn(&lpart, flag_reset_s_at_end_turn);
                    }
                }
                #endif //XSUITE_BACKTRACK


                #ifdef XSUITE_BACKTRACK
                if (flag_monitor==1){
                    ParticlesMonitor_track_local_particle(tbt_monitor, &lpart);
                }
                #endif //XSUITE_BACKTRACK
            } // for turns

            LocalParticle_to_Particles(&lpart, particles, part_id, 1);

            }// if partid
//            } //only_for_context cpu_openmp

            // On OpenMP we want to additionally by default reorganize all
            // the particles.
//            #ifndef XT_OMP_SKIP_REORGANIZE                             //only_for_context cpu_openmp
//            LocalParticle lpart;                                       //only_for_context cpu_openmp
//            lpart.io_buffer = io_buffer;                               //only_for_context cpu_openmp
//            Particles_to_LocalParticle(particles, &lpart, 0, capacity);//only_for_context cpu_openmp
//            check_is_active(&lpart);                                   //only_for_context cpu_openmp
//            count_reorganized_particles(&lpart);                       //only_for_context cpu_openmp
//            LocalParticle_to_Particles(&lpart, particles, 0, capacity);//only_for_context cpu_openmp
//            #endif                                                     //only_for_context cpu_openmp
        }//kernel
        

/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 821), // char *()(struct ArrNString_s *, int64_t)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 830), // struct ArrNString_s *
/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23), // int64_t
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION, 821), // char *()(struct ElementRefData_s *, int64_t)
/*  5 */ _CFFI_OP(_CFFI_OP_POINTER, 841), // struct ElementRefData_s *
/*  6 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/*  7 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  8 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct ArrNFloat64_s *, int64_t)
/*  9 */ _CFFI_OP(_CFFI_OP_POINTER, 828), // struct ArrNFloat64_s *
/* 10 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 12 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BeamBeamBiGaussian2DData_s *)
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 832), // struct BeamBeamBiGaussian2DData_s *
/* 14 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 15 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BeamBeamBiGaussian3DData_s *)
/* 16 */ _CFFI_OP(_CFFI_OP_POINTER, 833), // struct BeamBeamBiGaussian3DData_s *
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 18 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BeamBeamBiGaussian3DData_s *, int64_t)
/* 19 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 20 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 21 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t)
/* 23 */ _CFFI_OP(_CFFI_OP_POINTER, 834), // struct BeamBeamBiGaussian3DRecordData_s *
/* 24 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 25 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BeamstrahlungTableData_s *, int64_t)
/* 27 */ _CFFI_OP(_CFFI_OP_POINTER, 835), // struct BeamstrahlungTableData_s *
/* 28 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 29 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 30 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct BhabhaTableData_s *, int64_t)
/* 31 */ _CFFI_OP(_CFFI_OP_POINTER, 836), // struct BhabhaTableData_s *
/* 32 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 33 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 34 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct CavityData_s *)
/* 35 */ _CFFI_OP(_CFFI_OP_POINTER, 837), // struct CavityData_s *
/* 36 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 37 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct DipoleEdgeData_s *)
/* 38 */ _CFFI_OP(_CFFI_OP_POINTER, 838), // struct DipoleEdgeData_s *
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 40 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct DriftData_s *)
/* 41 */ _CFFI_OP(_CFFI_OP_POINTER, 839), // struct DriftData_s *
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 43 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct LumiTableData_s *, int64_t)
/* 44 */ _CFFI_OP(_CFFI_OP_POINTER, 842), // struct LumiTableData_s *
/* 45 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 47 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct MultipoleData_s *)
/* 48 */ _CFFI_OP(_CFFI_OP_POINTER, 844), // struct MultipoleData_s *
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 50 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct MultipoleData_s *, int64_t)
/* 51 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 52 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 53 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 54 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct ParticlesData_s *)
/* 55 */ _CFFI_OP(_CFFI_OP_POINTER, 845), // struct ParticlesData_s *
/* 56 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 57 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct ParticlesData_s *, int64_t)
/* 58 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 59 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 60 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 61 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct ParticlesMonitorData_s *)
/* 62 */ _CFFI_OP(_CFFI_OP_POINTER, 846), // struct ParticlesMonitorData_s *
/* 63 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 64 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct ParticlesMonitorData_s *, int64_t)
/* 65 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 66 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 67 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 68 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct SRotationData_s *)
/* 69 */ _CFFI_OP(_CFFI_OP_POINTER, 851), // struct SRotationData_s *
/* 70 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 71 */ _CFFI_OP(_CFFI_OP_FUNCTION, 823), // double *()(struct SynchrotronRadiationRecordData_s *, int64_t)
/* 72 */ _CFFI_OP(_CFFI_OP_POINTER, 852), // struct SynchrotronRadiationRecordData_s *
/* 73 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 74 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 75 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct ArrNFloat64_s *, int64_t)
/* 76 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 77 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 78 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 79 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BeamBeamBiGaussian2DData_s *)
/* 80 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 81 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 82 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BeamBeamBiGaussian3DData_s *)
/* 83 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 84 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 85 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BeamBeamBiGaussian3DData_s *, int64_t)
/* 86 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 87 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 88 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 89 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t)
/* 90 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 91 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 92 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 93 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BeamstrahlungTableData_s *, int64_t)
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 95 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 96 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 97 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct BhabhaTableData_s *, int64_t)
/* 98 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 99 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 100 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 101 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct CavityData_s *)
/* 102 */ _CFFI_OP(_CFFI_OP_NOOP, 35),
/* 103 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 104 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct DipoleEdgeData_s *)
/* 105 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 106 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 107 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct DriftData_s *)
/* 108 */ _CFFI_OP(_CFFI_OP_NOOP, 41),
/* 109 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 110 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct LumiTableData_s *, int64_t)
/* 111 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 112 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 113 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 114 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct MultipoleData_s *)
/* 115 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 116 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 117 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct MultipoleData_s *, int64_t)
/* 118 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 119 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 120 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 121 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct ParticlesData_s *)
/* 122 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 123 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct ParticlesData_s *, int64_t)
/* 125 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 126 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 127 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 128 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct ParticlesMonitorData_s *)
/* 129 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 130 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 131 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct ParticlesMonitorData_s *, int64_t)
/* 132 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 133 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 134 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 135 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct SRotationData_s *)
/* 136 */ _CFFI_OP(_CFFI_OP_NOOP, 69),
/* 137 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 138 */ _CFFI_OP(_CFFI_OP_FUNCTION, 586), // double()(struct SynchrotronRadiationRecordData_s *, int64_t)
/* 139 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 140 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 141 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 142 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct ArrNInt64_s *, int64_t)
/* 143 */ _CFFI_OP(_CFFI_OP_POINTER, 829), // struct ArrNInt64_s *
/* 144 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 145 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 146 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BeamBeamBiGaussian3DData_s *)
/* 147 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 148 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 149 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 150 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t)
/* 153 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 154 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 155 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 156 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BeamstrahlungTableData_s *)
/* 157 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 158 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 159 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BeamstrahlungTableData_s *, int64_t)
/* 160 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 161 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 162 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 163 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BhabhaTableData_s *)
/* 164 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 165 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 166 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct BhabhaTableData_s *, int64_t)
/* 167 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 168 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 169 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 170 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct DipoleEdgeData_s *)
/* 171 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 172 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 173 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct LumiTableData_s *)
/* 174 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 175 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 176 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct LumiTableData_s *, int64_t)
/* 177 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 178 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 179 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 180 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct MarkerData_s *)
/* 181 */ _CFFI_OP(_CFFI_OP_POINTER, 843), // struct MarkerData_s *
/* 182 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 183 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct MultipoleData_s *)
/* 184 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 185 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 186 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct ParticlesData_s *)
/* 187 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 188 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 189 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct ParticlesData_s *, int64_t)
/* 190 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 191 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 192 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 193 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct ParticlesMonitorData_s *)
/* 194 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 195 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 196 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct ParticlesMonitorData_s *, int64_t)
/* 197 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 198 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 199 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 200 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct RecordIdentifier_s *)
/* 201 */ _CFFI_OP(_CFFI_OP_POINTER, 849), // struct RecordIdentifier_s *
/* 202 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 203 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct RecordIndex_s *)
/* 204 */ _CFFI_OP(_CFFI_OP_POINTER, 850), // struct RecordIndex_s *
/* 205 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 206 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct SynchrotronRadiationRecordData_s *)
/* 207 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 208 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 209 */ _CFFI_OP(_CFFI_OP_FUNCTION, 825), // int64_t *()(struct SynchrotronRadiationRecordData_s *, int64_t)
/* 210 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 211 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 212 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 213 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNElementRefClass_s *)
/* 214 */ _CFFI_OP(_CFFI_OP_POINTER, 827), // struct ArrNElementRefClass_s *
/* 215 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 216 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNElementRefClass_s *, int64_t)
/* 217 */ _CFFI_OP(_CFFI_OP_NOOP, 214),
/* 218 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 219 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 220 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNFloat64_s *)
/* 221 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 222 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 223 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNInt64_s *)
/* 224 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 225 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 226 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNInt64_s *, int64_t)
/* 227 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 228 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 229 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 230 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNString_s *)
/* 231 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 232 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 233 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ArrNUint32_s *)
/* 234 */ _CFFI_OP(_CFFI_OP_POINTER, 831), // struct ArrNUint32_s *
/* 235 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 236 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BeamBeamBiGaussian3DData_s *)
/* 237 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 238 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 239 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 240 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 241 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 242 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t)
/* 243 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 244 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 245 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 246 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BeamstrahlungTableData_s *)
/* 247 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 248 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 249 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BeamstrahlungTableData_s *, int64_t)
/* 250 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 251 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 252 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 253 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BhabhaTableData_s *)
/* 254 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 255 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 256 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct BhabhaTableData_s *, int64_t)
/* 257 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 258 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 259 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 260 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct DipoleEdgeData_s *)
/* 261 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 262 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 263 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ElementRefClass_s *)
/* 264 */ _CFFI_OP(_CFFI_OP_POINTER, 840), // struct ElementRefClass_s *
/* 265 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 266 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ElementRefData_s *)
/* 267 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 268 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 269 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ElementRefData_s *, int64_t)
/* 270 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 271 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 272 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 273 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct LumiTableData_s *)
/* 274 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 275 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 276 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct LumiTableData_s *, int64_t)
/* 277 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 278 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 279 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 280 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct MarkerData_s *)
/* 281 */ _CFFI_OP(_CFFI_OP_NOOP, 181),
/* 282 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 283 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct MultipoleData_s *)
/* 284 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 285 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 286 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ParticlesData_s *)
/* 287 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 288 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 289 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ParticlesData_s *, int64_t)
/* 290 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 291 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 292 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 293 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ParticlesMonitorData_s *)
/* 294 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 295 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 296 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct ParticlesMonitorData_s *, int64_t)
/* 297 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 298 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 299 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 300 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct RecordIdentifier_s *)
/* 301 */ _CFFI_OP(_CFFI_OP_NOOP, 201),
/* 302 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 303 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct RecordIndex_s *)
/* 304 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 305 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 306 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct SynchrotronRadiationRecordData_s *)
/* 307 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 308 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 309 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // int64_t()(struct SynchrotronRadiationRecordData_s *, int64_t)
/* 310 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 311 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 312 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 313 */ _CFFI_OP(_CFFI_OP_FUNCTION, 214), // struct ArrNElementRefClass_s *()(struct ArrNElementRefClass_s *)
/* 314 */ _CFFI_OP(_CFFI_OP_NOOP, 214),
/* 315 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 316 */ _CFFI_OP(_CFFI_OP_FUNCTION, 214), // struct ArrNElementRefClass_s *()(struct ElementRefData_s *)
/* 317 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 318 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 319 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct ArrNFloat64_s *)
/* 320 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 321 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 322 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct BeamBeamBiGaussian3DData_s *)
/* 323 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 324 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 325 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 326 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 327 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 328 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct BeamstrahlungTableData_s *)
/* 329 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 330 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 331 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct BhabhaTableData_s *)
/* 332 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 333 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 334 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct LumiTableData_s *)
/* 335 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 336 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 337 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct MultipoleData_s *)
/* 338 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 339 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 340 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct ParticlesData_s *)
/* 341 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 342 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 343 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct ParticlesMonitorData_s *)
/* 344 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 345 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 346 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // struct ArrNFloat64_s *()(struct SynchrotronRadiationRecordData_s *)
/* 347 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 348 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 349 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct ArrNInt64_s *)
/* 350 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 351 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 352 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 353 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 354 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 355 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct BeamstrahlungTableData_s *)
/* 356 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 357 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 358 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct BhabhaTableData_s *)
/* 359 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 360 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 361 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct LumiTableData_s *)
/* 362 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 363 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 364 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct ParticlesData_s *)
/* 365 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 366 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 367 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct ParticlesMonitorData_s *)
/* 368 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 369 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 370 */ _CFFI_OP(_CFFI_OP_FUNCTION, 143), // struct ArrNInt64_s *()(struct SynchrotronRadiationRecordData_s *)
/* 371 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 372 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 373 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // struct ArrNString_s *()(struct ArrNString_s *)
/* 374 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 375 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 376 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // struct ArrNString_s *()(struct ElementRefData_s *)
/* 377 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 378 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 379 */ _CFFI_OP(_CFFI_OP_FUNCTION, 234), // struct ArrNUint32_s *()(struct ArrNUint32_s *)
/* 380 */ _CFFI_OP(_CFFI_OP_NOOP, 234),
/* 381 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 382 */ _CFFI_OP(_CFFI_OP_FUNCTION, 234), // struct ArrNUint32_s *()(struct ParticlesData_s *)
/* 383 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 384 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 385 */ _CFFI_OP(_CFFI_OP_FUNCTION, 234), // struct ArrNUint32_s *()(struct ParticlesMonitorData_s *)
/* 386 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 387 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 388 */ _CFFI_OP(_CFFI_OP_FUNCTION, 13), // struct BeamBeamBiGaussian2DData_s *()(struct BeamBeamBiGaussian2DData_s *)
/* 389 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 390 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 391 */ _CFFI_OP(_CFFI_OP_FUNCTION, 16), // struct BeamBeamBiGaussian3DData_s *()(struct BeamBeamBiGaussian3DData_s *)
/* 392 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 393 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 394 */ _CFFI_OP(_CFFI_OP_FUNCTION, 23), // struct BeamBeamBiGaussian3DRecordData_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 395 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 396 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 397 */ _CFFI_OP(_CFFI_OP_FUNCTION, 27), // struct BeamstrahlungTableData_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 398 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 399 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 400 */ _CFFI_OP(_CFFI_OP_FUNCTION, 27), // struct BeamstrahlungTableData_s *()(struct BeamstrahlungTableData_s *)
/* 401 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 402 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 403 */ _CFFI_OP(_CFFI_OP_FUNCTION, 31), // struct BhabhaTableData_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 404 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 405 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 406 */ _CFFI_OP(_CFFI_OP_FUNCTION, 31), // struct BhabhaTableData_s *()(struct BhabhaTableData_s *)
/* 407 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 408 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 409 */ _CFFI_OP(_CFFI_OP_FUNCTION, 35), // struct CavityData_s *()(struct CavityData_s *)
/* 410 */ _CFFI_OP(_CFFI_OP_NOOP, 35),
/* 411 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 412 */ _CFFI_OP(_CFFI_OP_FUNCTION, 38), // struct DipoleEdgeData_s *()(struct DipoleEdgeData_s *)
/* 413 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 414 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 415 */ _CFFI_OP(_CFFI_OP_FUNCTION, 41), // struct DriftData_s *()(struct DriftData_s *)
/* 416 */ _CFFI_OP(_CFFI_OP_NOOP, 41),
/* 417 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 418 */ _CFFI_OP(_CFFI_OP_FUNCTION, 264), // struct ElementRefClass_s *()(struct ArrNElementRefClass_s *, int64_t)
/* 419 */ _CFFI_OP(_CFFI_OP_NOOP, 214),
/* 420 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 421 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 422 */ _CFFI_OP(_CFFI_OP_FUNCTION, 264), // struct ElementRefClass_s *()(struct ElementRefClass_s *)
/* 423 */ _CFFI_OP(_CFFI_OP_NOOP, 264),
/* 424 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 425 */ _CFFI_OP(_CFFI_OP_FUNCTION, 264), // struct ElementRefClass_s *()(struct ElementRefData_s *, int64_t)
/* 426 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 427 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 428 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 429 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // struct ElementRefData_s *()(struct ElementRefData_s *)
/* 430 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 431 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 432 */ _CFFI_OP(_CFFI_OP_FUNCTION, 44), // struct LumiTableData_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 433 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 434 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 435 */ _CFFI_OP(_CFFI_OP_FUNCTION, 44), // struct LumiTableData_s *()(struct LumiTableData_s *)
/* 436 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 437 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 438 */ _CFFI_OP(_CFFI_OP_FUNCTION, 181), // struct MarkerData_s *()(struct MarkerData_s *)
/* 439 */ _CFFI_OP(_CFFI_OP_NOOP, 181),
/* 440 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 441 */ _CFFI_OP(_CFFI_OP_FUNCTION, 48), // struct MultipoleData_s *()(struct MultipoleData_s *)
/* 442 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 443 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 444 */ _CFFI_OP(_CFFI_OP_FUNCTION, 55), // struct ParticlesData_s *()(struct ParticlesData_s *)
/* 445 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 446 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 447 */ _CFFI_OP(_CFFI_OP_FUNCTION, 55), // struct ParticlesData_s *()(struct ParticlesMonitorData_s *)
/* 448 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 449 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 450 */ _CFFI_OP(_CFFI_OP_FUNCTION, 62), // struct ParticlesMonitorData_s *()(struct ParticlesMonitorData_s *)
/* 451 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 452 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 453 */ _CFFI_OP(_CFFI_OP_FUNCTION, 454), // struct RandomExponentialData_s *()(struct RandomExponentialData_s *)
/* 454 */ _CFFI_OP(_CFFI_OP_POINTER, 847), // struct RandomExponentialData_s *
/* 455 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 456 */ _CFFI_OP(_CFFI_OP_FUNCTION, 457), // struct RandomUniformData_s *()(struct RandomUniformData_s *)
/* 457 */ _CFFI_OP(_CFFI_OP_POINTER, 848), // struct RandomUniformData_s *
/* 458 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 459 */ _CFFI_OP(_CFFI_OP_FUNCTION, 201), // struct RecordIdentifier_s *()(struct BeamBeamBiGaussian3DData_s *)
/* 460 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 461 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 462 */ _CFFI_OP(_CFFI_OP_FUNCTION, 201), // struct RecordIdentifier_s *()(struct MultipoleData_s *)
/* 463 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 464 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 465 */ _CFFI_OP(_CFFI_OP_FUNCTION, 201), // struct RecordIdentifier_s *()(struct RecordIdentifier_s *)
/* 466 */ _CFFI_OP(_CFFI_OP_NOOP, 201),
/* 467 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 468 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 469 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 470 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 471 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct BeamstrahlungTableData_s *)
/* 472 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 473 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 474 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct BhabhaTableData_s *)
/* 475 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 476 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 477 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct LumiTableData_s *)
/* 478 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 479 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 480 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct RecordIndex_s *)
/* 481 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 482 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 483 */ _CFFI_OP(_CFFI_OP_FUNCTION, 204), // struct RecordIndex_s *()(struct SynchrotronRadiationRecordData_s *)
/* 484 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 485 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 486 */ _CFFI_OP(_CFFI_OP_FUNCTION, 69), // struct SRotationData_s *()(struct SRotationData_s *)
/* 487 */ _CFFI_OP(_CFFI_OP_NOOP, 69),
/* 488 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 489 */ _CFFI_OP(_CFFI_OP_FUNCTION, 72), // struct SynchrotronRadiationRecordData_s *()(struct SynchrotronRadiationRecordData_s *)
/* 490 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 491 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 492 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct ArrNUint32_s *, int64_t)
/* 493 */ _CFFI_OP(_CFFI_OP_NOOP, 234),
/* 494 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 495 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 496 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 497 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 498 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 499 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct BeamstrahlungTableData_s *)
/* 500 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 501 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 502 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct BhabhaTableData_s *)
/* 503 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 504 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 505 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct LumiTableData_s *)
/* 506 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 507 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 508 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct ParticlesData_s *, int64_t)
/* 509 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 510 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 511 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 512 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct ParticlesMonitorData_s *, int64_t)
/* 513 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 514 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 515 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 516 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct RecordIndex_s *)
/* 517 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 518 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 519 */ _CFFI_OP(_CFFI_OP_FUNCTION, 753), // uint32_t *()(struct SynchrotronRadiationRecordData_s *)
/* 520 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 521 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 522 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct ArrNUint32_s *, int64_t)
/* 523 */ _CFFI_OP(_CFFI_OP_NOOP, 234),
/* 524 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 525 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 526 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct BeamBeamBiGaussian3DRecordData_s *)
/* 527 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 528 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 529 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct BeamstrahlungTableData_s *)
/* 530 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 531 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 532 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct BhabhaTableData_s *)
/* 533 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 534 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 535 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct LumiTableData_s *)
/* 536 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 537 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 538 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct ParticlesData_s *, int64_t)
/* 539 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 540 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 541 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 542 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct ParticlesMonitorData_s *, int64_t)
/* 543 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 544 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 545 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 546 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct RecordIndex_s *)
/* 547 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 548 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 549 */ _CFFI_OP(_CFFI_OP_FUNCTION, 604), // uint32_t()(struct SynchrotronRadiationRecordData_s *)
/* 550 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 551 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 552 */ _CFFI_OP(_CFFI_OP_FUNCTION, 853), // uint8_t *()(struct RandomExponentialData_s *)
/* 553 */ _CFFI_OP(_CFFI_OP_NOOP, 454),
/* 554 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 555 */ _CFFI_OP(_CFFI_OP_FUNCTION, 853), // uint8_t *()(struct RandomUniformData_s *)
/* 556 */ _CFFI_OP(_CFFI_OP_NOOP, 457),
/* 557 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 558 */ _CFFI_OP(_CFFI_OP_FUNCTION, 781), // uint8_t()(struct RandomExponentialData_s *)
/* 559 */ _CFFI_OP(_CFFI_OP_NOOP, 454),
/* 560 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 561 */ _CFFI_OP(_CFFI_OP_FUNCTION, 781), // uint8_t()(struct RandomUniformData_s *)
/* 562 */ _CFFI_OP(_CFFI_OP_NOOP, 457),
/* 563 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 564 */ _CFFI_OP(_CFFI_OP_FUNCTION, 854), // void *()(struct ArrNElementRefClass_s *, int64_t)
/* 565 */ _CFFI_OP(_CFFI_OP_NOOP, 214),
/* 566 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 567 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 568 */ _CFFI_OP(_CFFI_OP_FUNCTION, 854), // void *()(struct ElementRefClass_s *)
/* 569 */ _CFFI_OP(_CFFI_OP_NOOP, 264),
/* 570 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 571 */ _CFFI_OP(_CFFI_OP_FUNCTION, 854), // void *()(struct ElementRefData_s *, int64_t)
/* 572 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 573 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 574 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 575 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(int8_t *, struct ElementRefData_s *, struct ParticlesData_s *, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, double, int8_t *, int64_t, int8_t *)
/* 576 */ _CFFI_OP(_CFFI_OP_POINTER, 826), // int8_t *
/* 577 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 578 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 579 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21), // int32_t
/* 580 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 581 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 582 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 583 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 584 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 585 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 586 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 587 */ _CFFI_OP(_CFFI_OP_NOOP, 576),
/* 588 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 589 */ _CFFI_OP(_CFFI_OP_NOOP, 576),
/* 590 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 591 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ArrNFloat64_s *, int64_t, double)
/* 592 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 593 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 594 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 595 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 596 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ArrNInt64_s *, int64_t, int64_t)
/* 597 */ _CFFI_OP(_CFFI_OP_NOOP, 143),
/* 598 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 599 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 600 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 601 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ArrNUint32_s *, int64_t, uint32_t)
/* 602 */ _CFFI_OP(_CFFI_OP_NOOP, 234),
/* 603 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 604 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22), // uint32_t
/* 605 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 606 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian2DData_s *, double)
/* 607 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 608 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 609 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 610 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DData_s *, double)
/* 611 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 612 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 613 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 614 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DData_s *, int64_t)
/* 615 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 616 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 617 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 618 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DData_s *, int64_t, double)
/* 619 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 620 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 621 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 622 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 623 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t)
/* 624 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 625 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 626 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 627 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t, double)
/* 628 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 629 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 630 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 631 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 632 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DRecordData_s *, int64_t, int64_t)
/* 633 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 634 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 635 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 636 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 637 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamBeamBiGaussian3DRecordData_s *, uint32_t)
/* 638 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 639 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 640 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 641 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamstrahlungTableData_s *, int64_t)
/* 642 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 643 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 644 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 645 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamstrahlungTableData_s *, int64_t, double)
/* 646 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 647 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 648 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 649 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 650 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamstrahlungTableData_s *, int64_t, int64_t)
/* 651 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 652 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 653 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 654 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 655 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BeamstrahlungTableData_s *, uint32_t)
/* 656 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 657 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 658 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 659 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BhabhaTableData_s *, int64_t)
/* 660 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 661 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 662 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 663 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BhabhaTableData_s *, int64_t, double)
/* 664 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 665 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 666 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 667 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 668 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BhabhaTableData_s *, int64_t, int64_t)
/* 669 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 670 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 671 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 672 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 673 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct BhabhaTableData_s *, uint32_t)
/* 674 */ _CFFI_OP(_CFFI_OP_NOOP, 31),
/* 675 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 676 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 677 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct CavityData_s *, double)
/* 678 */ _CFFI_OP(_CFFI_OP_NOOP, 35),
/* 679 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 680 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 681 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct DipoleEdgeData_s *, double)
/* 682 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 683 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 684 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 685 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct DipoleEdgeData_s *, int64_t)
/* 686 */ _CFFI_OP(_CFFI_OP_NOOP, 38),
/* 687 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 688 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 689 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct DriftData_s *, double)
/* 690 */ _CFFI_OP(_CFFI_OP_NOOP, 41),
/* 691 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 692 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 693 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct LumiTableData_s *, int64_t)
/* 694 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 695 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 696 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 697 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct LumiTableData_s *, int64_t, double)
/* 698 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 699 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 700 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 701 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 702 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct LumiTableData_s *, int64_t, int64_t)
/* 703 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 704 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 705 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 706 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 707 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct LumiTableData_s *, uint32_t)
/* 708 */ _CFFI_OP(_CFFI_OP_NOOP, 44),
/* 709 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 710 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 711 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct MarkerData_s *, int64_t)
/* 712 */ _CFFI_OP(_CFFI_OP_NOOP, 181),
/* 713 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 714 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 715 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct MultipoleData_s *, double)
/* 716 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 717 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 718 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 719 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct MultipoleData_s *, int64_t)
/* 720 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 721 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 722 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 723 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct MultipoleData_s *, int64_t, double)
/* 724 */ _CFFI_OP(_CFFI_OP_NOOP, 48),
/* 725 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 726 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 727 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 728 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, double)
/* 729 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 730 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 731 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 732 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, int64_t)
/* 733 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 734 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 735 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 736 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, int64_t, double)
/* 737 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 738 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 739 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 740 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 741 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, int64_t, int64_t)
/* 742 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 743 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 744 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 745 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 746 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, int64_t, uint32_t)
/* 747 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 748 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 749 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 750 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 751 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesData_s *, uint32_t *, int32_t)
/* 752 */ _CFFI_OP(_CFFI_OP_NOOP, 55),
/* 753 */ _CFFI_OP(_CFFI_OP_POINTER, 604), // uint32_t *
/* 754 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21),
/* 755 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 756 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesMonitorData_s *, double)
/* 757 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 758 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 759 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 760 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesMonitorData_s *, int64_t)
/* 761 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 762 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 763 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 764 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesMonitorData_s *, int64_t, double)
/* 765 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 766 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 767 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 768 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 769 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesMonitorData_s *, int64_t, int64_t)
/* 770 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 771 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 772 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 773 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 774 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct ParticlesMonitorData_s *, int64_t, uint32_t)
/* 775 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 776 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 777 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 778 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 779 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct RandomExponentialData_s *, uint8_t)
/* 780 */ _CFFI_OP(_CFFI_OP_NOOP, 454),
/* 781 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18), // uint8_t
/* 782 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 783 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct RandomUniformData_s *, uint8_t)
/* 784 */ _CFFI_OP(_CFFI_OP_NOOP, 457),
/* 785 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18),
/* 786 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 787 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct RecordIdentifier_s *, int64_t)
/* 788 */ _CFFI_OP(_CFFI_OP_NOOP, 201),
/* 789 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 790 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 791 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct RecordIndex_s *, int64_t)
/* 792 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 793 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 794 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 795 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct RecordIndex_s *, uint32_t)
/* 796 */ _CFFI_OP(_CFFI_OP_NOOP, 204),
/* 797 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 798 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 799 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct SRotationData_s *, double)
/* 800 */ _CFFI_OP(_CFFI_OP_NOOP, 69),
/* 801 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 802 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 803 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct SynchrotronRadiationRecordData_s *, int64_t)
/* 804 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 805 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 806 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 807 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct SynchrotronRadiationRecordData_s *, int64_t, double)
/* 808 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 809 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 810 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 811 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 812 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct SynchrotronRadiationRecordData_s *, int64_t, int64_t)
/* 813 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 814 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 815 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23),
/* 816 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 817 */ _CFFI_OP(_CFFI_OP_FUNCTION, 855), // void()(struct SynchrotronRadiationRecordData_s *, uint32_t)
/* 818 */ _CFFI_OP(_CFFI_OP_NOOP, 72),
/* 819 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22),
/* 820 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 821 */ _CFFI_OP(_CFFI_OP_POINTER, 822), // char *
/* 822 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 823 */ _CFFI_OP(_CFFI_OP_POINTER, 586), // double *
/* 824 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // enum ElementRefClass_e
/* 825 */ _CFFI_OP(_CFFI_OP_POINTER, 2), // int64_t *
/* 826 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 17), // int8_t
/* 827 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // struct ArrNElementRefClass_s
/* 828 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // struct ArrNFloat64_s
/* 829 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // struct ArrNInt64_s
/* 830 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // struct ArrNString_s
/* 831 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // struct ArrNUint32_s
/* 832 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // struct BeamBeamBiGaussian2DData_s
/* 833 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // struct BeamBeamBiGaussian3DData_s
/* 834 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // struct BeamBeamBiGaussian3DRecordData_s
/* 835 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 8), // struct BeamstrahlungTableData_s
/* 836 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 9), // struct BhabhaTableData_s
/* 837 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 10), // struct CavityData_s
/* 838 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 11), // struct DipoleEdgeData_s
/* 839 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 12), // struct DriftData_s
/* 840 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 13), // struct ElementRefClass_s
/* 841 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 14), // struct ElementRefData_s
/* 842 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 15), // struct LumiTableData_s
/* 843 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 16), // struct MarkerData_s
/* 844 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 17), // struct MultipoleData_s
/* 845 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 18), // struct ParticlesData_s
/* 846 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 19), // struct ParticlesMonitorData_s
/* 847 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 20), // struct RandomExponentialData_s
/* 848 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 21), // struct RandomUniformData_s
/* 849 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 22), // struct RecordIdentifier_s
/* 850 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 23), // struct RecordIndex_s
/* 851 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 24), // struct SRotationData_s
/* 852 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 25), // struct SynchrotronRadiationRecordData_s
/* 853 */ _CFFI_OP(_CFFI_OP_POINTER, 781), // uint8_t *
/* 854 */ _CFFI_OP(_CFFI_OP_POINTER, 855), // void *
/* 855 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

static int _cffi_const_ElementRefClass_BeamBeamBiGaussian2DData_t(unsigned long long *o)
{
  int n = (ElementRefClass_BeamBeamBiGaussian2DData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_BeamBeamBiGaussian2DData_t) | 0);  /* check that ElementRefClass_BeamBeamBiGaussian2DData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_BeamBeamBiGaussian3DData_t(unsigned long long *o)
{
  int n = (ElementRefClass_BeamBeamBiGaussian3DData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_BeamBeamBiGaussian3DData_t) | 0);  /* check that ElementRefClass_BeamBeamBiGaussian3DData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_CavityData_t(unsigned long long *o)
{
  int n = (ElementRefClass_CavityData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_CavityData_t) | 0);  /* check that ElementRefClass_CavityData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_DipoleEdgeData_t(unsigned long long *o)
{
  int n = (ElementRefClass_DipoleEdgeData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_DipoleEdgeData_t) | 0);  /* check that ElementRefClass_DipoleEdgeData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_DriftData_t(unsigned long long *o)
{
  int n = (ElementRefClass_DriftData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_DriftData_t) | 0);  /* check that ElementRefClass_DriftData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_MarkerData_t(unsigned long long *o)
{
  int n = (ElementRefClass_MarkerData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_MarkerData_t) | 0);  /* check that ElementRefClass_MarkerData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_MultipoleData_t(unsigned long long *o)
{
  int n = (ElementRefClass_MultipoleData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_MultipoleData_t) | 0);  /* check that ElementRefClass_MultipoleData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_ParticlesMonitorData_t(unsigned long long *o)
{
  int n = (ElementRefClass_ParticlesMonitorData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_ParticlesMonitorData_t) | 0);  /* check that ElementRefClass_ParticlesMonitorData_t is an integer */
  return n;
}

static int _cffi_const_ElementRefClass_SRotationData_t(unsigned long long *o)
{
  int n = (ElementRefClass_SRotationData_t) <= 0;
  *o = (unsigned long long)((ElementRefClass_SRotationData_t) | 0);  /* check that ElementRefClass_SRotationData_t is an integer */
  return n;
}

static struct ArrNElementRefClass_s * _cffi_d_ArrNElementRefClass_getp(struct ArrNElementRefClass_s * x0)
{
  return ArrNElementRefClass_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNElementRefClass_getp(PyObject *self, PyObject *arg0)
{
  struct ArrNElementRefClass_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNElementRefClass_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(214), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(214), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNElementRefClass_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(214));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNElementRefClass_getp _cffi_d_ArrNElementRefClass_getp
#endif

static struct ElementRefClass_s * _cffi_d_ArrNElementRefClass_getp1(struct ArrNElementRefClass_s * x0, int64_t x1)
{
  return ArrNElementRefClass_getp1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNElementRefClass_getp1(PyObject *self, PyObject *args)
{
  struct ArrNElementRefClass_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ElementRefClass_s * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNElementRefClass_getp1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(214), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(214), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNElementRefClass_getp1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(264));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNElementRefClass_getp1 _cffi_d_ArrNElementRefClass_getp1
#endif

static int64_t _cffi_d_ArrNElementRefClass_len(struct ArrNElementRefClass_s * x0)
{
  return ArrNElementRefClass_len(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNElementRefClass_len(PyObject *self, PyObject *arg0)
{
  struct ArrNElementRefClass_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(214), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(214), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNElementRefClass_len(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNElementRefClass_len _cffi_d_ArrNElementRefClass_len
#endif

static void * _cffi_d_ArrNElementRefClass_member(struct ArrNElementRefClass_s * x0, int64_t x1)
{
  return ArrNElementRefClass_member(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNElementRefClass_member(PyObject *self, PyObject *args)
{
  struct ArrNElementRefClass_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  void * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNElementRefClass_member", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(214), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(214), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNElementRefClass_member(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(854));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNElementRefClass_member _cffi_d_ArrNElementRefClass_member
#endif

static int64_t _cffi_d_ArrNElementRefClass_typeid(struct ArrNElementRefClass_s * x0, int64_t x1)
{
  return ArrNElementRefClass_typeid(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNElementRefClass_typeid(PyObject *self, PyObject *args)
{
  struct ArrNElementRefClass_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNElementRefClass_typeid", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(214), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(214), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNElementRefClass_typeid(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNElementRefClass_typeid _cffi_d_ArrNElementRefClass_typeid
#endif

static double _cffi_d_ArrNFloat64_get(struct ArrNFloat64_s * x0, int64_t x1)
{
  return ArrNFloat64_get(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNFloat64_get(PyObject *self, PyObject *args)
{
  struct ArrNFloat64_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNFloat64_get", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNFloat64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNFloat64_get(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNFloat64_get _cffi_d_ArrNFloat64_get
#endif

static struct ArrNFloat64_s * _cffi_d_ArrNFloat64_getp(struct ArrNFloat64_s * x0)
{
  return ArrNFloat64_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNFloat64_getp(PyObject *self, PyObject *arg0)
{
  struct ArrNFloat64_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNFloat64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNFloat64_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNFloat64_getp _cffi_d_ArrNFloat64_getp
#endif

static double * _cffi_d_ArrNFloat64_getp1(struct ArrNFloat64_s * x0, int64_t x1)
{
  return ArrNFloat64_getp1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNFloat64_getp1(PyObject *self, PyObject *args)
{
  struct ArrNFloat64_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNFloat64_getp1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNFloat64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNFloat64_getp1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNFloat64_getp1 _cffi_d_ArrNFloat64_getp1
#endif

static int64_t _cffi_d_ArrNFloat64_len(struct ArrNFloat64_s * x0)
{
  return ArrNFloat64_len(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNFloat64_len(PyObject *self, PyObject *arg0)
{
  struct ArrNFloat64_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNFloat64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNFloat64_len(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNFloat64_len _cffi_d_ArrNFloat64_len
#endif

static void _cffi_d_ArrNFloat64_set(struct ArrNFloat64_s * x0, int64_t x1, double x2)
{
  ArrNFloat64_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNFloat64_set(PyObject *self, PyObject *args)
{
  struct ArrNFloat64_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ArrNFloat64_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNFloat64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ArrNFloat64_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ArrNFloat64_set _cffi_d_ArrNFloat64_set
#endif

static int64_t _cffi_d_ArrNInt64_get(struct ArrNInt64_s * x0, int64_t x1)
{
  return ArrNInt64_get(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNInt64_get(PyObject *self, PyObject *args)
{
  struct ArrNInt64_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNInt64_get", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(143), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNInt64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(143), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNInt64_get(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNInt64_get _cffi_d_ArrNInt64_get
#endif

static struct ArrNInt64_s * _cffi_d_ArrNInt64_getp(struct ArrNInt64_s * x0)
{
  return ArrNInt64_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNInt64_getp(PyObject *self, PyObject *arg0)
{
  struct ArrNInt64_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(143), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNInt64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(143), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNInt64_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNInt64_getp _cffi_d_ArrNInt64_getp
#endif

static int64_t * _cffi_d_ArrNInt64_getp1(struct ArrNInt64_s * x0, int64_t x1)
{
  return ArrNInt64_getp1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNInt64_getp1(PyObject *self, PyObject *args)
{
  struct ArrNInt64_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNInt64_getp1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(143), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNInt64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(143), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNInt64_getp1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNInt64_getp1 _cffi_d_ArrNInt64_getp1
#endif

static int64_t _cffi_d_ArrNInt64_len(struct ArrNInt64_s * x0)
{
  return ArrNInt64_len(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNInt64_len(PyObject *self, PyObject *arg0)
{
  struct ArrNInt64_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(143), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNInt64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(143), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNInt64_len(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNInt64_len _cffi_d_ArrNInt64_len
#endif

static void _cffi_d_ArrNInt64_set(struct ArrNInt64_s * x0, int64_t x1, int64_t x2)
{
  ArrNInt64_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNInt64_set(PyObject *self, PyObject *args)
{
  struct ArrNInt64_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ArrNInt64_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(143), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNInt64_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(143), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ArrNInt64_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ArrNInt64_set _cffi_d_ArrNInt64_set
#endif

static struct ArrNString_s * _cffi_d_ArrNString_getp(struct ArrNString_s * x0)
{
  return ArrNString_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNString_getp(PyObject *self, PyObject *arg0)
{
  struct ArrNString_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNString_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNString_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNString_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(1));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNString_getp _cffi_d_ArrNString_getp
#endif

static char * _cffi_d_ArrNString_getp1(struct ArrNString_s * x0, int64_t x1)
{
  return ArrNString_getp1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNString_getp1(PyObject *self, PyObject *args)
{
  struct ArrNString_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  char * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNString_getp1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNString_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNString_getp1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(821));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNString_getp1 _cffi_d_ArrNString_getp1
#endif

static int64_t _cffi_d_ArrNString_len(struct ArrNString_s * x0)
{
  return ArrNString_len(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNString_len(PyObject *self, PyObject *arg0)
{
  struct ArrNString_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNString_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNString_len(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNString_len _cffi_d_ArrNString_len
#endif

static uint32_t _cffi_d_ArrNUint32_get(struct ArrNUint32_s * x0, int64_t x1)
{
  return ArrNUint32_get(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNUint32_get(PyObject *self, PyObject *args)
{
  struct ArrNUint32_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNUint32_get", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(234), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNUint32_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(234), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNUint32_get(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNUint32_get _cffi_d_ArrNUint32_get
#endif

static struct ArrNUint32_s * _cffi_d_ArrNUint32_getp(struct ArrNUint32_s * x0)
{
  return ArrNUint32_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNUint32_getp(PyObject *self, PyObject *arg0)
{
  struct ArrNUint32_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(234), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNUint32_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(234), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNUint32_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNUint32_getp _cffi_d_ArrNUint32_getp
#endif

static uint32_t * _cffi_d_ArrNUint32_getp1(struct ArrNUint32_s * x0, int64_t x1)
{
  return ArrNUint32_getp1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNUint32_getp1(PyObject *self, PyObject *args)
{
  struct ArrNUint32_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ArrNUint32_getp1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(234), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNUint32_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(234), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNUint32_getp1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNUint32_getp1 _cffi_d_ArrNUint32_getp1
#endif

static int64_t _cffi_d_ArrNUint32_len(struct ArrNUint32_s * x0)
{
  return ArrNUint32_len(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNUint32_len(PyObject *self, PyObject *arg0)
{
  struct ArrNUint32_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(234), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNUint32_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(234), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ArrNUint32_len(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ArrNUint32_len _cffi_d_ArrNUint32_len
#endif

static void _cffi_d_ArrNUint32_set(struct ArrNUint32_s * x0, int64_t x1, uint32_t x2)
{
  ArrNUint32_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ArrNUint32_set(PyObject *self, PyObject *args)
{
  struct ArrNUint32_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ArrNUint32_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(234), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ArrNUint32_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(234), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ArrNUint32_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ArrNUint32_set _cffi_d_ArrNUint32_set
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_min_sigma_diff(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_min_sigma_diff(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_min_sigma_diff(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_min_sigma_diff(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_min_sigma_diff _cffi_d_BeamBeamBiGaussian2DData_get_min_sigma_diff
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_Sigma_11(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11 _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_Sigma_13(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13 _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_Sigma_33(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33 _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_beta0(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_beta0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_beta0 _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_beta0
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_num_particles(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_num_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_num_particles(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_num_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_num_particles _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_num_particles
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_q0(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_q0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_q0 _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_q0
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_x(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_x _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_x
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_y(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_other_beam_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_other_beam_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_y _cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_y
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_px(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_post_subtract_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_post_subtract_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_px _cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_px
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_py(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_post_subtract_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_post_subtract_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_py _cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_py
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_x(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_ref_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_ref_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_x _cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_x
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_y(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_ref_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_ref_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_y _cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_y
#endif

static double _cffi_d_BeamBeamBiGaussian2DData_get_scale_strength(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_get_scale_strength(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_get_scale_strength(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_get_scale_strength(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_get_scale_strength _cffi_d_BeamBeamBiGaussian2DData_get_scale_strength
#endif

static struct BeamBeamBiGaussian2DData_s * _cffi_d_BeamBeamBiGaussian2DData_getp(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BeamBeamBiGaussian2DData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(13));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp _cffi_d_BeamBeamBiGaussian2DData_getp
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_min_sigma_diff(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_min_sigma_diff(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_min_sigma_diff(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_min_sigma_diff(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_min_sigma_diff _cffi_d_BeamBeamBiGaussian2DData_getp_min_sigma_diff
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11 _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13 _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33 _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_beta0(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_beta0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_beta0 _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_beta0
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_num_particles(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_num_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_num_particles(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_num_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_num_particles _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_num_particles
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_q0(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_q0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_q0 _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_q0
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_x(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_x _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_x
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_y(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_other_beam_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_other_beam_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_y _cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_y
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_px(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_post_subtract_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_post_subtract_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_px _cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_px
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_py(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_post_subtract_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_post_subtract_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_py _cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_py
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_x(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_ref_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_ref_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_x _cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_x
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_y(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_ref_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_ref_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_y _cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_y
#endif

static double * _cffi_d_BeamBeamBiGaussian2DData_getp_scale_strength(struct BeamBeamBiGaussian2DData_s * x0)
{
  return BeamBeamBiGaussian2DData_getp_scale_strength(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_getp_scale_strength(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian2DData_getp_scale_strength(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_getp_scale_strength _cffi_d_BeamBeamBiGaussian2DData_getp_scale_strength
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_min_sigma_diff(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_min_sigma_diff(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_min_sigma_diff(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_min_sigma_diff", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_min_sigma_diff(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_min_sigma_diff _cffi_d_BeamBeamBiGaussian2DData_set_min_sigma_diff
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_Sigma_11(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_Sigma_11", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_Sigma_11(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11 _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_Sigma_13(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_Sigma_13", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_Sigma_13(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13 _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_Sigma_33(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_Sigma_33", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_Sigma_33(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33 _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_beta0(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_beta0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_beta0(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_beta0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_beta0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_beta0 _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_beta0
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_num_particles(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_num_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_num_particles(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_num_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_num_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_num_particles _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_num_particles
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_q0(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_q0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_q0(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_q0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_q0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_q0 _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_q0
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_x(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_shift_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_x(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_shift_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_shift_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_x _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_x
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_y(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_other_beam_shift_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_y(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_other_beam_shift_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_other_beam_shift_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_y _cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_y
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_px(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_post_subtract_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_post_subtract_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_post_subtract_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_px _cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_px
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_py(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_post_subtract_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_post_subtract_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_post_subtract_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_py _cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_py
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_x(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_ref_shift_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_x(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_ref_shift_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_ref_shift_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_x _cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_x
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_y(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_ref_shift_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_y(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_ref_shift_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_ref_shift_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_y _cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_y
#endif

static void _cffi_d_BeamBeamBiGaussian2DData_set_scale_strength(struct BeamBeamBiGaussian2DData_s * x0, double x1)
{
  BeamBeamBiGaussian2DData_set_scale_strength(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian2DData_set_scale_strength(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian2DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian2DData_set_scale_strength", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian2DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian2DData_set_scale_strength(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian2DData_set_scale_strength _cffi_d_BeamBeamBiGaussian2DData_set_scale_strength
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get__cos_alpha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__cos_alpha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__cos_alpha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__cos_alpha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__cos_alpha _cffi_d_BeamBeamBiGaussian3DData_get__cos_alpha
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get__cos_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__cos_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__cos_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__cos_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__cos_phi _cffi_d_BeamBeamBiGaussian3DData_get__cos_phi
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id _cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_offset(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__internal_record_id_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_offset(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__internal_record_id_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_offset _cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_offset
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get__sin_alpha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__sin_alpha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__sin_alpha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__sin_alpha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__sin_alpha _cffi_d_BeamBeamBiGaussian3DData_get__sin_alpha
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get__sin_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__sin_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__sin_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__sin_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__sin_phi _cffi_d_BeamBeamBiGaussian3DData_get__sin_phi
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get__tan_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get__tan_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get__tan_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get__tan_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get__tan_phi _cffi_d_BeamBeamBiGaussian3DData_get__tan_phi
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_compt_x_min(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_compt_x_min(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_compt_x_min(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_compt_x_min(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_compt_x_min _cffi_d_BeamBeamBiGaussian3DData_get_compt_x_min
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get_flag_beamsize_effect(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_flag_beamsize_effect(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_flag_beamsize_effect(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_flag_beamsize_effect(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_flag_beamsize_effect _cffi_d_BeamBeamBiGaussian3DData_get_flag_beamsize_effect
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get_flag_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_flag_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_flag_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_flag_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_flag_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_get_flag_beamstrahlung
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get_flag_bhabha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_flag_bhabha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_flag_bhabha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_flag_bhabha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_flag_bhabha _cffi_d_BeamBeamBiGaussian3DData_get_flag_bhabha
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get_flag_luminosity(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_flag_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_flag_luminosity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_flag_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_flag_luminosity _cffi_d_BeamBeamBiGaussian3DData_get_flag_luminosity
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_min_sigma_diff(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_min_sigma_diff(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_min_sigma_diff(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_min_sigma_diff(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_min_sigma_diff _cffi_d_BeamBeamBiGaussian3DData_get_min_sigma_diff
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_get_num_slices_other_beam(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_num_slices_other_beam(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_num_slices_other_beam(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_num_slices_other_beam(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_num_slices_other_beam _cffi_d_BeamBeamBiGaussian3DData_get_num_slices_other_beam
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_q0(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_q0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_q0 _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_q0
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_px _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_px
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_py _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_py
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_x _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_x
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_y _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_y
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_other_beam_shift_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_px _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_px
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_py _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_py
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_pzeta _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_pzeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_x _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_x
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_y _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_y
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_post_subtract_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_post_subtract_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_zeta _cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_zeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_px _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_px
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_py _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_py
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_pzeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_x _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_x
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_y _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_y
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_ref_shift_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_ref_shift_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_zeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_scale_strength(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_scale_strength(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_scale_strength(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_scale_strength(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_scale_strength _cffi_d_BeamBeamBiGaussian3DData_get_scale_strength
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star _cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star
#endif

static double _cffi_d_BeamBeamBiGaussian3DData_get_threshold_singular(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_get_threshold_singular(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_get_threshold_singular(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_get_threshold_singular(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_get_threshold_singular _cffi_d_BeamBeamBiGaussian3DData_get_threshold_singular
#endif

static struct BeamBeamBiGaussian3DData_s * _cffi_d_BeamBeamBiGaussian3DData_getp(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BeamBeamBiGaussian3DData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(16));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp _cffi_d_BeamBeamBiGaussian3DData_getp
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star _cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp__cos_alpha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__cos_alpha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__cos_alpha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__cos_alpha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__cos_alpha _cffi_d_BeamBeamBiGaussian3DData_getp__cos_alpha
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp__cos_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__cos_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__cos_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__cos_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__cos_phi _cffi_d_BeamBeamBiGaussian3DData_getp__cos_phi
#endif

static struct RecordIdentifier_s * _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__internal_record_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIdentifier_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__internal_record_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(201));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_offset(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__internal_record_id_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_offset(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__internal_record_id_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_offset _cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_offset
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp__sin_alpha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__sin_alpha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__sin_alpha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__sin_alpha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__sin_alpha _cffi_d_BeamBeamBiGaussian3DData_getp__sin_alpha
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp__sin_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__sin_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__sin_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__sin_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__sin_phi _cffi_d_BeamBeamBiGaussian3DData_getp__sin_phi
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp__tan_phi(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp__tan_phi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp__tan_phi(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp__tan_phi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp__tan_phi _cffi_d_BeamBeamBiGaussian3DData_getp__tan_phi
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_compt_x_min(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_compt_x_min(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_compt_x_min(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_compt_x_min(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_compt_x_min _cffi_d_BeamBeamBiGaussian3DData_getp_compt_x_min
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_flag_beamsize_effect(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_flag_beamsize_effect(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect _cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_flag_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_flag_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp_flag_bhabha(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_flag_bhabha(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_flag_bhabha(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_flag_bhabha(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_flag_bhabha _cffi_d_BeamBeamBiGaussian3DData_getp_flag_bhabha
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp_flag_luminosity(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_flag_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_flag_luminosity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_flag_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_flag_luminosity _cffi_d_BeamBeamBiGaussian3DData_getp_flag_luminosity
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_min_sigma_diff(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_min_sigma_diff(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_min_sigma_diff(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_min_sigma_diff(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_min_sigma_diff _cffi_d_BeamBeamBiGaussian3DData_getp_min_sigma_diff
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DData_getp_num_slices_other_beam(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_num_slices_other_beam(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_num_slices_other_beam(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_num_slices_other_beam(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_num_slices_other_beam _cffi_d_BeamBeamBiGaussian3DData_getp_num_slices_other_beam
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_q0(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_q0(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_q0 _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_q0
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_px _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_px
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_py _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_py
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_x _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_x
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_y _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_y
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_px _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_px
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_py _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_py
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_x _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_x
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_y _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_y
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_post_subtract_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_post_subtract_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_zeta _cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_zeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_px(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_px _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_px
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_py(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_py _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_py
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_x(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_x(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_x _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_x
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_y(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_y(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_y _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_y
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_ref_shift_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_zeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_ref_shift_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_zeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_scale_strength(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_scale_strength(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_scale_strength(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_scale_strength(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_scale_strength _cffi_d_BeamBeamBiGaussian3DData_getp_scale_strength
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star _cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star
#endif

static double * _cffi_d_BeamBeamBiGaussian3DData_getp_threshold_singular(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_getp_threshold_singular(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_getp_threshold_singular(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_getp_threshold_singular(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_getp_threshold_singular _cffi_d_BeamBeamBiGaussian3DData_getp_threshold_singular
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star(struct BeamBeamBiGaussian3DData_s * x0)
{
  return BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star _cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__cos_alpha(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set__cos_alpha(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__cos_alpha(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__cos_alpha", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__cos_alpha(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__cos_alpha _cffi_d_BeamBeamBiGaussian3DData_set__cos_alpha
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__cos_phi(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set__cos_phi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__cos_phi(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__cos_phi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__cos_phi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__cos_phi _cffi_d_BeamBeamBiGaussian3DData_set__cos_phi
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id _cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_offset(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set__internal_record_id_offset(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_offset(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__internal_record_id_offset", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__internal_record_id_offset(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_offset _cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_offset
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__sin_alpha(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set__sin_alpha(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__sin_alpha(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__sin_alpha", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__sin_alpha(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__sin_alpha _cffi_d_BeamBeamBiGaussian3DData_set__sin_alpha
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__sin_phi(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set__sin_phi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__sin_phi(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__sin_phi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__sin_phi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__sin_phi _cffi_d_BeamBeamBiGaussian3DData_set__sin_phi
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set__tan_phi(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set__tan_phi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set__tan_phi(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set__tan_phi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set__tan_phi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set__tan_phi _cffi_d_BeamBeamBiGaussian3DData_set__tan_phi
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_compt_x_min(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_compt_x_min(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_compt_x_min(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_compt_x_min", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_compt_x_min(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_compt_x_min _cffi_d_BeamBeamBiGaussian3DData_set_compt_x_min
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_flag_beamsize_effect(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set_flag_beamsize_effect(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_flag_beamsize_effect(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_flag_beamsize_effect", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_flag_beamsize_effect(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_flag_beamsize_effect _cffi_d_BeamBeamBiGaussian3DData_set_flag_beamsize_effect
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_flag_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set_flag_beamstrahlung(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_flag_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_flag_beamstrahlung", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_flag_beamstrahlung(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_flag_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_set_flag_beamstrahlung
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_flag_bhabha(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set_flag_bhabha(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_flag_bhabha(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_flag_bhabha", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_flag_bhabha(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_flag_bhabha _cffi_d_BeamBeamBiGaussian3DData_set_flag_bhabha
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_flag_luminosity(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set_flag_luminosity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_flag_luminosity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_flag_luminosity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_flag_luminosity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_flag_luminosity _cffi_d_BeamBeamBiGaussian3DData_set_flag_luminosity
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_min_sigma_diff(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_min_sigma_diff(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_min_sigma_diff(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_min_sigma_diff", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_min_sigma_diff(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_min_sigma_diff _cffi_d_BeamBeamBiGaussian3DData_set_min_sigma_diff
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_num_slices_other_beam(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DData_set_num_slices_other_beam(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_num_slices_other_beam(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_num_slices_other_beam", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_num_slices_other_beam(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_num_slices_other_beam _cffi_d_BeamBeamBiGaussian3DData_set_num_slices_other_beam
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_q0(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_q0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_q0(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_q0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_q0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_q0 _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_q0
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_px(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_px _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_px
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_py(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_py _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_py
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_x(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_x(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_x _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_x
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_y(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_y(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_y _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_y
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_other_beam_shift_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_other_beam_shift_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_other_beam_shift_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_px(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_px _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_px
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_py(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_py _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_py
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_pzeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_pzeta _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_pzeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_x(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_x(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_x _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_x
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_y(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_y(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_y _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_y
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_zeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_post_subtract_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_zeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_post_subtract_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_post_subtract_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_zeta _cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_zeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_px(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_px _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_px
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_py(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_py _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_py
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_pzeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_pzeta _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_pzeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_x(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_x(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_x _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_x
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_y(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_y(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_y _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_y
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_zeta(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_ref_shift_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_zeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_ref_shift_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_ref_shift_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_zeta _cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_zeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_scale_strength(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_scale_strength(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_scale_strength(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_scale_strength", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_scale_strength(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_scale_strength _cffi_d_BeamBeamBiGaussian3DData_set_scale_strength
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star(struct BeamBeamBiGaussian3DData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star _cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star
#endif

static void _cffi_d_BeamBeamBiGaussian3DData_set_threshold_singular(struct BeamBeamBiGaussian3DData_s * x0, double x1)
{
  BeamBeamBiGaussian3DData_set_threshold_singular(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DData_set_threshold_singular(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DData_set_threshold_singular", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(16), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DData_set_threshold_singular(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DData_set_threshold_singular _cffi_d_BeamBeamBiGaussian3DData_set_threshold_singular
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv _cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g _cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity
#endif

static uint32_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_lumitable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn
#endif

static double _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id
#endif

static struct BeamBeamBiGaussian3DRecordData_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BeamBeamBiGaussian3DRecordData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(23));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp _cffi_d_BeamBeamBiGaussian3DRecordData_getp
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn
#endif

static double * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  return BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id
#endif

static struct BeamstrahlungTableData_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BeamstrahlungTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(27));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable
#endif

static struct RecordIndex_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv _cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv
#endif

static struct BhabhaTableData_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BhabhaTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(31));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable
#endif

static struct RecordIndex_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g _cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g
#endif

static struct LumiTableData_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct LumiTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(44));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable
#endif

static struct RecordIndex_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id
#endif

static int64_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity
#endif

static uint32_t * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity
#endif

static struct ArrNInt64_s * _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv _cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g _cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_lumitable_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_lumitable_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity
#endif

static int64_t _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0)
{
  return BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv _cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g _cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded(struct BeamBeamBiGaussian3DRecordData_s * x0, uint32_t x1)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, double x2)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity
#endif

static void _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id(struct BeamBeamBiGaussian3DRecordData_s * x0, int64_t x1, int64_t x2)
{
  BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id(PyObject *self, PyObject *args)
{
  struct BeamBeamBiGaussian3DRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamBeamBiGaussian3DRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(23), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id _cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id
#endif

static uint32_t _cffi_d_BeamstrahlungTableData_get__index__dummy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_get__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get__index__dummy _cffi_d_BeamstrahlungTableData_get__index__dummy
#endif

static int64_t _cffi_d_BeamstrahlungTableData_get__index_buffer_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_get__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get__index_buffer_id _cffi_d_BeamstrahlungTableData_get__index_buffer_id
#endif

static int64_t _cffi_d_BeamstrahlungTableData_get__index_capacity(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_get__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get__index_capacity _cffi_d_BeamstrahlungTableData_get__index_capacity
#endif

static uint32_t _cffi_d_BeamstrahlungTableData_get__index_num_recorded(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_get__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get__index_num_recorded _cffi_d_BeamstrahlungTableData_get__index_num_recorded
#endif

static int64_t _cffi_d_BeamstrahlungTableData_get_at_element(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_at_element(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_at_element _cffi_d_BeamstrahlungTableData_get_at_element
#endif

static int64_t _cffi_d_BeamstrahlungTableData_get_at_turn(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_at_turn(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_at_turn _cffi_d_BeamstrahlungTableData_get_at_turn
#endif

static double _cffi_d_BeamstrahlungTableData_get_delta_avg(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_delta_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_delta_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_delta_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_delta_avg _cffi_d_BeamstrahlungTableData_get_delta_avg
#endif

static double _cffi_d_BeamstrahlungTableData_get_n_avg(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_n_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_n_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_n_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_n_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_n_avg _cffi_d_BeamstrahlungTableData_get_n_avg
#endif

static int64_t _cffi_d_BeamstrahlungTableData_get_particle_id(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_particle_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_particle_id _cffi_d_BeamstrahlungTableData_get_particle_id
#endif

static double _cffi_d_BeamstrahlungTableData_get_photon_critical_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_photon_critical_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_photon_critical_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_photon_critical_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_photon_critical_energy _cffi_d_BeamstrahlungTableData_get_photon_critical_energy
#endif

static double _cffi_d_BeamstrahlungTableData_get_photon_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_photon_energy _cffi_d_BeamstrahlungTableData_get_photon_energy
#endif

static double _cffi_d_BeamstrahlungTableData_get_photon_id(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_photon_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_photon_id _cffi_d_BeamstrahlungTableData_get_photon_id
#endif

static double _cffi_d_BeamstrahlungTableData_get_primary_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_primary_energy _cffi_d_BeamstrahlungTableData_get_primary_energy
#endif

static double _cffi_d_BeamstrahlungTableData_get_rho_inv(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_get_rho_inv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_get_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_get_rho_inv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_get_rho_inv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_get_rho_inv _cffi_d_BeamstrahlungTableData_get_rho_inv
#endif

static struct BeamstrahlungTableData_s * _cffi_d_BeamstrahlungTableData_getp(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BeamstrahlungTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(27));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp _cffi_d_BeamstrahlungTableData_getp
#endif

static int64_t * _cffi_d_BeamstrahlungTableData_getp1_at_element(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_at_element(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_at_element _cffi_d_BeamstrahlungTableData_getp1_at_element
#endif

static int64_t * _cffi_d_BeamstrahlungTableData_getp1_at_turn(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_at_turn(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_at_turn _cffi_d_BeamstrahlungTableData_getp1_at_turn
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_delta_avg(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_delta_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_delta_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_delta_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_delta_avg _cffi_d_BeamstrahlungTableData_getp1_delta_avg
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_n_avg(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_n_avg(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_n_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_n_avg", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_n_avg(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_n_avg _cffi_d_BeamstrahlungTableData_getp1_n_avg
#endif

static int64_t * _cffi_d_BeamstrahlungTableData_getp1_particle_id(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_particle_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_particle_id _cffi_d_BeamstrahlungTableData_getp1_particle_id
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_photon_critical_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_photon_critical_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_photon_critical_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_photon_critical_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_photon_critical_energy _cffi_d_BeamstrahlungTableData_getp1_photon_critical_energy
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_photon_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_photon_energy _cffi_d_BeamstrahlungTableData_getp1_photon_energy
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_photon_id(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_photon_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_photon_id _cffi_d_BeamstrahlungTableData_getp1_photon_id
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_primary_energy(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_primary_energy _cffi_d_BeamstrahlungTableData_getp1_primary_energy
#endif

static double * _cffi_d_BeamstrahlungTableData_getp1_rho_inv(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  return BeamstrahlungTableData_getp1_rho_inv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp1_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_getp1_rho_inv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp1_rho_inv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp1_rho_inv _cffi_d_BeamstrahlungTableData_getp1_rho_inv
#endif

static struct RecordIndex_s * _cffi_d_BeamstrahlungTableData_getp__index(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp__index(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp__index _cffi_d_BeamstrahlungTableData_getp__index
#endif

static uint32_t * _cffi_d_BeamstrahlungTableData_getp__index__dummy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp__index__dummy _cffi_d_BeamstrahlungTableData_getp__index__dummy
#endif

static int64_t * _cffi_d_BeamstrahlungTableData_getp__index_buffer_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp__index_buffer_id _cffi_d_BeamstrahlungTableData_getp__index_buffer_id
#endif

static int64_t * _cffi_d_BeamstrahlungTableData_getp__index_capacity(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp__index_capacity _cffi_d_BeamstrahlungTableData_getp__index_capacity
#endif

static uint32_t * _cffi_d_BeamstrahlungTableData_getp__index_num_recorded(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp__index_num_recorded _cffi_d_BeamstrahlungTableData_getp__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_BeamstrahlungTableData_getp_at_element(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_at_element _cffi_d_BeamstrahlungTableData_getp_at_element
#endif

static struct ArrNInt64_s * _cffi_d_BeamstrahlungTableData_getp_at_turn(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_at_turn _cffi_d_BeamstrahlungTableData_getp_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_delta_avg(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_delta_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_delta_avg(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_delta_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_delta_avg _cffi_d_BeamstrahlungTableData_getp_delta_avg
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_n_avg(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_n_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_n_avg(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_n_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_n_avg _cffi_d_BeamstrahlungTableData_getp_n_avg
#endif

static struct ArrNInt64_s * _cffi_d_BeamstrahlungTableData_getp_particle_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_particle_id _cffi_d_BeamstrahlungTableData_getp_particle_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_photon_critical_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_photon_critical_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_photon_critical_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_photon_critical_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_photon_critical_energy _cffi_d_BeamstrahlungTableData_getp_photon_critical_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_photon_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_photon_energy _cffi_d_BeamstrahlungTableData_getp_photon_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_photon_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_photon_id _cffi_d_BeamstrahlungTableData_getp_photon_id
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_primary_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_primary_energy _cffi_d_BeamstrahlungTableData_getp_primary_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BeamstrahlungTableData_getp_rho_inv(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_getp_rho_inv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_getp_rho_inv(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_getp_rho_inv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_getp_rho_inv _cffi_d_BeamstrahlungTableData_getp_rho_inv
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_at_element(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_at_element(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_at_element _cffi_d_BeamstrahlungTableData_len_at_element
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_at_turn(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_at_turn(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_at_turn _cffi_d_BeamstrahlungTableData_len_at_turn
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_delta_avg(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_delta_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_delta_avg(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_delta_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_delta_avg _cffi_d_BeamstrahlungTableData_len_delta_avg
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_n_avg(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_n_avg(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_n_avg(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_n_avg(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_n_avg _cffi_d_BeamstrahlungTableData_len_n_avg
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_particle_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_particle_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_particle_id _cffi_d_BeamstrahlungTableData_len_particle_id
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_photon_critical_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_photon_critical_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_photon_critical_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_photon_critical_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_photon_critical_energy _cffi_d_BeamstrahlungTableData_len_photon_critical_energy
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_photon_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_photon_energy _cffi_d_BeamstrahlungTableData_len_photon_energy
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_photon_id(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_photon_id(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_photon_id _cffi_d_BeamstrahlungTableData_len_photon_id
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_primary_energy(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_primary_energy _cffi_d_BeamstrahlungTableData_len_primary_energy
#endif

static int64_t _cffi_d_BeamstrahlungTableData_len_rho_inv(struct BeamstrahlungTableData_s * x0)
{
  return BeamstrahlungTableData_len_rho_inv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_len_rho_inv(PyObject *self, PyObject *arg0)
{
  struct BeamstrahlungTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BeamstrahlungTableData_len_rho_inv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BeamstrahlungTableData_len_rho_inv _cffi_d_BeamstrahlungTableData_len_rho_inv
#endif

static void _cffi_d_BeamstrahlungTableData_set__index__dummy(struct BeamstrahlungTableData_s * x0, uint32_t x1)
{
  BeamstrahlungTableData_set__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set__index__dummy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set__index__dummy _cffi_d_BeamstrahlungTableData_set__index__dummy
#endif

static void _cffi_d_BeamstrahlungTableData_set__index_buffer_id(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  BeamstrahlungTableData_set__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set__index_buffer_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set__index_buffer_id _cffi_d_BeamstrahlungTableData_set__index_buffer_id
#endif

static void _cffi_d_BeamstrahlungTableData_set__index_capacity(struct BeamstrahlungTableData_s * x0, int64_t x1)
{
  BeamstrahlungTableData_set__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set__index_capacity(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set__index_capacity _cffi_d_BeamstrahlungTableData_set__index_capacity
#endif

static void _cffi_d_BeamstrahlungTableData_set__index_num_recorded(struct BeamstrahlungTableData_s * x0, uint32_t x1)
{
  BeamstrahlungTableData_set__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set__index_num_recorded(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set__index_num_recorded _cffi_d_BeamstrahlungTableData_set__index_num_recorded
#endif

static void _cffi_d_BeamstrahlungTableData_set_at_element(struct BeamstrahlungTableData_s * x0, int64_t x1, int64_t x2)
{
  BeamstrahlungTableData_set_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_at_element(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_at_element _cffi_d_BeamstrahlungTableData_set_at_element
#endif

static void _cffi_d_BeamstrahlungTableData_set_at_turn(struct BeamstrahlungTableData_s * x0, int64_t x1, int64_t x2)
{
  BeamstrahlungTableData_set_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_at_turn(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_at_turn _cffi_d_BeamstrahlungTableData_set_at_turn
#endif

static void _cffi_d_BeamstrahlungTableData_set_delta_avg(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_delta_avg(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_delta_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_delta_avg", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_delta_avg(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_delta_avg _cffi_d_BeamstrahlungTableData_set_delta_avg
#endif

static void _cffi_d_BeamstrahlungTableData_set_n_avg(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_n_avg(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_n_avg(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_n_avg", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_n_avg(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_n_avg _cffi_d_BeamstrahlungTableData_set_n_avg
#endif

static void _cffi_d_BeamstrahlungTableData_set_particle_id(struct BeamstrahlungTableData_s * x0, int64_t x1, int64_t x2)
{
  BeamstrahlungTableData_set_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_particle_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_particle_id _cffi_d_BeamstrahlungTableData_set_particle_id
#endif

static void _cffi_d_BeamstrahlungTableData_set_photon_critical_energy(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_photon_critical_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_photon_critical_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_photon_critical_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_photon_critical_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_photon_critical_energy _cffi_d_BeamstrahlungTableData_set_photon_critical_energy
#endif

static void _cffi_d_BeamstrahlungTableData_set_photon_energy(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_photon_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_photon_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_photon_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_photon_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_photon_energy _cffi_d_BeamstrahlungTableData_set_photon_energy
#endif

static void _cffi_d_BeamstrahlungTableData_set_photon_id(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_photon_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_photon_id(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_photon_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_photon_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_photon_id _cffi_d_BeamstrahlungTableData_set_photon_id
#endif

static void _cffi_d_BeamstrahlungTableData_set_primary_energy(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_primary_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_primary_energy(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_primary_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_primary_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_primary_energy _cffi_d_BeamstrahlungTableData_set_primary_energy
#endif

static void _cffi_d_BeamstrahlungTableData_set_rho_inv(struct BeamstrahlungTableData_s * x0, int64_t x1, double x2)
{
  BeamstrahlungTableData_set_rho_inv(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BeamstrahlungTableData_set_rho_inv(PyObject *self, PyObject *args)
{
  struct BeamstrahlungTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BeamstrahlungTableData_set_rho_inv", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BeamstrahlungTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BeamstrahlungTableData_set_rho_inv(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BeamstrahlungTableData_set_rho_inv _cffi_d_BeamstrahlungTableData_set_rho_inv
#endif

static uint32_t _cffi_d_BhabhaTableData_get__index__dummy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_get__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get__index__dummy _cffi_d_BhabhaTableData_get__index__dummy
#endif

static int64_t _cffi_d_BhabhaTableData_get__index_buffer_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_get__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get__index_buffer_id _cffi_d_BhabhaTableData_get__index_buffer_id
#endif

static int64_t _cffi_d_BhabhaTableData_get__index_capacity(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_get__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get__index_capacity _cffi_d_BhabhaTableData_get__index_capacity
#endif

static uint32_t _cffi_d_BhabhaTableData_get__index_num_recorded(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_get__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get__index_num_recorded _cffi_d_BhabhaTableData_get__index_num_recorded
#endif

static int64_t _cffi_d_BhabhaTableData_get_at_element(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_at_element(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_at_element _cffi_d_BhabhaTableData_get_at_element
#endif

static int64_t _cffi_d_BhabhaTableData_get_at_turn(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_at_turn(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_at_turn _cffi_d_BhabhaTableData_get_at_turn
#endif

static int64_t _cffi_d_BhabhaTableData_get_particle_id(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_particle_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_particle_id _cffi_d_BhabhaTableData_get_particle_id
#endif

static double _cffi_d_BhabhaTableData_get_photon_energy(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_photon_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_photon_energy _cffi_d_BhabhaTableData_get_photon_energy
#endif

static int64_t _cffi_d_BhabhaTableData_get_photon_id(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_photon_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_photon_id _cffi_d_BhabhaTableData_get_photon_id
#endif

static double _cffi_d_BhabhaTableData_get_photon_px(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_photon_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_photon_px(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_photon_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_photon_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_photon_px _cffi_d_BhabhaTableData_get_photon_px
#endif

static double _cffi_d_BhabhaTableData_get_photon_py(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_photon_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_photon_py(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_photon_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_photon_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_photon_py _cffi_d_BhabhaTableData_get_photon_py
#endif

static double _cffi_d_BhabhaTableData_get_photon_pzeta(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_photon_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_photon_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_photon_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_photon_pzeta _cffi_d_BhabhaTableData_get_photon_pzeta
#endif

static double _cffi_d_BhabhaTableData_get_primary_energy(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_primary_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_primary_energy _cffi_d_BhabhaTableData_get_primary_energy
#endif

static double _cffi_d_BhabhaTableData_get_theta_e(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_theta_e(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_theta_e(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_theta_e", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_theta_e(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_theta_e _cffi_d_BhabhaTableData_get_theta_e
#endif

static double _cffi_d_BhabhaTableData_get_theta_g(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_get_theta_g(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_get_theta_g(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_get_theta_g", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_get_theta_g(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_get_theta_g _cffi_d_BhabhaTableData_get_theta_g
#endif

static struct BhabhaTableData_s * _cffi_d_BhabhaTableData_getp(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct BhabhaTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(31));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp _cffi_d_BhabhaTableData_getp
#endif

static int64_t * _cffi_d_BhabhaTableData_getp1_at_element(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_at_element(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_at_element _cffi_d_BhabhaTableData_getp1_at_element
#endif

static int64_t * _cffi_d_BhabhaTableData_getp1_at_turn(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_at_turn(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_at_turn _cffi_d_BhabhaTableData_getp1_at_turn
#endif

static int64_t * _cffi_d_BhabhaTableData_getp1_particle_id(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_particle_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_particle_id _cffi_d_BhabhaTableData_getp1_particle_id
#endif

static double * _cffi_d_BhabhaTableData_getp1_photon_energy(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_photon_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_photon_energy _cffi_d_BhabhaTableData_getp1_photon_energy
#endif

static int64_t * _cffi_d_BhabhaTableData_getp1_photon_id(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_photon_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_photon_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_photon_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_photon_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_photon_id _cffi_d_BhabhaTableData_getp1_photon_id
#endif

static double * _cffi_d_BhabhaTableData_getp1_photon_px(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_photon_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_photon_px(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_photon_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_photon_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_photon_px _cffi_d_BhabhaTableData_getp1_photon_px
#endif

static double * _cffi_d_BhabhaTableData_getp1_photon_py(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_photon_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_photon_py(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_photon_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_photon_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_photon_py _cffi_d_BhabhaTableData_getp1_photon_py
#endif

static double * _cffi_d_BhabhaTableData_getp1_photon_pzeta(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_photon_pzeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_photon_pzeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_photon_pzeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_photon_pzeta _cffi_d_BhabhaTableData_getp1_photon_pzeta
#endif

static double * _cffi_d_BhabhaTableData_getp1_primary_energy(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_primary_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_primary_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_primary_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_primary_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_primary_energy _cffi_d_BhabhaTableData_getp1_primary_energy
#endif

static double * _cffi_d_BhabhaTableData_getp1_theta_e(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_theta_e(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_theta_e(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_theta_e", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_theta_e(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_theta_e _cffi_d_BhabhaTableData_getp1_theta_e
#endif

static double * _cffi_d_BhabhaTableData_getp1_theta_g(struct BhabhaTableData_s * x0, int64_t x1)
{
  return BhabhaTableData_getp1_theta_g(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp1_theta_g(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_getp1_theta_g", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp1_theta_g(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp1_theta_g _cffi_d_BhabhaTableData_getp1_theta_g
#endif

static struct RecordIndex_s * _cffi_d_BhabhaTableData_getp__index(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp__index(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp__index _cffi_d_BhabhaTableData_getp__index
#endif

static uint32_t * _cffi_d_BhabhaTableData_getp__index__dummy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp__index__dummy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp__index__dummy _cffi_d_BhabhaTableData_getp__index__dummy
#endif

static int64_t * _cffi_d_BhabhaTableData_getp__index_buffer_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp__index_buffer_id _cffi_d_BhabhaTableData_getp__index_buffer_id
#endif

static int64_t * _cffi_d_BhabhaTableData_getp__index_capacity(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp__index_capacity(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp__index_capacity _cffi_d_BhabhaTableData_getp__index_capacity
#endif

static uint32_t * _cffi_d_BhabhaTableData_getp__index_num_recorded(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp__index_num_recorded _cffi_d_BhabhaTableData_getp__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_BhabhaTableData_getp_at_element(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_at_element(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_at_element _cffi_d_BhabhaTableData_getp_at_element
#endif

static struct ArrNInt64_s * _cffi_d_BhabhaTableData_getp_at_turn(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_at_turn(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_at_turn _cffi_d_BhabhaTableData_getp_at_turn
#endif

static struct ArrNInt64_s * _cffi_d_BhabhaTableData_getp_particle_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_particle_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_particle_id _cffi_d_BhabhaTableData_getp_particle_id
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_photon_energy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_photon_energy _cffi_d_BhabhaTableData_getp_photon_energy
#endif

static struct ArrNInt64_s * _cffi_d_BhabhaTableData_getp_photon_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_photon_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_photon_id _cffi_d_BhabhaTableData_getp_photon_id
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_photon_px(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_photon_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_photon_px(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_photon_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_photon_px _cffi_d_BhabhaTableData_getp_photon_px
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_photon_py(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_photon_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_photon_py(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_photon_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_photon_py _cffi_d_BhabhaTableData_getp_photon_py
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_photon_pzeta(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_photon_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_photon_pzeta(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_photon_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_photon_pzeta _cffi_d_BhabhaTableData_getp_photon_pzeta
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_primary_energy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_primary_energy _cffi_d_BhabhaTableData_getp_primary_energy
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_theta_e(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_theta_e(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_theta_e(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_theta_e(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_theta_e _cffi_d_BhabhaTableData_getp_theta_e
#endif

static struct ArrNFloat64_s * _cffi_d_BhabhaTableData_getp_theta_g(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_getp_theta_g(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_getp_theta_g(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_getp_theta_g(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_getp_theta_g _cffi_d_BhabhaTableData_getp_theta_g
#endif

static int64_t _cffi_d_BhabhaTableData_len_at_element(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_at_element(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_at_element _cffi_d_BhabhaTableData_len_at_element
#endif

static int64_t _cffi_d_BhabhaTableData_len_at_turn(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_at_turn(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_at_turn _cffi_d_BhabhaTableData_len_at_turn
#endif

static int64_t _cffi_d_BhabhaTableData_len_particle_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_particle_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_particle_id _cffi_d_BhabhaTableData_len_particle_id
#endif

static int64_t _cffi_d_BhabhaTableData_len_photon_energy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_photon_energy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_photon_energy _cffi_d_BhabhaTableData_len_photon_energy
#endif

static int64_t _cffi_d_BhabhaTableData_len_photon_id(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_photon_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_photon_id(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_photon_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_photon_id _cffi_d_BhabhaTableData_len_photon_id
#endif

static int64_t _cffi_d_BhabhaTableData_len_photon_px(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_photon_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_photon_px(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_photon_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_photon_px _cffi_d_BhabhaTableData_len_photon_px
#endif

static int64_t _cffi_d_BhabhaTableData_len_photon_py(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_photon_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_photon_py(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_photon_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_photon_py _cffi_d_BhabhaTableData_len_photon_py
#endif

static int64_t _cffi_d_BhabhaTableData_len_photon_pzeta(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_photon_pzeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_photon_pzeta(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_photon_pzeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_photon_pzeta _cffi_d_BhabhaTableData_len_photon_pzeta
#endif

static int64_t _cffi_d_BhabhaTableData_len_primary_energy(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_primary_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_primary_energy(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_primary_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_primary_energy _cffi_d_BhabhaTableData_len_primary_energy
#endif

static int64_t _cffi_d_BhabhaTableData_len_theta_e(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_theta_e(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_theta_e(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_theta_e(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_theta_e _cffi_d_BhabhaTableData_len_theta_e
#endif

static int64_t _cffi_d_BhabhaTableData_len_theta_g(struct BhabhaTableData_s * x0)
{
  return BhabhaTableData_len_theta_g(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_len_theta_g(PyObject *self, PyObject *arg0)
{
  struct BhabhaTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = BhabhaTableData_len_theta_g(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_BhabhaTableData_len_theta_g _cffi_d_BhabhaTableData_len_theta_g
#endif

static void _cffi_d_BhabhaTableData_set__index__dummy(struct BhabhaTableData_s * x0, uint32_t x1)
{
  BhabhaTableData_set__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set__index__dummy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set__index__dummy _cffi_d_BhabhaTableData_set__index__dummy
#endif

static void _cffi_d_BhabhaTableData_set__index_buffer_id(struct BhabhaTableData_s * x0, int64_t x1)
{
  BhabhaTableData_set__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set__index_buffer_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set__index_buffer_id _cffi_d_BhabhaTableData_set__index_buffer_id
#endif

static void _cffi_d_BhabhaTableData_set__index_capacity(struct BhabhaTableData_s * x0, int64_t x1)
{
  BhabhaTableData_set__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set__index_capacity(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set__index_capacity _cffi_d_BhabhaTableData_set__index_capacity
#endif

static void _cffi_d_BhabhaTableData_set__index_num_recorded(struct BhabhaTableData_s * x0, uint32_t x1)
{
  BhabhaTableData_set__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set__index_num_recorded(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set__index_num_recorded _cffi_d_BhabhaTableData_set__index_num_recorded
#endif

static void _cffi_d_BhabhaTableData_set_at_element(struct BhabhaTableData_s * x0, int64_t x1, int64_t x2)
{
  BhabhaTableData_set_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_at_element(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_at_element _cffi_d_BhabhaTableData_set_at_element
#endif

static void _cffi_d_BhabhaTableData_set_at_turn(struct BhabhaTableData_s * x0, int64_t x1, int64_t x2)
{
  BhabhaTableData_set_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_at_turn(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_at_turn _cffi_d_BhabhaTableData_set_at_turn
#endif

static void _cffi_d_BhabhaTableData_set_particle_id(struct BhabhaTableData_s * x0, int64_t x1, int64_t x2)
{
  BhabhaTableData_set_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_particle_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_particle_id _cffi_d_BhabhaTableData_set_particle_id
#endif

static void _cffi_d_BhabhaTableData_set_photon_energy(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_photon_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_photon_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_photon_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_photon_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_photon_energy _cffi_d_BhabhaTableData_set_photon_energy
#endif

static void _cffi_d_BhabhaTableData_set_photon_id(struct BhabhaTableData_s * x0, int64_t x1, int64_t x2)
{
  BhabhaTableData_set_photon_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_photon_id(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_photon_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_photon_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_photon_id _cffi_d_BhabhaTableData_set_photon_id
#endif

static void _cffi_d_BhabhaTableData_set_photon_px(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_photon_px(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_photon_px(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_photon_px", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_photon_px(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_photon_px _cffi_d_BhabhaTableData_set_photon_px
#endif

static void _cffi_d_BhabhaTableData_set_photon_py(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_photon_py(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_photon_py(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_photon_py", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_photon_py(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_photon_py _cffi_d_BhabhaTableData_set_photon_py
#endif

static void _cffi_d_BhabhaTableData_set_photon_pzeta(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_photon_pzeta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_photon_pzeta(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_photon_pzeta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_photon_pzeta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_photon_pzeta _cffi_d_BhabhaTableData_set_photon_pzeta
#endif

static void _cffi_d_BhabhaTableData_set_primary_energy(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_primary_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_primary_energy(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_primary_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_primary_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_primary_energy _cffi_d_BhabhaTableData_set_primary_energy
#endif

static void _cffi_d_BhabhaTableData_set_theta_e(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_theta_e(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_theta_e(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_theta_e", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_theta_e(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_theta_e _cffi_d_BhabhaTableData_set_theta_e
#endif

static void _cffi_d_BhabhaTableData_set_theta_g(struct BhabhaTableData_s * x0, int64_t x1, double x2)
{
  BhabhaTableData_set_theta_g(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_BhabhaTableData_set_theta_g(PyObject *self, PyObject *args)
{
  struct BhabhaTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "BhabhaTableData_set_theta_g", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(31), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct BhabhaTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(31), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { BhabhaTableData_set_theta_g(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_BhabhaTableData_set_theta_g _cffi_d_BhabhaTableData_set_theta_g
#endif

static double _cffi_d_CavityData_get_frequency(struct CavityData_s * x0)
{
  return CavityData_get_frequency(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_get_frequency(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_get_frequency(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_get_frequency _cffi_d_CavityData_get_frequency
#endif

static double _cffi_d_CavityData_get_lag(struct CavityData_s * x0)
{
  return CavityData_get_lag(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_get_lag(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_get_lag(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_get_lag _cffi_d_CavityData_get_lag
#endif

static double _cffi_d_CavityData_get_lag_taper(struct CavityData_s * x0)
{
  return CavityData_get_lag_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_get_lag_taper(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_get_lag_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_get_lag_taper _cffi_d_CavityData_get_lag_taper
#endif

static double _cffi_d_CavityData_get_voltage(struct CavityData_s * x0)
{
  return CavityData_get_voltage(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_get_voltage(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_get_voltage(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_get_voltage _cffi_d_CavityData_get_voltage
#endif

static struct CavityData_s * _cffi_d_CavityData_getp(struct CavityData_s * x0)
{
  return CavityData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_getp(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct CavityData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(35));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_getp _cffi_d_CavityData_getp
#endif

static double * _cffi_d_CavityData_getp_frequency(struct CavityData_s * x0)
{
  return CavityData_getp_frequency(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_getp_frequency(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_getp_frequency(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_getp_frequency _cffi_d_CavityData_getp_frequency
#endif

static double * _cffi_d_CavityData_getp_lag(struct CavityData_s * x0)
{
  return CavityData_getp_lag(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_getp_lag(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_getp_lag(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_getp_lag _cffi_d_CavityData_getp_lag
#endif

static double * _cffi_d_CavityData_getp_lag_taper(struct CavityData_s * x0)
{
  return CavityData_getp_lag_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_getp_lag_taper(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_getp_lag_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_getp_lag_taper _cffi_d_CavityData_getp_lag_taper
#endif

static double * _cffi_d_CavityData_getp_voltage(struct CavityData_s * x0)
{
  return CavityData_getp_voltage(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_getp_voltage(PyObject *self, PyObject *arg0)
{
  struct CavityData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CavityData_getp_voltage(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_CavityData_getp_voltage _cffi_d_CavityData_getp_voltage
#endif

static void _cffi_d_CavityData_set_frequency(struct CavityData_s * x0, double x1)
{
  CavityData_set_frequency(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_set_frequency(PyObject *self, PyObject *args)
{
  struct CavityData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CavityData_set_frequency", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CavityData_set_frequency(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CavityData_set_frequency _cffi_d_CavityData_set_frequency
#endif

static void _cffi_d_CavityData_set_lag(struct CavityData_s * x0, double x1)
{
  CavityData_set_lag(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_set_lag(PyObject *self, PyObject *args)
{
  struct CavityData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CavityData_set_lag", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CavityData_set_lag(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CavityData_set_lag _cffi_d_CavityData_set_lag
#endif

static void _cffi_d_CavityData_set_lag_taper(struct CavityData_s * x0, double x1)
{
  CavityData_set_lag_taper(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_set_lag_taper(PyObject *self, PyObject *args)
{
  struct CavityData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CavityData_set_lag_taper", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CavityData_set_lag_taper(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CavityData_set_lag_taper _cffi_d_CavityData_set_lag_taper
#endif

static void _cffi_d_CavityData_set_voltage(struct CavityData_s * x0, double x1)
{
  CavityData_set_voltage(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CavityData_set_voltage(PyObject *self, PyObject *args)
{
  struct CavityData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CavityData_set_voltage", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(35), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct CavityData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(35), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CavityData_set_voltage(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CavityData_set_voltage _cffi_d_CavityData_set_voltage
#endif

static double _cffi_d_DipoleEdgeData_get_delta_taper(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_delta_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_delta_taper(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_delta_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_delta_taper _cffi_d_DipoleEdgeData_get_delta_taper
#endif

static double _cffi_d_DipoleEdgeData_get_e1(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_e1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_e1(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_e1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_e1 _cffi_d_DipoleEdgeData_get_e1
#endif

static double _cffi_d_DipoleEdgeData_get_e1_fd(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_e1_fd(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_e1_fd(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_e1_fd(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_e1_fd _cffi_d_DipoleEdgeData_get_e1_fd
#endif

static double _cffi_d_DipoleEdgeData_get_fint(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_fint(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_fint(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_fint(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_fint _cffi_d_DipoleEdgeData_get_fint
#endif

static double _cffi_d_DipoleEdgeData_get_hgap(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_hgap(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_hgap(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_hgap(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_hgap _cffi_d_DipoleEdgeData_get_hgap
#endif

static double _cffi_d_DipoleEdgeData_get_k(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_k(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_k(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_k(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_k _cffi_d_DipoleEdgeData_get_k
#endif

static int64_t _cffi_d_DipoleEdgeData_get_model(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_model(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_model(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_model(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_model _cffi_d_DipoleEdgeData_get_model
#endif

static double _cffi_d_DipoleEdgeData_get_r21(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_r21(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_r21(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_r21(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_r21 _cffi_d_DipoleEdgeData_get_r21
#endif

static double _cffi_d_DipoleEdgeData_get_r43(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_r43(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_r43(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_r43(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_r43 _cffi_d_DipoleEdgeData_get_r43
#endif

static int64_t _cffi_d_DipoleEdgeData_get_side(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_get_side(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_get_side(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_get_side(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_get_side _cffi_d_DipoleEdgeData_get_side
#endif

static struct DipoleEdgeData_s * _cffi_d_DipoleEdgeData_getp(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct DipoleEdgeData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(38));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp _cffi_d_DipoleEdgeData_getp
#endif

static double * _cffi_d_DipoleEdgeData_getp_delta_taper(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_delta_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_delta_taper(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_delta_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_delta_taper _cffi_d_DipoleEdgeData_getp_delta_taper
#endif

static double * _cffi_d_DipoleEdgeData_getp_e1(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_e1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_e1(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_e1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_e1 _cffi_d_DipoleEdgeData_getp_e1
#endif

static double * _cffi_d_DipoleEdgeData_getp_e1_fd(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_e1_fd(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_e1_fd(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_e1_fd(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_e1_fd _cffi_d_DipoleEdgeData_getp_e1_fd
#endif

static double * _cffi_d_DipoleEdgeData_getp_fint(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_fint(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_fint(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_fint(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_fint _cffi_d_DipoleEdgeData_getp_fint
#endif

static double * _cffi_d_DipoleEdgeData_getp_hgap(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_hgap(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_hgap(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_hgap(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_hgap _cffi_d_DipoleEdgeData_getp_hgap
#endif

static double * _cffi_d_DipoleEdgeData_getp_k(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_k(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_k(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_k(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_k _cffi_d_DipoleEdgeData_getp_k
#endif

static int64_t * _cffi_d_DipoleEdgeData_getp_model(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_model(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_model(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_model(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_model _cffi_d_DipoleEdgeData_getp_model
#endif

static double * _cffi_d_DipoleEdgeData_getp_r21(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_r21(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_r21(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_r21(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_r21 _cffi_d_DipoleEdgeData_getp_r21
#endif

static double * _cffi_d_DipoleEdgeData_getp_r43(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_r43(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_r43(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_r43(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_r43 _cffi_d_DipoleEdgeData_getp_r43
#endif

static int64_t * _cffi_d_DipoleEdgeData_getp_side(struct DipoleEdgeData_s * x0)
{
  return DipoleEdgeData_getp_side(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_getp_side(PyObject *self, PyObject *arg0)
{
  struct DipoleEdgeData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DipoleEdgeData_getp_side(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DipoleEdgeData_getp_side _cffi_d_DipoleEdgeData_getp_side
#endif

static void _cffi_d_DipoleEdgeData_set_delta_taper(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_delta_taper(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_delta_taper(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_delta_taper", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_delta_taper(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_delta_taper _cffi_d_DipoleEdgeData_set_delta_taper
#endif

static void _cffi_d_DipoleEdgeData_set_e1(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_e1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_e1(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_e1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_e1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_e1 _cffi_d_DipoleEdgeData_set_e1
#endif

static void _cffi_d_DipoleEdgeData_set_e1_fd(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_e1_fd(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_e1_fd(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_e1_fd", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_e1_fd(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_e1_fd _cffi_d_DipoleEdgeData_set_e1_fd
#endif

static void _cffi_d_DipoleEdgeData_set_fint(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_fint(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_fint(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_fint", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_fint(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_fint _cffi_d_DipoleEdgeData_set_fint
#endif

static void _cffi_d_DipoleEdgeData_set_hgap(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_hgap(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_hgap(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_hgap", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_hgap(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_hgap _cffi_d_DipoleEdgeData_set_hgap
#endif

static void _cffi_d_DipoleEdgeData_set_k(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_k(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_k(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_k", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_k(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_k _cffi_d_DipoleEdgeData_set_k
#endif

static void _cffi_d_DipoleEdgeData_set_model(struct DipoleEdgeData_s * x0, int64_t x1)
{
  DipoleEdgeData_set_model(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_model(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_model", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_model(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_model _cffi_d_DipoleEdgeData_set_model
#endif

static void _cffi_d_DipoleEdgeData_set_r21(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_r21(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_r21(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_r21", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_r21(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_r21 _cffi_d_DipoleEdgeData_set_r21
#endif

static void _cffi_d_DipoleEdgeData_set_r43(struct DipoleEdgeData_s * x0, double x1)
{
  DipoleEdgeData_set_r43(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_r43(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_r43", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_r43(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_r43 _cffi_d_DipoleEdgeData_set_r43
#endif

static void _cffi_d_DipoleEdgeData_set_side(struct DipoleEdgeData_s * x0, int64_t x1)
{
  DipoleEdgeData_set_side(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DipoleEdgeData_set_side(PyObject *self, PyObject *args)
{
  struct DipoleEdgeData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DipoleEdgeData_set_side", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(38), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DipoleEdgeData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(38), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DipoleEdgeData_set_side(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DipoleEdgeData_set_side _cffi_d_DipoleEdgeData_set_side
#endif

static double _cffi_d_DriftData_get_length(struct DriftData_s * x0)
{
  return DriftData_get_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DriftData_get_length(PyObject *self, PyObject *arg0)
{
  struct DriftData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(41), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DriftData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(41), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DriftData_get_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DriftData_get_length _cffi_d_DriftData_get_length
#endif

static struct DriftData_s * _cffi_d_DriftData_getp(struct DriftData_s * x0)
{
  return DriftData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DriftData_getp(PyObject *self, PyObject *arg0)
{
  struct DriftData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct DriftData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(41), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DriftData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(41), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DriftData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(41));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DriftData_getp _cffi_d_DriftData_getp
#endif

static double * _cffi_d_DriftData_getp_length(struct DriftData_s * x0)
{
  return DriftData_getp_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DriftData_getp_length(PyObject *self, PyObject *arg0)
{
  struct DriftData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(41), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DriftData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(41), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = DriftData_getp_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_DriftData_getp_length _cffi_d_DriftData_getp_length
#endif

static void _cffi_d_DriftData_set_length(struct DriftData_s * x0, double x1)
{
  DriftData_set_length(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_DriftData_set_length(PyObject *self, PyObject *args)
{
  struct DriftData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "DriftData_set_length", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(41), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct DriftData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(41), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { DriftData_set_length(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_DriftData_set_length _cffi_d_DriftData_set_length
#endif

static struct ElementRefClass_s * _cffi_d_ElementRefClass_getp(struct ElementRefClass_s * x0)
{
  return ElementRefClass_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefClass_getp(PyObject *self, PyObject *arg0)
{
  struct ElementRefClass_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ElementRefClass_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(264), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(264), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefClass_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(264));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefClass_getp _cffi_d_ElementRefClass_getp
#endif

static void * _cffi_d_ElementRefClass_member(struct ElementRefClass_s * x0)
{
  return ElementRefClass_member(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefClass_member(PyObject *self, PyObject *arg0)
{
  struct ElementRefClass_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  void * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(264), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(264), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefClass_member(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(854));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefClass_member _cffi_d_ElementRefClass_member
#endif

static int64_t _cffi_d_ElementRefClass_typeid(struct ElementRefClass_s * x0)
{
  return ElementRefClass_typeid(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefClass_typeid(PyObject *self, PyObject *arg0)
{
  struct ElementRefClass_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(264), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefClass_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(264), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefClass_typeid(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefClass_typeid _cffi_d_ElementRefClass_typeid
#endif

static struct ElementRefData_s * _cffi_d_ElementRefData_getp(struct ElementRefData_s * x0)
{
  return ElementRefData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_getp(PyObject *self, PyObject *arg0)
{
  struct ElementRefData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ElementRefData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(5));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_getp _cffi_d_ElementRefData_getp
#endif

static struct ElementRefClass_s * _cffi_d_ElementRefData_getp1_elements(struct ElementRefData_s * x0, int64_t x1)
{
  return ElementRefData_getp1_elements(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_getp1_elements(PyObject *self, PyObject *args)
{
  struct ElementRefData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ElementRefClass_s * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ElementRefData_getp1_elements", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_getp1_elements(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(264));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_getp1_elements _cffi_d_ElementRefData_getp1_elements
#endif

static char * _cffi_d_ElementRefData_getp1_names(struct ElementRefData_s * x0, int64_t x1)
{
  return ElementRefData_getp1_names(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_getp1_names(PyObject *self, PyObject *args)
{
  struct ElementRefData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  char * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ElementRefData_getp1_names", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_getp1_names(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(821));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_getp1_names _cffi_d_ElementRefData_getp1_names
#endif

static struct ArrNElementRefClass_s * _cffi_d_ElementRefData_getp_elements(struct ElementRefData_s * x0)
{
  return ElementRefData_getp_elements(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_getp_elements(PyObject *self, PyObject *arg0)
{
  struct ElementRefData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNElementRefClass_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_getp_elements(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(214));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_getp_elements _cffi_d_ElementRefData_getp_elements
#endif

static struct ArrNString_s * _cffi_d_ElementRefData_getp_names(struct ElementRefData_s * x0)
{
  return ElementRefData_getp_names(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_getp_names(PyObject *self, PyObject *arg0)
{
  struct ElementRefData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNString_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_getp_names(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(1));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_getp_names _cffi_d_ElementRefData_getp_names
#endif

static int64_t _cffi_d_ElementRefData_len_elements(struct ElementRefData_s * x0)
{
  return ElementRefData_len_elements(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_len_elements(PyObject *self, PyObject *arg0)
{
  struct ElementRefData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_len_elements(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_len_elements _cffi_d_ElementRefData_len_elements
#endif

static int64_t _cffi_d_ElementRefData_len_names(struct ElementRefData_s * x0)
{
  return ElementRefData_len_names(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_len_names(PyObject *self, PyObject *arg0)
{
  struct ElementRefData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_len_names(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_len_names _cffi_d_ElementRefData_len_names
#endif

static void * _cffi_d_ElementRefData_member_elements(struct ElementRefData_s * x0, int64_t x1)
{
  return ElementRefData_member_elements(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_member_elements(PyObject *self, PyObject *args)
{
  struct ElementRefData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  void * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ElementRefData_member_elements", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_member_elements(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(854));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_member_elements _cffi_d_ElementRefData_member_elements
#endif

static int64_t _cffi_d_ElementRefData_typeid_elements(struct ElementRefData_s * x0, int64_t x1)
{
  return ElementRefData_typeid_elements(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ElementRefData_typeid_elements(PyObject *self, PyObject *args)
{
  struct ElementRefData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ElementRefData_typeid_elements", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ElementRefData_typeid_elements(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ElementRefData_typeid_elements _cffi_d_ElementRefData_typeid_elements
#endif

static uint32_t _cffi_d_LumiTableData_get__index__dummy(struct LumiTableData_s * x0)
{
  return LumiTableData_get__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get__index__dummy(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get__index__dummy _cffi_d_LumiTableData_get__index__dummy
#endif

static int64_t _cffi_d_LumiTableData_get__index_buffer_id(struct LumiTableData_s * x0)
{
  return LumiTableData_get__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get__index_buffer_id _cffi_d_LumiTableData_get__index_buffer_id
#endif

static int64_t _cffi_d_LumiTableData_get__index_capacity(struct LumiTableData_s * x0)
{
  return LumiTableData_get__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get__index_capacity(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get__index_capacity _cffi_d_LumiTableData_get__index_capacity
#endif

static uint32_t _cffi_d_LumiTableData_get__index_num_recorded(struct LumiTableData_s * x0)
{
  return LumiTableData_get__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get__index_num_recorded _cffi_d_LumiTableData_get__index_num_recorded
#endif

static int64_t _cffi_d_LumiTableData_get_at_element(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_get_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get_at_element(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_get_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get_at_element _cffi_d_LumiTableData_get_at_element
#endif

static int64_t _cffi_d_LumiTableData_get_at_turn(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_get_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get_at_turn(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_get_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get_at_turn _cffi_d_LumiTableData_get_at_turn
#endif

static double _cffi_d_LumiTableData_get_luminosity(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_get_luminosity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get_luminosity(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_get_luminosity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get_luminosity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get_luminosity _cffi_d_LumiTableData_get_luminosity
#endif

static int64_t _cffi_d_LumiTableData_get_particle_id(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_get_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_get_particle_id(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_get_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_get_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_get_particle_id _cffi_d_LumiTableData_get_particle_id
#endif

static struct LumiTableData_s * _cffi_d_LumiTableData_getp(struct LumiTableData_s * x0)
{
  return LumiTableData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct LumiTableData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(44));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp _cffi_d_LumiTableData_getp
#endif

static int64_t * _cffi_d_LumiTableData_getp1_at_element(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_getp1_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp1_at_element(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_getp1_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp1_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp1_at_element _cffi_d_LumiTableData_getp1_at_element
#endif

static int64_t * _cffi_d_LumiTableData_getp1_at_turn(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_getp1_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp1_at_turn(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_getp1_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp1_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp1_at_turn _cffi_d_LumiTableData_getp1_at_turn
#endif

static double * _cffi_d_LumiTableData_getp1_luminosity(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_getp1_luminosity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp1_luminosity(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_getp1_luminosity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp1_luminosity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp1_luminosity _cffi_d_LumiTableData_getp1_luminosity
#endif

static int64_t * _cffi_d_LumiTableData_getp1_particle_id(struct LumiTableData_s * x0, int64_t x1)
{
  return LumiTableData_getp1_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp1_particle_id(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_getp1_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp1_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp1_particle_id _cffi_d_LumiTableData_getp1_particle_id
#endif

static struct RecordIndex_s * _cffi_d_LumiTableData_getp__index(struct LumiTableData_s * x0)
{
  return LumiTableData_getp__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp__index(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp__index _cffi_d_LumiTableData_getp__index
#endif

static uint32_t * _cffi_d_LumiTableData_getp__index__dummy(struct LumiTableData_s * x0)
{
  return LumiTableData_getp__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp__index__dummy(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp__index__dummy _cffi_d_LumiTableData_getp__index__dummy
#endif

static int64_t * _cffi_d_LumiTableData_getp__index_buffer_id(struct LumiTableData_s * x0)
{
  return LumiTableData_getp__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp__index_buffer_id _cffi_d_LumiTableData_getp__index_buffer_id
#endif

static int64_t * _cffi_d_LumiTableData_getp__index_capacity(struct LumiTableData_s * x0)
{
  return LumiTableData_getp__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp__index_capacity(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp__index_capacity _cffi_d_LumiTableData_getp__index_capacity
#endif

static uint32_t * _cffi_d_LumiTableData_getp__index_num_recorded(struct LumiTableData_s * x0)
{
  return LumiTableData_getp__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp__index_num_recorded _cffi_d_LumiTableData_getp__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_LumiTableData_getp_at_element(struct LumiTableData_s * x0)
{
  return LumiTableData_getp_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp_at_element(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp_at_element _cffi_d_LumiTableData_getp_at_element
#endif

static struct ArrNInt64_s * _cffi_d_LumiTableData_getp_at_turn(struct LumiTableData_s * x0)
{
  return LumiTableData_getp_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp_at_turn(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp_at_turn _cffi_d_LumiTableData_getp_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_LumiTableData_getp_luminosity(struct LumiTableData_s * x0)
{
  return LumiTableData_getp_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp_luminosity(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp_luminosity _cffi_d_LumiTableData_getp_luminosity
#endif

static struct ArrNInt64_s * _cffi_d_LumiTableData_getp_particle_id(struct LumiTableData_s * x0)
{
  return LumiTableData_getp_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_getp_particle_id(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_getp_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_getp_particle_id _cffi_d_LumiTableData_getp_particle_id
#endif

static int64_t _cffi_d_LumiTableData_len_at_element(struct LumiTableData_s * x0)
{
  return LumiTableData_len_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_len_at_element(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_len_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_len_at_element _cffi_d_LumiTableData_len_at_element
#endif

static int64_t _cffi_d_LumiTableData_len_at_turn(struct LumiTableData_s * x0)
{
  return LumiTableData_len_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_len_at_turn(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_len_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_len_at_turn _cffi_d_LumiTableData_len_at_turn
#endif

static int64_t _cffi_d_LumiTableData_len_luminosity(struct LumiTableData_s * x0)
{
  return LumiTableData_len_luminosity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_len_luminosity(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_len_luminosity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_len_luminosity _cffi_d_LumiTableData_len_luminosity
#endif

static int64_t _cffi_d_LumiTableData_len_particle_id(struct LumiTableData_s * x0)
{
  return LumiTableData_len_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_len_particle_id(PyObject *self, PyObject *arg0)
{
  struct LumiTableData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = LumiTableData_len_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_LumiTableData_len_particle_id _cffi_d_LumiTableData_len_particle_id
#endif

static void _cffi_d_LumiTableData_set__index__dummy(struct LumiTableData_s * x0, uint32_t x1)
{
  LumiTableData_set__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set__index__dummy(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set__index__dummy _cffi_d_LumiTableData_set__index__dummy
#endif

static void _cffi_d_LumiTableData_set__index_buffer_id(struct LumiTableData_s * x0, int64_t x1)
{
  LumiTableData_set__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set__index_buffer_id(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set__index_buffer_id _cffi_d_LumiTableData_set__index_buffer_id
#endif

static void _cffi_d_LumiTableData_set__index_capacity(struct LumiTableData_s * x0, int64_t x1)
{
  LumiTableData_set__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set__index_capacity(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set__index_capacity _cffi_d_LumiTableData_set__index_capacity
#endif

static void _cffi_d_LumiTableData_set__index_num_recorded(struct LumiTableData_s * x0, uint32_t x1)
{
  LumiTableData_set__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set__index_num_recorded(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set__index_num_recorded _cffi_d_LumiTableData_set__index_num_recorded
#endif

static void _cffi_d_LumiTableData_set_at_element(struct LumiTableData_s * x0, int64_t x1, int64_t x2)
{
  LumiTableData_set_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set_at_element(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set_at_element _cffi_d_LumiTableData_set_at_element
#endif

static void _cffi_d_LumiTableData_set_at_turn(struct LumiTableData_s * x0, int64_t x1, int64_t x2)
{
  LumiTableData_set_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set_at_turn(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set_at_turn _cffi_d_LumiTableData_set_at_turn
#endif

static void _cffi_d_LumiTableData_set_luminosity(struct LumiTableData_s * x0, int64_t x1, double x2)
{
  LumiTableData_set_luminosity(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set_luminosity(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set_luminosity", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set_luminosity(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set_luminosity _cffi_d_LumiTableData_set_luminosity
#endif

static void _cffi_d_LumiTableData_set_particle_id(struct LumiTableData_s * x0, int64_t x1, int64_t x2)
{
  LumiTableData_set_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_LumiTableData_set_particle_id(PyObject *self, PyObject *args)
{
  struct LumiTableData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "LumiTableData_set_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct LumiTableData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(44), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { LumiTableData_set_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_LumiTableData_set_particle_id _cffi_d_LumiTableData_set_particle_id
#endif

static int64_t _cffi_d_MarkerData_get__dummy(struct MarkerData_s * x0)
{
  return MarkerData_get__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MarkerData_get__dummy(PyObject *self, PyObject *arg0)
{
  struct MarkerData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(181), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MarkerData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(181), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MarkerData_get__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MarkerData_get__dummy _cffi_d_MarkerData_get__dummy
#endif

static struct MarkerData_s * _cffi_d_MarkerData_getp(struct MarkerData_s * x0)
{
  return MarkerData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MarkerData_getp(PyObject *self, PyObject *arg0)
{
  struct MarkerData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct MarkerData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(181), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MarkerData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(181), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MarkerData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(181));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MarkerData_getp _cffi_d_MarkerData_getp
#endif

static int64_t * _cffi_d_MarkerData_getp__dummy(struct MarkerData_s * x0)
{
  return MarkerData_getp__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MarkerData_getp__dummy(PyObject *self, PyObject *arg0)
{
  struct MarkerData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(181), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MarkerData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(181), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MarkerData_getp__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MarkerData_getp__dummy _cffi_d_MarkerData_getp__dummy
#endif

static void _cffi_d_MarkerData_set__dummy(struct MarkerData_s * x0, int64_t x1)
{
  MarkerData_set__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MarkerData_set__dummy(PyObject *self, PyObject *args)
{
  struct MarkerData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MarkerData_set__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(181), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MarkerData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(181), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MarkerData_set__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MarkerData_set__dummy _cffi_d_MarkerData_set__dummy
#endif

static int64_t _cffi_d_MultipoleData_get__internal_record_id_buffer_id(struct MultipoleData_s * x0)
{
  return MultipoleData_get__internal_record_id_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get__internal_record_id_buffer_id(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get__internal_record_id_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get__internal_record_id_buffer_id _cffi_d_MultipoleData_get__internal_record_id_buffer_id
#endif

static int64_t _cffi_d_MultipoleData_get__internal_record_id_offset(struct MultipoleData_s * x0)
{
  return MultipoleData_get__internal_record_id_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get__internal_record_id_offset(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get__internal_record_id_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get__internal_record_id_offset _cffi_d_MultipoleData_get__internal_record_id_offset
#endif

static double _cffi_d_MultipoleData_get_delta_taper(struct MultipoleData_s * x0)
{
  return MultipoleData_get_delta_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_delta_taper(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_delta_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_delta_taper _cffi_d_MultipoleData_get_delta_taper
#endif

static double _cffi_d_MultipoleData_get_hxl(struct MultipoleData_s * x0)
{
  return MultipoleData_get_hxl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_hxl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_hxl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_hxl _cffi_d_MultipoleData_get_hxl
#endif

static double _cffi_d_MultipoleData_get_hyl(struct MultipoleData_s * x0)
{
  return MultipoleData_get_hyl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_hyl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_hyl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_hyl _cffi_d_MultipoleData_get_hyl
#endif

static double _cffi_d_MultipoleData_get_inv_factorial_order(struct MultipoleData_s * x0)
{
  return MultipoleData_get_inv_factorial_order(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_inv_factorial_order(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_inv_factorial_order(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_inv_factorial_order _cffi_d_MultipoleData_get_inv_factorial_order
#endif

static double _cffi_d_MultipoleData_get_knl(struct MultipoleData_s * x0, int64_t x1)
{
  return MultipoleData_get_knl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_knl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_get_knl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_knl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_knl _cffi_d_MultipoleData_get_knl
#endif

static double _cffi_d_MultipoleData_get_ksl(struct MultipoleData_s * x0, int64_t x1)
{
  return MultipoleData_get_ksl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_ksl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_get_ksl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_ksl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_ksl _cffi_d_MultipoleData_get_ksl
#endif

static double _cffi_d_MultipoleData_get_length(struct MultipoleData_s * x0)
{
  return MultipoleData_get_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_length(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_length _cffi_d_MultipoleData_get_length
#endif

static int64_t _cffi_d_MultipoleData_get_order(struct MultipoleData_s * x0)
{
  return MultipoleData_get_order(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_order(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_order(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_order _cffi_d_MultipoleData_get_order
#endif

static int64_t _cffi_d_MultipoleData_get_radiation_flag(struct MultipoleData_s * x0)
{
  return MultipoleData_get_radiation_flag(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_get_radiation_flag(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_get_radiation_flag(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_get_radiation_flag _cffi_d_MultipoleData_get_radiation_flag
#endif

static struct MultipoleData_s * _cffi_d_MultipoleData_getp(struct MultipoleData_s * x0)
{
  return MultipoleData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct MultipoleData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(48));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp _cffi_d_MultipoleData_getp
#endif

static double * _cffi_d_MultipoleData_getp1_knl(struct MultipoleData_s * x0, int64_t x1)
{
  return MultipoleData_getp1_knl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp1_knl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_getp1_knl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp1_knl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp1_knl _cffi_d_MultipoleData_getp1_knl
#endif

static double * _cffi_d_MultipoleData_getp1_ksl(struct MultipoleData_s * x0, int64_t x1)
{
  return MultipoleData_getp1_ksl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp1_ksl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_getp1_ksl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp1_ksl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp1_ksl _cffi_d_MultipoleData_getp1_ksl
#endif

static struct RecordIdentifier_s * _cffi_d_MultipoleData_getp__internal_record_id(struct MultipoleData_s * x0)
{
  return MultipoleData_getp__internal_record_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp__internal_record_id(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIdentifier_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp__internal_record_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(201));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp__internal_record_id _cffi_d_MultipoleData_getp__internal_record_id
#endif

static int64_t * _cffi_d_MultipoleData_getp__internal_record_id_buffer_id(struct MultipoleData_s * x0)
{
  return MultipoleData_getp__internal_record_id_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp__internal_record_id_buffer_id(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp__internal_record_id_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp__internal_record_id_buffer_id _cffi_d_MultipoleData_getp__internal_record_id_buffer_id
#endif

static int64_t * _cffi_d_MultipoleData_getp__internal_record_id_offset(struct MultipoleData_s * x0)
{
  return MultipoleData_getp__internal_record_id_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp__internal_record_id_offset(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp__internal_record_id_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp__internal_record_id_offset _cffi_d_MultipoleData_getp__internal_record_id_offset
#endif

static double * _cffi_d_MultipoleData_getp_delta_taper(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_delta_taper(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_delta_taper(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_delta_taper(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_delta_taper _cffi_d_MultipoleData_getp_delta_taper
#endif

static double * _cffi_d_MultipoleData_getp_hxl(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_hxl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_hxl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_hxl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_hxl _cffi_d_MultipoleData_getp_hxl
#endif

static double * _cffi_d_MultipoleData_getp_hyl(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_hyl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_hyl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_hyl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_hyl _cffi_d_MultipoleData_getp_hyl
#endif

static double * _cffi_d_MultipoleData_getp_inv_factorial_order(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_inv_factorial_order(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_inv_factorial_order(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_inv_factorial_order(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_inv_factorial_order _cffi_d_MultipoleData_getp_inv_factorial_order
#endif

static struct ArrNFloat64_s * _cffi_d_MultipoleData_getp_knl(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_knl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_knl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_knl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_knl _cffi_d_MultipoleData_getp_knl
#endif

static struct ArrNFloat64_s * _cffi_d_MultipoleData_getp_ksl(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_ksl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_ksl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_ksl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_ksl _cffi_d_MultipoleData_getp_ksl
#endif

static double * _cffi_d_MultipoleData_getp_length(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_length(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_length _cffi_d_MultipoleData_getp_length
#endif

static int64_t * _cffi_d_MultipoleData_getp_order(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_order(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_order(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_order(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_order _cffi_d_MultipoleData_getp_order
#endif

static int64_t * _cffi_d_MultipoleData_getp_radiation_flag(struct MultipoleData_s * x0)
{
  return MultipoleData_getp_radiation_flag(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_getp_radiation_flag(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_getp_radiation_flag(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_getp_radiation_flag _cffi_d_MultipoleData_getp_radiation_flag
#endif

static int64_t _cffi_d_MultipoleData_len_knl(struct MultipoleData_s * x0)
{
  return MultipoleData_len_knl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_len_knl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_len_knl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_len_knl _cffi_d_MultipoleData_len_knl
#endif

static int64_t _cffi_d_MultipoleData_len_ksl(struct MultipoleData_s * x0)
{
  return MultipoleData_len_ksl(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_len_ksl(PyObject *self, PyObject *arg0)
{
  struct MultipoleData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = MultipoleData_len_ksl(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_MultipoleData_len_ksl _cffi_d_MultipoleData_len_ksl
#endif

static void _cffi_d_MultipoleData_set__internal_record_id_buffer_id(struct MultipoleData_s * x0, int64_t x1)
{
  MultipoleData_set__internal_record_id_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set__internal_record_id_buffer_id(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set__internal_record_id_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set__internal_record_id_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set__internal_record_id_buffer_id _cffi_d_MultipoleData_set__internal_record_id_buffer_id
#endif

static void _cffi_d_MultipoleData_set__internal_record_id_offset(struct MultipoleData_s * x0, int64_t x1)
{
  MultipoleData_set__internal_record_id_offset(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set__internal_record_id_offset(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set__internal_record_id_offset", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set__internal_record_id_offset(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set__internal_record_id_offset _cffi_d_MultipoleData_set__internal_record_id_offset
#endif

static void _cffi_d_MultipoleData_set_delta_taper(struct MultipoleData_s * x0, double x1)
{
  MultipoleData_set_delta_taper(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_delta_taper(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_delta_taper", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_delta_taper(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_delta_taper _cffi_d_MultipoleData_set_delta_taper
#endif

static void _cffi_d_MultipoleData_set_hxl(struct MultipoleData_s * x0, double x1)
{
  MultipoleData_set_hxl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_hxl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_hxl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_hxl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_hxl _cffi_d_MultipoleData_set_hxl
#endif

static void _cffi_d_MultipoleData_set_hyl(struct MultipoleData_s * x0, double x1)
{
  MultipoleData_set_hyl(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_hyl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_hyl", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_hyl(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_hyl _cffi_d_MultipoleData_set_hyl
#endif

static void _cffi_d_MultipoleData_set_inv_factorial_order(struct MultipoleData_s * x0, double x1)
{
  MultipoleData_set_inv_factorial_order(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_inv_factorial_order(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_inv_factorial_order", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_inv_factorial_order(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_inv_factorial_order _cffi_d_MultipoleData_set_inv_factorial_order
#endif

static void _cffi_d_MultipoleData_set_knl(struct MultipoleData_s * x0, int64_t x1, double x2)
{
  MultipoleData_set_knl(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_knl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_knl", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_knl(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_knl _cffi_d_MultipoleData_set_knl
#endif

static void _cffi_d_MultipoleData_set_ksl(struct MultipoleData_s * x0, int64_t x1, double x2)
{
  MultipoleData_set_ksl(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_ksl(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_ksl", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_ksl(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_ksl _cffi_d_MultipoleData_set_ksl
#endif

static void _cffi_d_MultipoleData_set_length(struct MultipoleData_s * x0, double x1)
{
  MultipoleData_set_length(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_length(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_length", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_length(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_length _cffi_d_MultipoleData_set_length
#endif

static void _cffi_d_MultipoleData_set_order(struct MultipoleData_s * x0, int64_t x1)
{
  MultipoleData_set_order(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_order(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_order", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_order(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_order _cffi_d_MultipoleData_set_order
#endif

static void _cffi_d_MultipoleData_set_radiation_flag(struct MultipoleData_s * x0, int64_t x1)
{
  MultipoleData_set_radiation_flag(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_MultipoleData_set_radiation_flag(PyObject *self, PyObject *args)
{
  struct MultipoleData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "MultipoleData_set_radiation_flag", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct MultipoleData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(48), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { MultipoleData_set_radiation_flag(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_MultipoleData_set_radiation_flag _cffi_d_MultipoleData_set_radiation_flag
#endif

static int64_t _cffi_d_ParticlesData_get__capacity(struct ParticlesData_s * x0)
{
  return ParticlesData_get__capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__capacity(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__capacity _cffi_d_ParticlesData_get__capacity
#endif

static int64_t _cffi_d_ParticlesData_get__num_active_particles(struct ParticlesData_s * x0)
{
  return ParticlesData_get__num_active_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__num_active_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__num_active_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__num_active_particles _cffi_d_ParticlesData_get__num_active_particles
#endif

static int64_t _cffi_d_ParticlesData_get__num_lost_particles(struct ParticlesData_s * x0)
{
  return ParticlesData_get__num_lost_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__num_lost_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__num_lost_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__num_lost_particles _cffi_d_ParticlesData_get__num_lost_particles
#endif

static uint32_t _cffi_d_ParticlesData_get__rng_s1(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get__rng_s1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get__rng_s1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__rng_s1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__rng_s1 _cffi_d_ParticlesData_get__rng_s1
#endif

static uint32_t _cffi_d_ParticlesData_get__rng_s2(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get__rng_s2(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get__rng_s2", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__rng_s2(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__rng_s2 _cffi_d_ParticlesData_get__rng_s2
#endif

static uint32_t _cffi_d_ParticlesData_get__rng_s3(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get__rng_s3(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get__rng_s3", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__rng_s3(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__rng_s3 _cffi_d_ParticlesData_get__rng_s3
#endif

static uint32_t _cffi_d_ParticlesData_get__rng_s4(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get__rng_s4(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get__rng_s4", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get__rng_s4(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get__rng_s4 _cffi_d_ParticlesData_get__rng_s4
#endif

static int64_t _cffi_d_ParticlesData_get_at_element(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_at_element _cffi_d_ParticlesData_get_at_element
#endif

static int64_t _cffi_d_ParticlesData_get_at_turn(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_at_turn _cffi_d_ParticlesData_get_at_turn
#endif

static double _cffi_d_ParticlesData_get_beta0(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_beta0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_beta0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_beta0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_beta0 _cffi_d_ParticlesData_get_beta0
#endif

static double _cffi_d_ParticlesData_get_charge_ratio(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_charge_ratio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_charge_ratio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_charge_ratio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_charge_ratio _cffi_d_ParticlesData_get_charge_ratio
#endif

static double _cffi_d_ParticlesData_get_chi(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_chi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_chi(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_chi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_chi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_chi _cffi_d_ParticlesData_get_chi
#endif

static double _cffi_d_ParticlesData_get_delta(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_delta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_delta _cffi_d_ParticlesData_get_delta
#endif

static double _cffi_d_ParticlesData_get_gamma0(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_gamma0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_gamma0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_gamma0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_gamma0 _cffi_d_ParticlesData_get_gamma0
#endif

static double _cffi_d_ParticlesData_get_mass0(struct ParticlesData_s * x0)
{
  return ParticlesData_get_mass0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_mass0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_mass0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_mass0 _cffi_d_ParticlesData_get_mass0
#endif

static double _cffi_d_ParticlesData_get_p0c(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_p0c(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_p0c", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_p0c(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_p0c _cffi_d_ParticlesData_get_p0c
#endif

static int64_t _cffi_d_ParticlesData_get_parent_particle_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_parent_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_parent_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_parent_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_parent_particle_id _cffi_d_ParticlesData_get_parent_particle_id
#endif

static int64_t _cffi_d_ParticlesData_get_particle_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_particle_id _cffi_d_ParticlesData_get_particle_id
#endif

static int64_t _cffi_d_ParticlesData_get_pdg_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_pdg_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_pdg_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_pdg_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_pdg_id _cffi_d_ParticlesData_get_pdg_id
#endif

static double _cffi_d_ParticlesData_get_ptau(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_ptau(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_ptau", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_ptau(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_ptau _cffi_d_ParticlesData_get_ptau
#endif

static double _cffi_d_ParticlesData_get_px(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_px(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_px _cffi_d_ParticlesData_get_px
#endif

static double _cffi_d_ParticlesData_get_py(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_py(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_py _cffi_d_ParticlesData_get_py
#endif

static double _cffi_d_ParticlesData_get_q0(struct ParticlesData_s * x0)
{
  return ParticlesData_get_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_q0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_q0 _cffi_d_ParticlesData_get_q0
#endif

static double _cffi_d_ParticlesData_get_rpp(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_rpp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_rpp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_rpp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_rpp _cffi_d_ParticlesData_get_rpp
#endif

static double _cffi_d_ParticlesData_get_rvv(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_rvv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_rvv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_rvv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_rvv _cffi_d_ParticlesData_get_rvv
#endif

static double _cffi_d_ParticlesData_get_s(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_s(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_s(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_s", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_s(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_s _cffi_d_ParticlesData_get_s
#endif

static int64_t _cffi_d_ParticlesData_get_start_tracking_at_element(struct ParticlesData_s * x0)
{
  return ParticlesData_get_start_tracking_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_start_tracking_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_start_tracking_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_start_tracking_at_element _cffi_d_ParticlesData_get_start_tracking_at_element
#endif

static int64_t _cffi_d_ParticlesData_get_state(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_state(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_state(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_state", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_state(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_state _cffi_d_ParticlesData_get_state
#endif

static double _cffi_d_ParticlesData_get_weight(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_weight(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_weight(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_weight", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_weight(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_weight _cffi_d_ParticlesData_get_weight
#endif

static double _cffi_d_ParticlesData_get_x(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_x(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_x _cffi_d_ParticlesData_get_x
#endif

static double _cffi_d_ParticlesData_get_y(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_y(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_y _cffi_d_ParticlesData_get_y
#endif

static double _cffi_d_ParticlesData_get_zeta(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_get_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_get_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_get_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_get_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_get_zeta _cffi_d_ParticlesData_get_zeta
#endif

static struct ParticlesData_s * _cffi_d_ParticlesData_getp(struct ParticlesData_s * x0)
{
  return ParticlesData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ParticlesData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(55));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp _cffi_d_ParticlesData_getp
#endif

static uint32_t * _cffi_d_ParticlesData_getp1__rng_s1(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1__rng_s1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1__rng_s1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1__rng_s1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1__rng_s1 _cffi_d_ParticlesData_getp1__rng_s1
#endif

static uint32_t * _cffi_d_ParticlesData_getp1__rng_s2(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1__rng_s2(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1__rng_s2", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1__rng_s2(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1__rng_s2 _cffi_d_ParticlesData_getp1__rng_s2
#endif

static uint32_t * _cffi_d_ParticlesData_getp1__rng_s3(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1__rng_s3(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1__rng_s3", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1__rng_s3(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1__rng_s3 _cffi_d_ParticlesData_getp1__rng_s3
#endif

static uint32_t * _cffi_d_ParticlesData_getp1__rng_s4(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1__rng_s4(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1__rng_s4", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1__rng_s4(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1__rng_s4 _cffi_d_ParticlesData_getp1__rng_s4
#endif

static int64_t * _cffi_d_ParticlesData_getp1_at_element(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_at_element _cffi_d_ParticlesData_getp1_at_element
#endif

static int64_t * _cffi_d_ParticlesData_getp1_at_turn(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_at_turn _cffi_d_ParticlesData_getp1_at_turn
#endif

static double * _cffi_d_ParticlesData_getp1_beta0(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_beta0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_beta0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_beta0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_beta0 _cffi_d_ParticlesData_getp1_beta0
#endif

static double * _cffi_d_ParticlesData_getp1_charge_ratio(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_charge_ratio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_charge_ratio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_charge_ratio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_charge_ratio _cffi_d_ParticlesData_getp1_charge_ratio
#endif

static double * _cffi_d_ParticlesData_getp1_chi(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_chi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_chi(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_chi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_chi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_chi _cffi_d_ParticlesData_getp1_chi
#endif

static double * _cffi_d_ParticlesData_getp1_delta(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_delta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_delta _cffi_d_ParticlesData_getp1_delta
#endif

static double * _cffi_d_ParticlesData_getp1_gamma0(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_gamma0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_gamma0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_gamma0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_gamma0 _cffi_d_ParticlesData_getp1_gamma0
#endif

static double * _cffi_d_ParticlesData_getp1_p0c(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_p0c(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_p0c", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_p0c(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_p0c _cffi_d_ParticlesData_getp1_p0c
#endif

static int64_t * _cffi_d_ParticlesData_getp1_parent_particle_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_parent_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_parent_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_parent_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_parent_particle_id _cffi_d_ParticlesData_getp1_parent_particle_id
#endif

static int64_t * _cffi_d_ParticlesData_getp1_particle_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_particle_id _cffi_d_ParticlesData_getp1_particle_id
#endif

static int64_t * _cffi_d_ParticlesData_getp1_pdg_id(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_pdg_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_pdg_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_pdg_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_pdg_id _cffi_d_ParticlesData_getp1_pdg_id
#endif

static double * _cffi_d_ParticlesData_getp1_ptau(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_ptau(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_ptau", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_ptau(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_ptau _cffi_d_ParticlesData_getp1_ptau
#endif

static double * _cffi_d_ParticlesData_getp1_px(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_px(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_px _cffi_d_ParticlesData_getp1_px
#endif

static double * _cffi_d_ParticlesData_getp1_py(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_py(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_py _cffi_d_ParticlesData_getp1_py
#endif

static double * _cffi_d_ParticlesData_getp1_rpp(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_rpp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_rpp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_rpp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_rpp _cffi_d_ParticlesData_getp1_rpp
#endif

static double * _cffi_d_ParticlesData_getp1_rvv(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_rvv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_rvv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_rvv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_rvv _cffi_d_ParticlesData_getp1_rvv
#endif

static double * _cffi_d_ParticlesData_getp1_s(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_s(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_s(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_s", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_s(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_s _cffi_d_ParticlesData_getp1_s
#endif

static int64_t * _cffi_d_ParticlesData_getp1_state(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_state(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_state(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_state", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_state(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_state _cffi_d_ParticlesData_getp1_state
#endif

static double * _cffi_d_ParticlesData_getp1_weight(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_weight(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_weight(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_weight", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_weight(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_weight _cffi_d_ParticlesData_getp1_weight
#endif

static double * _cffi_d_ParticlesData_getp1_x(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_x(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_x _cffi_d_ParticlesData_getp1_x
#endif

static double * _cffi_d_ParticlesData_getp1_y(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_y(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_y _cffi_d_ParticlesData_getp1_y
#endif

static double * _cffi_d_ParticlesData_getp1_zeta(struct ParticlesData_s * x0, int64_t x1)
{
  return ParticlesData_getp1_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp1_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_getp1_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp1_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp1_zeta _cffi_d_ParticlesData_getp1_zeta
#endif

static int64_t * _cffi_d_ParticlesData_getp__capacity(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__capacity(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__capacity _cffi_d_ParticlesData_getp__capacity
#endif

static int64_t * _cffi_d_ParticlesData_getp__num_active_particles(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__num_active_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__num_active_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__num_active_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__num_active_particles _cffi_d_ParticlesData_getp__num_active_particles
#endif

static int64_t * _cffi_d_ParticlesData_getp__num_lost_particles(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__num_lost_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__num_lost_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__num_lost_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__num_lost_particles _cffi_d_ParticlesData_getp__num_lost_particles
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesData_getp__rng_s1(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__rng_s1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__rng_s1(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__rng_s1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__rng_s1 _cffi_d_ParticlesData_getp__rng_s1
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesData_getp__rng_s2(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__rng_s2(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__rng_s2(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__rng_s2(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__rng_s2 _cffi_d_ParticlesData_getp__rng_s2
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesData_getp__rng_s3(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__rng_s3(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__rng_s3(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__rng_s3(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__rng_s3 _cffi_d_ParticlesData_getp__rng_s3
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesData_getp__rng_s4(struct ParticlesData_s * x0)
{
  return ParticlesData_getp__rng_s4(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp__rng_s4(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp__rng_s4(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp__rng_s4 _cffi_d_ParticlesData_getp__rng_s4
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_at_element(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_at_element _cffi_d_ParticlesData_getp_at_element
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_at_turn(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_at_turn _cffi_d_ParticlesData_getp_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_beta0(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_beta0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_beta0 _cffi_d_ParticlesData_getp_beta0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_charge_ratio(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_charge_ratio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_charge_ratio(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_charge_ratio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_charge_ratio _cffi_d_ParticlesData_getp_charge_ratio
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_chi(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_chi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_chi(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_chi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_chi _cffi_d_ParticlesData_getp_chi
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_delta(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_delta(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_delta _cffi_d_ParticlesData_getp_delta
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_gamma0(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_gamma0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_gamma0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_gamma0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_gamma0 _cffi_d_ParticlesData_getp_gamma0
#endif

static double * _cffi_d_ParticlesData_getp_mass0(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_mass0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_mass0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_mass0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_mass0 _cffi_d_ParticlesData_getp_mass0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_p0c(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_p0c(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_p0c(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_p0c(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_p0c _cffi_d_ParticlesData_getp_p0c
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_parent_particle_id(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_parent_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_parent_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_parent_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_parent_particle_id _cffi_d_ParticlesData_getp_parent_particle_id
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_particle_id(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_particle_id _cffi_d_ParticlesData_getp_particle_id
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_pdg_id(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_pdg_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_pdg_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_pdg_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_pdg_id _cffi_d_ParticlesData_getp_pdg_id
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_ptau(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_ptau(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_ptau(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_ptau(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_ptau _cffi_d_ParticlesData_getp_ptau
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_px(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_px(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_px _cffi_d_ParticlesData_getp_px
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_py(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_py(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_py _cffi_d_ParticlesData_getp_py
#endif

static double * _cffi_d_ParticlesData_getp_q0(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_q0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_q0 _cffi_d_ParticlesData_getp_q0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_rpp(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_rpp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_rpp(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_rpp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_rpp _cffi_d_ParticlesData_getp_rpp
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_rvv(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_rvv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_rvv(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_rvv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_rvv _cffi_d_ParticlesData_getp_rvv
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_s(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_s(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_s(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_s(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_s _cffi_d_ParticlesData_getp_s
#endif

static int64_t * _cffi_d_ParticlesData_getp_start_tracking_at_element(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_start_tracking_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_start_tracking_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_start_tracking_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_start_tracking_at_element _cffi_d_ParticlesData_getp_start_tracking_at_element
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesData_getp_state(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_state(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_state _cffi_d_ParticlesData_getp_state
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_weight(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_weight(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_weight(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_weight(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_weight _cffi_d_ParticlesData_getp_weight
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_x(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_x(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_x _cffi_d_ParticlesData_getp_x
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_y(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_y(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_y _cffi_d_ParticlesData_getp_y
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesData_getp_zeta(struct ParticlesData_s * x0)
{
  return ParticlesData_getp_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_getp_zeta(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_getp_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_getp_zeta _cffi_d_ParticlesData_getp_zeta
#endif

static int64_t _cffi_d_ParticlesData_len__rng_s1(struct ParticlesData_s * x0)
{
  return ParticlesData_len__rng_s1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len__rng_s1(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len__rng_s1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len__rng_s1 _cffi_d_ParticlesData_len__rng_s1
#endif

static int64_t _cffi_d_ParticlesData_len__rng_s2(struct ParticlesData_s * x0)
{
  return ParticlesData_len__rng_s2(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len__rng_s2(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len__rng_s2(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len__rng_s2 _cffi_d_ParticlesData_len__rng_s2
#endif

static int64_t _cffi_d_ParticlesData_len__rng_s3(struct ParticlesData_s * x0)
{
  return ParticlesData_len__rng_s3(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len__rng_s3(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len__rng_s3(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len__rng_s3 _cffi_d_ParticlesData_len__rng_s3
#endif

static int64_t _cffi_d_ParticlesData_len__rng_s4(struct ParticlesData_s * x0)
{
  return ParticlesData_len__rng_s4(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len__rng_s4(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len__rng_s4(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len__rng_s4 _cffi_d_ParticlesData_len__rng_s4
#endif

static int64_t _cffi_d_ParticlesData_len_at_element(struct ParticlesData_s * x0)
{
  return ParticlesData_len_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_at_element _cffi_d_ParticlesData_len_at_element
#endif

static int64_t _cffi_d_ParticlesData_len_at_turn(struct ParticlesData_s * x0)
{
  return ParticlesData_len_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_at_turn _cffi_d_ParticlesData_len_at_turn
#endif

static int64_t _cffi_d_ParticlesData_len_beta0(struct ParticlesData_s * x0)
{
  return ParticlesData_len_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_beta0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_beta0 _cffi_d_ParticlesData_len_beta0
#endif

static int64_t _cffi_d_ParticlesData_len_charge_ratio(struct ParticlesData_s * x0)
{
  return ParticlesData_len_charge_ratio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_charge_ratio(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_charge_ratio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_charge_ratio _cffi_d_ParticlesData_len_charge_ratio
#endif

static int64_t _cffi_d_ParticlesData_len_chi(struct ParticlesData_s * x0)
{
  return ParticlesData_len_chi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_chi(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_chi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_chi _cffi_d_ParticlesData_len_chi
#endif

static int64_t _cffi_d_ParticlesData_len_delta(struct ParticlesData_s * x0)
{
  return ParticlesData_len_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_delta(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_delta _cffi_d_ParticlesData_len_delta
#endif

static int64_t _cffi_d_ParticlesData_len_gamma0(struct ParticlesData_s * x0)
{
  return ParticlesData_len_gamma0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_gamma0(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_gamma0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_gamma0 _cffi_d_ParticlesData_len_gamma0
#endif

static int64_t _cffi_d_ParticlesData_len_p0c(struct ParticlesData_s * x0)
{
  return ParticlesData_len_p0c(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_p0c(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_p0c(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_p0c _cffi_d_ParticlesData_len_p0c
#endif

static int64_t _cffi_d_ParticlesData_len_parent_particle_id(struct ParticlesData_s * x0)
{
  return ParticlesData_len_parent_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_parent_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_parent_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_parent_particle_id _cffi_d_ParticlesData_len_parent_particle_id
#endif

static int64_t _cffi_d_ParticlesData_len_particle_id(struct ParticlesData_s * x0)
{
  return ParticlesData_len_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_particle_id _cffi_d_ParticlesData_len_particle_id
#endif

static int64_t _cffi_d_ParticlesData_len_pdg_id(struct ParticlesData_s * x0)
{
  return ParticlesData_len_pdg_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_pdg_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_pdg_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_pdg_id _cffi_d_ParticlesData_len_pdg_id
#endif

static int64_t _cffi_d_ParticlesData_len_ptau(struct ParticlesData_s * x0)
{
  return ParticlesData_len_ptau(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_ptau(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_ptau(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_ptau _cffi_d_ParticlesData_len_ptau
#endif

static int64_t _cffi_d_ParticlesData_len_px(struct ParticlesData_s * x0)
{
  return ParticlesData_len_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_px(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_px _cffi_d_ParticlesData_len_px
#endif

static int64_t _cffi_d_ParticlesData_len_py(struct ParticlesData_s * x0)
{
  return ParticlesData_len_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_py(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_py _cffi_d_ParticlesData_len_py
#endif

static int64_t _cffi_d_ParticlesData_len_rpp(struct ParticlesData_s * x0)
{
  return ParticlesData_len_rpp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_rpp(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_rpp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_rpp _cffi_d_ParticlesData_len_rpp
#endif

static int64_t _cffi_d_ParticlesData_len_rvv(struct ParticlesData_s * x0)
{
  return ParticlesData_len_rvv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_rvv(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_rvv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_rvv _cffi_d_ParticlesData_len_rvv
#endif

static int64_t _cffi_d_ParticlesData_len_s(struct ParticlesData_s * x0)
{
  return ParticlesData_len_s(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_s(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_s(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_s _cffi_d_ParticlesData_len_s
#endif

static int64_t _cffi_d_ParticlesData_len_state(struct ParticlesData_s * x0)
{
  return ParticlesData_len_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_state(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_state _cffi_d_ParticlesData_len_state
#endif

static int64_t _cffi_d_ParticlesData_len_weight(struct ParticlesData_s * x0)
{
  return ParticlesData_len_weight(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_weight(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_weight(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_weight _cffi_d_ParticlesData_len_weight
#endif

static int64_t _cffi_d_ParticlesData_len_x(struct ParticlesData_s * x0)
{
  return ParticlesData_len_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_x(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_x _cffi_d_ParticlesData_len_x
#endif

static int64_t _cffi_d_ParticlesData_len_y(struct ParticlesData_s * x0)
{
  return ParticlesData_len_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_y(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_y _cffi_d_ParticlesData_len_y
#endif

static int64_t _cffi_d_ParticlesData_len_zeta(struct ParticlesData_s * x0)
{
  return ParticlesData_len_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_len_zeta(PyObject *self, PyObject *arg0)
{
  struct ParticlesData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesData_len_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesData_len_zeta _cffi_d_ParticlesData_len_zeta
#endif

static void _cffi_d_ParticlesData_set__capacity(struct ParticlesData_s * x0, int64_t x1)
{
  ParticlesData_set__capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__capacity(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__capacity _cffi_d_ParticlesData_set__capacity
#endif

static void _cffi_d_ParticlesData_set__num_active_particles(struct ParticlesData_s * x0, int64_t x1)
{
  ParticlesData_set__num_active_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__num_active_particles(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__num_active_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__num_active_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__num_active_particles _cffi_d_ParticlesData_set__num_active_particles
#endif

static void _cffi_d_ParticlesData_set__num_lost_particles(struct ParticlesData_s * x0, int64_t x1)
{
  ParticlesData_set__num_lost_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__num_lost_particles(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__num_lost_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__num_lost_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__num_lost_particles _cffi_d_ParticlesData_set__num_lost_particles
#endif

static void _cffi_d_ParticlesData_set__rng_s1(struct ParticlesData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesData_set__rng_s1(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__rng_s1", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__rng_s1(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__rng_s1 _cffi_d_ParticlesData_set__rng_s1
#endif

static void _cffi_d_ParticlesData_set__rng_s2(struct ParticlesData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesData_set__rng_s2(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__rng_s2", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__rng_s2(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__rng_s2 _cffi_d_ParticlesData_set__rng_s2
#endif

static void _cffi_d_ParticlesData_set__rng_s3(struct ParticlesData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesData_set__rng_s3(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__rng_s3", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__rng_s3(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__rng_s3 _cffi_d_ParticlesData_set__rng_s3
#endif

static void _cffi_d_ParticlesData_set__rng_s4(struct ParticlesData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesData_set__rng_s4(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set__rng_s4", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set__rng_s4(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set__rng_s4 _cffi_d_ParticlesData_set__rng_s4
#endif

static void _cffi_d_ParticlesData_set_at_element(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_at_element _cffi_d_ParticlesData_set_at_element
#endif

static void _cffi_d_ParticlesData_set_at_turn(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_at_turn _cffi_d_ParticlesData_set_at_turn
#endif

static void _cffi_d_ParticlesData_set_beta0(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_beta0(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_beta0", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_beta0(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_beta0 _cffi_d_ParticlesData_set_beta0
#endif

static void _cffi_d_ParticlesData_set_charge_ratio(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_charge_ratio(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_charge_ratio", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_charge_ratio(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_charge_ratio _cffi_d_ParticlesData_set_charge_ratio
#endif

static void _cffi_d_ParticlesData_set_chi(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_chi(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_chi(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_chi", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_chi(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_chi _cffi_d_ParticlesData_set_chi
#endif

static void _cffi_d_ParticlesData_set_delta(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_delta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_delta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_delta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_delta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_delta _cffi_d_ParticlesData_set_delta
#endif

static void _cffi_d_ParticlesData_set_gamma0(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_gamma0(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_gamma0", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_gamma0(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_gamma0 _cffi_d_ParticlesData_set_gamma0
#endif

static void _cffi_d_ParticlesData_set_mass0(struct ParticlesData_s * x0, double x1)
{
  ParticlesData_set_mass0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_mass0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_mass0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_mass0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_mass0 _cffi_d_ParticlesData_set_mass0
#endif

static void _cffi_d_ParticlesData_set_p0c(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_p0c(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_p0c", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_p0c(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_p0c _cffi_d_ParticlesData_set_p0c
#endif

static void _cffi_d_ParticlesData_set_parent_particle_id(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_parent_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_parent_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_parent_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_parent_particle_id _cffi_d_ParticlesData_set_parent_particle_id
#endif

static void _cffi_d_ParticlesData_set_particle_id(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_particle_id _cffi_d_ParticlesData_set_particle_id
#endif

static void _cffi_d_ParticlesData_set_pdg_id(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_pdg_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_pdg_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_pdg_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_pdg_id _cffi_d_ParticlesData_set_pdg_id
#endif

static void _cffi_d_ParticlesData_set_ptau(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_ptau(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_ptau", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_ptau(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_ptau _cffi_d_ParticlesData_set_ptau
#endif

static void _cffi_d_ParticlesData_set_px(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_px(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_px(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_px", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_px(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_px _cffi_d_ParticlesData_set_px
#endif

static void _cffi_d_ParticlesData_set_py(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_py(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_py(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_py", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_py(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_py _cffi_d_ParticlesData_set_py
#endif

static void _cffi_d_ParticlesData_set_q0(struct ParticlesData_s * x0, double x1)
{
  ParticlesData_set_q0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_q0(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_q0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_q0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_q0 _cffi_d_ParticlesData_set_q0
#endif

static void _cffi_d_ParticlesData_set_rpp(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_rpp(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_rpp", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_rpp(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_rpp _cffi_d_ParticlesData_set_rpp
#endif

static void _cffi_d_ParticlesData_set_rvv(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_rvv(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_rvv", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_rvv(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_rvv _cffi_d_ParticlesData_set_rvv
#endif

static void _cffi_d_ParticlesData_set_s(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_s(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_s(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_s", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_s(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_s _cffi_d_ParticlesData_set_s
#endif

static void _cffi_d_ParticlesData_set_start_tracking_at_element(struct ParticlesData_s * x0, int64_t x1)
{
  ParticlesData_set_start_tracking_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_start_tracking_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_start_tracking_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_start_tracking_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_start_tracking_at_element _cffi_d_ParticlesData_set_start_tracking_at_element
#endif

static void _cffi_d_ParticlesData_set_state(struct ParticlesData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesData_set_state(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_state(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_state", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_state(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_state _cffi_d_ParticlesData_set_state
#endif

static void _cffi_d_ParticlesData_set_weight(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_weight(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_weight(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_weight", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_weight(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_weight _cffi_d_ParticlesData_set_weight
#endif

static void _cffi_d_ParticlesData_set_x(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_x(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_x(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_x", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_x(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_x _cffi_d_ParticlesData_set_x
#endif

static void _cffi_d_ParticlesData_set_y(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_y(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_y(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_y", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_y(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_y _cffi_d_ParticlesData_set_y
#endif

static void _cffi_d_ParticlesData_set_zeta(struct ParticlesData_s * x0, int64_t x1, double x2)
{
  ParticlesData_set_zeta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesData_set_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesData_set_zeta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesData_set_zeta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesData_set_zeta _cffi_d_ParticlesData_set_zeta
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data__capacity(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data__capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__capacity(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__capacity _cffi_d_ParticlesMonitorData_get_data__capacity
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data__num_active_particles(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data__num_active_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__num_active_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__num_active_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__num_active_particles _cffi_d_ParticlesMonitorData_get_data__num_active_particles
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data__num_lost_particles(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data__num_lost_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__num_lost_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__num_lost_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__num_lost_particles _cffi_d_ParticlesMonitorData_get_data__num_lost_particles
#endif

static uint32_t _cffi_d_ParticlesMonitorData_get_data__rng_s1(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data__rng_s1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data__rng_s1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__rng_s1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__rng_s1 _cffi_d_ParticlesMonitorData_get_data__rng_s1
#endif

static uint32_t _cffi_d_ParticlesMonitorData_get_data__rng_s2(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data__rng_s2(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data__rng_s2", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__rng_s2(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__rng_s2 _cffi_d_ParticlesMonitorData_get_data__rng_s2
#endif

static uint32_t _cffi_d_ParticlesMonitorData_get_data__rng_s3(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data__rng_s3(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data__rng_s3", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__rng_s3(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__rng_s3 _cffi_d_ParticlesMonitorData_get_data__rng_s3
#endif

static uint32_t _cffi_d_ParticlesMonitorData_get_data__rng_s4(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data__rng_s4(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data__rng_s4", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data__rng_s4(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data__rng_s4 _cffi_d_ParticlesMonitorData_get_data__rng_s4
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_at_element(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_at_element _cffi_d_ParticlesMonitorData_get_data_at_element
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_at_turn(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_at_turn _cffi_d_ParticlesMonitorData_get_data_at_turn
#endif

static double _cffi_d_ParticlesMonitorData_get_data_beta0(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_beta0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_beta0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_beta0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_beta0 _cffi_d_ParticlesMonitorData_get_data_beta0
#endif

static double _cffi_d_ParticlesMonitorData_get_data_charge_ratio(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_charge_ratio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_charge_ratio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_charge_ratio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_charge_ratio _cffi_d_ParticlesMonitorData_get_data_charge_ratio
#endif

static double _cffi_d_ParticlesMonitorData_get_data_chi(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_chi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_chi(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_chi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_chi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_chi _cffi_d_ParticlesMonitorData_get_data_chi
#endif

static double _cffi_d_ParticlesMonitorData_get_data_delta(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_delta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_delta _cffi_d_ParticlesMonitorData_get_data_delta
#endif

static double _cffi_d_ParticlesMonitorData_get_data_gamma0(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_gamma0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_gamma0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_gamma0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_gamma0 _cffi_d_ParticlesMonitorData_get_data_gamma0
#endif

static double _cffi_d_ParticlesMonitorData_get_data_mass0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data_mass0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_mass0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_mass0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_mass0 _cffi_d_ParticlesMonitorData_get_data_mass0
#endif

static double _cffi_d_ParticlesMonitorData_get_data_p0c(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_p0c(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_p0c", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_p0c(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_p0c _cffi_d_ParticlesMonitorData_get_data_p0c
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_parent_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_parent_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_parent_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_parent_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_parent_particle_id _cffi_d_ParticlesMonitorData_get_data_parent_particle_id
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_particle_id _cffi_d_ParticlesMonitorData_get_data_particle_id
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_pdg_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_pdg_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_pdg_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_pdg_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_pdg_id _cffi_d_ParticlesMonitorData_get_data_pdg_id
#endif

static double _cffi_d_ParticlesMonitorData_get_data_ptau(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_ptau(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_ptau", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_ptau(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_ptau _cffi_d_ParticlesMonitorData_get_data_ptau
#endif

static double _cffi_d_ParticlesMonitorData_get_data_px(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_px(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_px _cffi_d_ParticlesMonitorData_get_data_px
#endif

static double _cffi_d_ParticlesMonitorData_get_data_py(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_py(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_py _cffi_d_ParticlesMonitorData_get_data_py
#endif

static double _cffi_d_ParticlesMonitorData_get_data_q0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_q0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_q0 _cffi_d_ParticlesMonitorData_get_data_q0
#endif

static double _cffi_d_ParticlesMonitorData_get_data_rpp(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_rpp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_rpp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_rpp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_rpp _cffi_d_ParticlesMonitorData_get_data_rpp
#endif

static double _cffi_d_ParticlesMonitorData_get_data_rvv(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_rvv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_rvv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_rvv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_rvv _cffi_d_ParticlesMonitorData_get_data_rvv
#endif

static double _cffi_d_ParticlesMonitorData_get_data_s(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_s(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_s(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_s", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_s(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_s _cffi_d_ParticlesMonitorData_get_data_s
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_start_tracking_at_element(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_data_start_tracking_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_start_tracking_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_start_tracking_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_start_tracking_at_element _cffi_d_ParticlesMonitorData_get_data_start_tracking_at_element
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_data_state(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_state(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_state(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_state", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_state(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_state _cffi_d_ParticlesMonitorData_get_data_state
#endif

static double _cffi_d_ParticlesMonitorData_get_data_weight(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_weight(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_weight(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_weight", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_weight(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_weight _cffi_d_ParticlesMonitorData_get_data_weight
#endif

static double _cffi_d_ParticlesMonitorData_get_data_x(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_x(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_x _cffi_d_ParticlesMonitorData_get_data_x
#endif

static double _cffi_d_ParticlesMonitorData_get_data_y(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_y(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_y _cffi_d_ParticlesMonitorData_get_data_y
#endif

static double _cffi_d_ParticlesMonitorData_get_data_zeta(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_get_data_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_data_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_get_data_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_data_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_data_zeta _cffi_d_ParticlesMonitorData_get_data_zeta
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_ebe_mode(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_ebe_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_ebe_mode(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_ebe_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_ebe_mode _cffi_d_ParticlesMonitorData_get_ebe_mode
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_flag_auto_to_numpy(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_flag_auto_to_numpy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_flag_auto_to_numpy(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_flag_auto_to_numpy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_flag_auto_to_numpy _cffi_d_ParticlesMonitorData_get_flag_auto_to_numpy
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_n_records(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_n_records(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_n_records(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_n_records(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_n_records _cffi_d_ParticlesMonitorData_get_n_records
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_n_repetitions(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_n_repetitions(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_n_repetitions(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_n_repetitions(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_n_repetitions _cffi_d_ParticlesMonitorData_get_n_repetitions
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_part_id_end(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_part_id_end(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_part_id_end(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_part_id_end(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_part_id_end _cffi_d_ParticlesMonitorData_get_part_id_end
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_part_id_start(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_part_id_start(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_part_id_start(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_part_id_start(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_part_id_start _cffi_d_ParticlesMonitorData_get_part_id_start
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_repetition_period(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_repetition_period(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_repetition_period(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_repetition_period(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_repetition_period _cffi_d_ParticlesMonitorData_get_repetition_period
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_start_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_start_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_start_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_start_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_start_at_turn _cffi_d_ParticlesMonitorData_get_start_at_turn
#endif

static int64_t _cffi_d_ParticlesMonitorData_get_stop_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_get_stop_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_get_stop_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_get_stop_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_get_stop_at_turn _cffi_d_ParticlesMonitorData_get_stop_at_turn
#endif

static struct ParticlesMonitorData_s * _cffi_d_ParticlesMonitorData_getp(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ParticlesMonitorData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(62));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp _cffi_d_ParticlesMonitorData_getp
#endif

static uint32_t * _cffi_d_ParticlesMonitorData_getp1_data__rng_s1(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data__rng_s1(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data__rng_s1", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data__rng_s1(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data__rng_s1 _cffi_d_ParticlesMonitorData_getp1_data__rng_s1
#endif

static uint32_t * _cffi_d_ParticlesMonitorData_getp1_data__rng_s2(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data__rng_s2(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data__rng_s2", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data__rng_s2(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data__rng_s2 _cffi_d_ParticlesMonitorData_getp1_data__rng_s2
#endif

static uint32_t * _cffi_d_ParticlesMonitorData_getp1_data__rng_s3(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data__rng_s3(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data__rng_s3", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data__rng_s3(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data__rng_s3 _cffi_d_ParticlesMonitorData_getp1_data__rng_s3
#endif

static uint32_t * _cffi_d_ParticlesMonitorData_getp1_data__rng_s4(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data__rng_s4(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data__rng_s4", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data__rng_s4(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data__rng_s4 _cffi_d_ParticlesMonitorData_getp1_data__rng_s4
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_at_element(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_at_element _cffi_d_ParticlesMonitorData_getp1_data_at_element
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_at_turn(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_at_turn _cffi_d_ParticlesMonitorData_getp1_data_at_turn
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_beta0(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_beta0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_beta0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_beta0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_beta0 _cffi_d_ParticlesMonitorData_getp1_data_beta0
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_charge_ratio(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_charge_ratio(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_charge_ratio", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_charge_ratio(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_charge_ratio _cffi_d_ParticlesMonitorData_getp1_data_charge_ratio
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_chi(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_chi(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_chi(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_chi", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_chi(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_chi _cffi_d_ParticlesMonitorData_getp1_data_chi
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_delta(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_delta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_delta _cffi_d_ParticlesMonitorData_getp1_data_delta
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_gamma0(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_gamma0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_gamma0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_gamma0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_gamma0 _cffi_d_ParticlesMonitorData_getp1_data_gamma0
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_p0c(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_p0c(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_p0c", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_p0c(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_p0c _cffi_d_ParticlesMonitorData_getp1_data_p0c
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_parent_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_parent_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_parent_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_parent_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_parent_particle_id _cffi_d_ParticlesMonitorData_getp1_data_parent_particle_id
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_particle_id _cffi_d_ParticlesMonitorData_getp1_data_particle_id
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_pdg_id(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_pdg_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_pdg_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_pdg_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_pdg_id _cffi_d_ParticlesMonitorData_getp1_data_pdg_id
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_ptau(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_ptau(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_ptau", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_ptau(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_ptau _cffi_d_ParticlesMonitorData_getp1_data_ptau
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_px(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_px(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_px(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_px", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_px(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_px _cffi_d_ParticlesMonitorData_getp1_data_px
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_py(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_py(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_py(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_py", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_py(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_py _cffi_d_ParticlesMonitorData_getp1_data_py
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_rpp(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_rpp(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_rpp", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_rpp(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_rpp _cffi_d_ParticlesMonitorData_getp1_data_rpp
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_rvv(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_rvv(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_rvv", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_rvv(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_rvv _cffi_d_ParticlesMonitorData_getp1_data_rvv
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_s(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_s(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_s(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_s", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_s(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_s _cffi_d_ParticlesMonitorData_getp1_data_s
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp1_data_state(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_state(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_state(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_state", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_state(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_state _cffi_d_ParticlesMonitorData_getp1_data_state
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_weight(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_weight(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_weight(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_weight", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_weight(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_weight _cffi_d_ParticlesMonitorData_getp1_data_weight
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_x(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_x(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_x _cffi_d_ParticlesMonitorData_getp1_data_x
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_y(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_y(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_y _cffi_d_ParticlesMonitorData_getp1_data_y
#endif

static double * _cffi_d_ParticlesMonitorData_getp1_data_zeta(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  return ParticlesMonitorData_getp1_data_zeta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp1_data_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_getp1_data_zeta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp1_data_zeta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp1_data_zeta _cffi_d_ParticlesMonitorData_getp1_data_zeta
#endif

static struct ParticlesData_s * _cffi_d_ParticlesMonitorData_getp_data(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ParticlesData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(55));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data _cffi_d_ParticlesMonitorData_getp_data
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_data__capacity(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__capacity(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__capacity _cffi_d_ParticlesMonitorData_getp_data__capacity
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_data__num_active_particles(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__num_active_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__num_active_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__num_active_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__num_active_particles _cffi_d_ParticlesMonitorData_getp_data__num_active_particles
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_data__num_lost_particles(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__num_lost_particles(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__num_lost_particles(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__num_lost_particles(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__num_lost_particles _cffi_d_ParticlesMonitorData_getp_data__num_lost_particles
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesMonitorData_getp_data__rng_s1(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__rng_s1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__rng_s1(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__rng_s1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__rng_s1 _cffi_d_ParticlesMonitorData_getp_data__rng_s1
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesMonitorData_getp_data__rng_s2(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__rng_s2(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__rng_s2(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__rng_s2(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__rng_s2 _cffi_d_ParticlesMonitorData_getp_data__rng_s2
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesMonitorData_getp_data__rng_s3(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__rng_s3(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__rng_s3(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__rng_s3(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__rng_s3 _cffi_d_ParticlesMonitorData_getp_data__rng_s3
#endif

static struct ArrNUint32_s * _cffi_d_ParticlesMonitorData_getp_data__rng_s4(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data__rng_s4(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data__rng_s4(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNUint32_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data__rng_s4(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(234));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data__rng_s4 _cffi_d_ParticlesMonitorData_getp_data__rng_s4
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_at_element(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_at_element _cffi_d_ParticlesMonitorData_getp_data_at_element
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_at_turn _cffi_d_ParticlesMonitorData_getp_data_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_beta0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_beta0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_beta0 _cffi_d_ParticlesMonitorData_getp_data_beta0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_charge_ratio(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_charge_ratio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_charge_ratio(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_charge_ratio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_charge_ratio _cffi_d_ParticlesMonitorData_getp_data_charge_ratio
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_chi(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_chi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_chi(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_chi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_chi _cffi_d_ParticlesMonitorData_getp_data_chi
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_delta(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_delta(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_delta _cffi_d_ParticlesMonitorData_getp_data_delta
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_gamma0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_gamma0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_gamma0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_gamma0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_gamma0 _cffi_d_ParticlesMonitorData_getp_data_gamma0
#endif

static double * _cffi_d_ParticlesMonitorData_getp_data_mass0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_mass0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_mass0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_mass0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_mass0 _cffi_d_ParticlesMonitorData_getp_data_mass0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_p0c(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_p0c(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_p0c(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_p0c(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_p0c _cffi_d_ParticlesMonitorData_getp_data_p0c
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_parent_particle_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_parent_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_parent_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_parent_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_parent_particle_id _cffi_d_ParticlesMonitorData_getp_data_parent_particle_id
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_particle_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_particle_id _cffi_d_ParticlesMonitorData_getp_data_particle_id
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_pdg_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_pdg_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_pdg_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_pdg_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_pdg_id _cffi_d_ParticlesMonitorData_getp_data_pdg_id
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_ptau(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_ptau(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_ptau(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_ptau(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_ptau _cffi_d_ParticlesMonitorData_getp_data_ptau
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_px(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_px(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_px _cffi_d_ParticlesMonitorData_getp_data_px
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_py(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_py(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_py _cffi_d_ParticlesMonitorData_getp_data_py
#endif

static double * _cffi_d_ParticlesMonitorData_getp_data_q0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_q0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_q0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_q0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_q0 _cffi_d_ParticlesMonitorData_getp_data_q0
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_rpp(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_rpp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_rpp(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_rpp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_rpp _cffi_d_ParticlesMonitorData_getp_data_rpp
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_rvv(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_rvv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_rvv(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_rvv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_rvv _cffi_d_ParticlesMonitorData_getp_data_rvv
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_s(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_s(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_s(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_s(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_s _cffi_d_ParticlesMonitorData_getp_data_s
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_data_start_tracking_at_element(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_start_tracking_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_start_tracking_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_start_tracking_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_start_tracking_at_element _cffi_d_ParticlesMonitorData_getp_data_start_tracking_at_element
#endif

static struct ArrNInt64_s * _cffi_d_ParticlesMonitorData_getp_data_state(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_state(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_state _cffi_d_ParticlesMonitorData_getp_data_state
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_weight(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_weight(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_weight(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_weight(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_weight _cffi_d_ParticlesMonitorData_getp_data_weight
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_x(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_x(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_x _cffi_d_ParticlesMonitorData_getp_data_x
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_y(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_y(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_y _cffi_d_ParticlesMonitorData_getp_data_y
#endif

static struct ArrNFloat64_s * _cffi_d_ParticlesMonitorData_getp_data_zeta(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_data_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_data_zeta(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_data_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_data_zeta _cffi_d_ParticlesMonitorData_getp_data_zeta
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_ebe_mode(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_ebe_mode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_ebe_mode(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_ebe_mode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_ebe_mode _cffi_d_ParticlesMonitorData_getp_ebe_mode
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_flag_auto_to_numpy(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_flag_auto_to_numpy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_flag_auto_to_numpy(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_flag_auto_to_numpy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_flag_auto_to_numpy _cffi_d_ParticlesMonitorData_getp_flag_auto_to_numpy
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_n_records(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_n_records(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_n_records(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_n_records(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_n_records _cffi_d_ParticlesMonitorData_getp_n_records
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_n_repetitions(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_n_repetitions(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_n_repetitions(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_n_repetitions(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_n_repetitions _cffi_d_ParticlesMonitorData_getp_n_repetitions
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_part_id_end(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_part_id_end(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_part_id_end(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_part_id_end(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_part_id_end _cffi_d_ParticlesMonitorData_getp_part_id_end
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_part_id_start(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_part_id_start(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_part_id_start(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_part_id_start(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_part_id_start _cffi_d_ParticlesMonitorData_getp_part_id_start
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_repetition_period(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_repetition_period(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_repetition_period(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_repetition_period(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_repetition_period _cffi_d_ParticlesMonitorData_getp_repetition_period
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_start_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_start_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_start_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_start_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_start_at_turn _cffi_d_ParticlesMonitorData_getp_start_at_turn
#endif

static int64_t * _cffi_d_ParticlesMonitorData_getp_stop_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_getp_stop_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_getp_stop_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_getp_stop_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_getp_stop_at_turn _cffi_d_ParticlesMonitorData_getp_stop_at_turn
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data__rng_s1(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data__rng_s1(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data__rng_s1(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data__rng_s1(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data__rng_s1 _cffi_d_ParticlesMonitorData_len_data__rng_s1
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data__rng_s2(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data__rng_s2(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data__rng_s2(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data__rng_s2(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data__rng_s2 _cffi_d_ParticlesMonitorData_len_data__rng_s2
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data__rng_s3(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data__rng_s3(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data__rng_s3(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data__rng_s3(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data__rng_s3 _cffi_d_ParticlesMonitorData_len_data__rng_s3
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data__rng_s4(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data__rng_s4(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data__rng_s4(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data__rng_s4(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data__rng_s4 _cffi_d_ParticlesMonitorData_len_data__rng_s4
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_at_element(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_at_element(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_at_element _cffi_d_ParticlesMonitorData_len_data_at_element
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_at_turn(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_at_turn(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_at_turn _cffi_d_ParticlesMonitorData_len_data_at_turn
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_beta0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_beta0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_beta0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_beta0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_beta0 _cffi_d_ParticlesMonitorData_len_data_beta0
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_charge_ratio(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_charge_ratio(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_charge_ratio(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_charge_ratio(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_charge_ratio _cffi_d_ParticlesMonitorData_len_data_charge_ratio
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_chi(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_chi(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_chi(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_chi(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_chi _cffi_d_ParticlesMonitorData_len_data_chi
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_delta(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_delta(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_delta _cffi_d_ParticlesMonitorData_len_data_delta
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_gamma0(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_gamma0(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_gamma0(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_gamma0(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_gamma0 _cffi_d_ParticlesMonitorData_len_data_gamma0
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_p0c(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_p0c(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_p0c(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_p0c(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_p0c _cffi_d_ParticlesMonitorData_len_data_p0c
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_parent_particle_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_parent_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_parent_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_parent_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_parent_particle_id _cffi_d_ParticlesMonitorData_len_data_parent_particle_id
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_particle_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_particle_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_particle_id _cffi_d_ParticlesMonitorData_len_data_particle_id
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_pdg_id(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_pdg_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_pdg_id(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_pdg_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_pdg_id _cffi_d_ParticlesMonitorData_len_data_pdg_id
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_ptau(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_ptau(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_ptau(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_ptau(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_ptau _cffi_d_ParticlesMonitorData_len_data_ptau
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_px(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_px(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_px(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_px(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_px _cffi_d_ParticlesMonitorData_len_data_px
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_py(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_py(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_py(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_py(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_py _cffi_d_ParticlesMonitorData_len_data_py
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_rpp(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_rpp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_rpp(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_rpp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_rpp _cffi_d_ParticlesMonitorData_len_data_rpp
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_rvv(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_rvv(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_rvv(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_rvv(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_rvv _cffi_d_ParticlesMonitorData_len_data_rvv
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_s(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_s(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_s(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_s(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_s _cffi_d_ParticlesMonitorData_len_data_s
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_state(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_state(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_state _cffi_d_ParticlesMonitorData_len_data_state
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_weight(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_weight(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_weight(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_weight(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_weight _cffi_d_ParticlesMonitorData_len_data_weight
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_x(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_x(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_x _cffi_d_ParticlesMonitorData_len_data_x
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_y(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_y(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_y _cffi_d_ParticlesMonitorData_len_data_y
#endif

static int64_t _cffi_d_ParticlesMonitorData_len_data_zeta(struct ParticlesMonitorData_s * x0)
{
  return ParticlesMonitorData_len_data_zeta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_len_data_zeta(PyObject *self, PyObject *arg0)
{
  struct ParticlesMonitorData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = ParticlesMonitorData_len_data_zeta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_ParticlesMonitorData_len_data_zeta _cffi_d_ParticlesMonitorData_len_data_zeta
#endif

static void _cffi_d_ParticlesMonitorData_set_data__capacity(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_data__capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__capacity(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__capacity _cffi_d_ParticlesMonitorData_set_data__capacity
#endif

static void _cffi_d_ParticlesMonitorData_set_data__num_active_particles(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_data__num_active_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__num_active_particles(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__num_active_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__num_active_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__num_active_particles _cffi_d_ParticlesMonitorData_set_data__num_active_particles
#endif

static void _cffi_d_ParticlesMonitorData_set_data__num_lost_particles(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_data__num_lost_particles(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__num_lost_particles(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__num_lost_particles", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__num_lost_particles(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__num_lost_particles _cffi_d_ParticlesMonitorData_set_data__num_lost_particles
#endif

static void _cffi_d_ParticlesMonitorData_set_data__rng_s1(struct ParticlesMonitorData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesMonitorData_set_data__rng_s1(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__rng_s1(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__rng_s1", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__rng_s1(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__rng_s1 _cffi_d_ParticlesMonitorData_set_data__rng_s1
#endif

static void _cffi_d_ParticlesMonitorData_set_data__rng_s2(struct ParticlesMonitorData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesMonitorData_set_data__rng_s2(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__rng_s2(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__rng_s2", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__rng_s2(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__rng_s2 _cffi_d_ParticlesMonitorData_set_data__rng_s2
#endif

static void _cffi_d_ParticlesMonitorData_set_data__rng_s3(struct ParticlesMonitorData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesMonitorData_set_data__rng_s3(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__rng_s3(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__rng_s3", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__rng_s3(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__rng_s3 _cffi_d_ParticlesMonitorData_set_data__rng_s3
#endif

static void _cffi_d_ParticlesMonitorData_set_data__rng_s4(struct ParticlesMonitorData_s * x0, int64_t x1, uint32_t x2)
{
  ParticlesMonitorData_set_data__rng_s4(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data__rng_s4(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  uint32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data__rng_s4", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, uint32_t);
  if (x2 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data__rng_s4(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data__rng_s4 _cffi_d_ParticlesMonitorData_set_data__rng_s4
#endif

static void _cffi_d_ParticlesMonitorData_set_data_at_element(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_at_element _cffi_d_ParticlesMonitorData_set_data_at_element
#endif

static void _cffi_d_ParticlesMonitorData_set_data_at_turn(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_at_turn _cffi_d_ParticlesMonitorData_set_data_at_turn
#endif

static void _cffi_d_ParticlesMonitorData_set_data_beta0(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_beta0(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_beta0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_beta0", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_beta0(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_beta0 _cffi_d_ParticlesMonitorData_set_data_beta0
#endif

static void _cffi_d_ParticlesMonitorData_set_data_charge_ratio(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_charge_ratio(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_charge_ratio(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_charge_ratio", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_charge_ratio(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_charge_ratio _cffi_d_ParticlesMonitorData_set_data_charge_ratio
#endif

static void _cffi_d_ParticlesMonitorData_set_data_chi(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_chi(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_chi(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_chi", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_chi(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_chi _cffi_d_ParticlesMonitorData_set_data_chi
#endif

static void _cffi_d_ParticlesMonitorData_set_data_delta(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_delta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_delta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_delta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_delta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_delta _cffi_d_ParticlesMonitorData_set_data_delta
#endif

static void _cffi_d_ParticlesMonitorData_set_data_gamma0(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_gamma0(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_gamma0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_gamma0", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_gamma0(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_gamma0 _cffi_d_ParticlesMonitorData_set_data_gamma0
#endif

static void _cffi_d_ParticlesMonitorData_set_data_mass0(struct ParticlesMonitorData_s * x0, double x1)
{
  ParticlesMonitorData_set_data_mass0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_mass0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_mass0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_mass0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_mass0 _cffi_d_ParticlesMonitorData_set_data_mass0
#endif

static void _cffi_d_ParticlesMonitorData_set_data_p0c(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_p0c(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_p0c(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_p0c", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_p0c(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_p0c _cffi_d_ParticlesMonitorData_set_data_p0c
#endif

static void _cffi_d_ParticlesMonitorData_set_data_parent_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_parent_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_parent_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_parent_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_parent_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_parent_particle_id _cffi_d_ParticlesMonitorData_set_data_parent_particle_id
#endif

static void _cffi_d_ParticlesMonitorData_set_data_particle_id(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_particle_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_particle_id _cffi_d_ParticlesMonitorData_set_data_particle_id
#endif

static void _cffi_d_ParticlesMonitorData_set_data_pdg_id(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_pdg_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_pdg_id(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_pdg_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_pdg_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_pdg_id _cffi_d_ParticlesMonitorData_set_data_pdg_id
#endif

static void _cffi_d_ParticlesMonitorData_set_data_ptau(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_ptau(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_ptau(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_ptau", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_ptau(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_ptau _cffi_d_ParticlesMonitorData_set_data_ptau
#endif

static void _cffi_d_ParticlesMonitorData_set_data_px(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_px(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_px(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_px", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_px(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_px _cffi_d_ParticlesMonitorData_set_data_px
#endif

static void _cffi_d_ParticlesMonitorData_set_data_py(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_py(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_py(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_py", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_py(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_py _cffi_d_ParticlesMonitorData_set_data_py
#endif

static void _cffi_d_ParticlesMonitorData_set_data_q0(struct ParticlesMonitorData_s * x0, double x1)
{
  ParticlesMonitorData_set_data_q0(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_q0(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_q0", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_q0(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_q0 _cffi_d_ParticlesMonitorData_set_data_q0
#endif

static void _cffi_d_ParticlesMonitorData_set_data_rpp(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_rpp(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_rpp(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_rpp", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_rpp(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_rpp _cffi_d_ParticlesMonitorData_set_data_rpp
#endif

static void _cffi_d_ParticlesMonitorData_set_data_rvv(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_rvv(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_rvv(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_rvv", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_rvv(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_rvv _cffi_d_ParticlesMonitorData_set_data_rvv
#endif

static void _cffi_d_ParticlesMonitorData_set_data_s(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_s(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_s(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_s", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_s(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_s _cffi_d_ParticlesMonitorData_set_data_s
#endif

static void _cffi_d_ParticlesMonitorData_set_data_start_tracking_at_element(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_data_start_tracking_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_start_tracking_at_element(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_start_tracking_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_start_tracking_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_start_tracking_at_element _cffi_d_ParticlesMonitorData_set_data_start_tracking_at_element
#endif

static void _cffi_d_ParticlesMonitorData_set_data_state(struct ParticlesMonitorData_s * x0, int64_t x1, int64_t x2)
{
  ParticlesMonitorData_set_data_state(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_state(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_state", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_state(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_state _cffi_d_ParticlesMonitorData_set_data_state
#endif

static void _cffi_d_ParticlesMonitorData_set_data_weight(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_weight(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_weight(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_weight", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_weight(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_weight _cffi_d_ParticlesMonitorData_set_data_weight
#endif

static void _cffi_d_ParticlesMonitorData_set_data_x(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_x(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_x(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_x", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_x(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_x _cffi_d_ParticlesMonitorData_set_data_x
#endif

static void _cffi_d_ParticlesMonitorData_set_data_y(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_y(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_y(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_y", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_y(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_y _cffi_d_ParticlesMonitorData_set_data_y
#endif

static void _cffi_d_ParticlesMonitorData_set_data_zeta(struct ParticlesMonitorData_s * x0, int64_t x1, double x2)
{
  ParticlesMonitorData_set_data_zeta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_data_zeta(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_data_zeta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_data_zeta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_data_zeta _cffi_d_ParticlesMonitorData_set_data_zeta
#endif

static void _cffi_d_ParticlesMonitorData_set_ebe_mode(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_ebe_mode(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_ebe_mode(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_ebe_mode", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_ebe_mode(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_ebe_mode _cffi_d_ParticlesMonitorData_set_ebe_mode
#endif

static void _cffi_d_ParticlesMonitorData_set_flag_auto_to_numpy(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_flag_auto_to_numpy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_flag_auto_to_numpy(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_flag_auto_to_numpy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_flag_auto_to_numpy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_flag_auto_to_numpy _cffi_d_ParticlesMonitorData_set_flag_auto_to_numpy
#endif

static void _cffi_d_ParticlesMonitorData_set_n_records(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_n_records(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_n_records(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_n_records", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_n_records(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_n_records _cffi_d_ParticlesMonitorData_set_n_records
#endif

static void _cffi_d_ParticlesMonitorData_set_n_repetitions(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_n_repetitions(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_n_repetitions(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_n_repetitions", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_n_repetitions(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_n_repetitions _cffi_d_ParticlesMonitorData_set_n_repetitions
#endif

static void _cffi_d_ParticlesMonitorData_set_part_id_end(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_part_id_end(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_part_id_end(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_part_id_end", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_part_id_end(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_part_id_end _cffi_d_ParticlesMonitorData_set_part_id_end
#endif

static void _cffi_d_ParticlesMonitorData_set_part_id_start(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_part_id_start(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_part_id_start(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_part_id_start", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_part_id_start(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_part_id_start _cffi_d_ParticlesMonitorData_set_part_id_start
#endif

static void _cffi_d_ParticlesMonitorData_set_repetition_period(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_repetition_period(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_repetition_period(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_repetition_period", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_repetition_period(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_repetition_period _cffi_d_ParticlesMonitorData_set_repetition_period
#endif

static void _cffi_d_ParticlesMonitorData_set_start_at_turn(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_start_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_start_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_start_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_start_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_start_at_turn _cffi_d_ParticlesMonitorData_set_start_at_turn
#endif

static void _cffi_d_ParticlesMonitorData_set_stop_at_turn(struct ParticlesMonitorData_s * x0, int64_t x1)
{
  ParticlesMonitorData_set_stop_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_ParticlesMonitorData_set_stop_at_turn(PyObject *self, PyObject *args)
{
  struct ParticlesMonitorData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "ParticlesMonitorData_set_stop_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesMonitorData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(62), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { ParticlesMonitorData_set_stop_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_ParticlesMonitorData_set_stop_at_turn _cffi_d_ParticlesMonitorData_set_stop_at_turn
#endif

static void _cffi_d_Particles_initialize_rand_gen(struct ParticlesData_s * x0, uint32_t * x1, int32_t x2)
{
  Particles_initialize_rand_gen(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_Particles_initialize_rand_gen(PyObject *self, PyObject *args)
{
  struct ParticlesData_s * x0;
  uint32_t * x1;
  int32_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "Particles_initialize_rand_gen", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(753), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (uint32_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(753), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int32_t);
  if (x2 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { Particles_initialize_rand_gen(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_Particles_initialize_rand_gen _cffi_d_Particles_initialize_rand_gen
#endif

static uint8_t _cffi_d_RandomExponentialData_get__dummy(struct RandomExponentialData_s * x0)
{
  return RandomExponentialData_get__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomExponentialData_get__dummy(PyObject *self, PyObject *arg0)
{
  struct RandomExponentialData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint8_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(454), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomExponentialData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(454), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomExponentialData_get__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint8_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomExponentialData_get__dummy _cffi_d_RandomExponentialData_get__dummy
#endif

static struct RandomExponentialData_s * _cffi_d_RandomExponentialData_getp(struct RandomExponentialData_s * x0)
{
  return RandomExponentialData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomExponentialData_getp(PyObject *self, PyObject *arg0)
{
  struct RandomExponentialData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RandomExponentialData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(454), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomExponentialData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(454), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomExponentialData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(454));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomExponentialData_getp _cffi_d_RandomExponentialData_getp
#endif

static uint8_t * _cffi_d_RandomExponentialData_getp__dummy(struct RandomExponentialData_s * x0)
{
  return RandomExponentialData_getp__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomExponentialData_getp__dummy(PyObject *self, PyObject *arg0)
{
  struct RandomExponentialData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint8_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(454), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomExponentialData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(454), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomExponentialData_getp__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(853));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomExponentialData_getp__dummy _cffi_d_RandomExponentialData_getp__dummy
#endif

static void _cffi_d_RandomExponentialData_set__dummy(struct RandomExponentialData_s * x0, uint8_t x1)
{
  RandomExponentialData_set__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomExponentialData_set__dummy(PyObject *self, PyObject *args)
{
  struct RandomExponentialData_s * x0;
  uint8_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RandomExponentialData_set__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(454), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomExponentialData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(454), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RandomExponentialData_set__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RandomExponentialData_set__dummy _cffi_d_RandomExponentialData_set__dummy
#endif

static uint8_t _cffi_d_RandomUniformData_get__dummy(struct RandomUniformData_s * x0)
{
  return RandomUniformData_get__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomUniformData_get__dummy(PyObject *self, PyObject *arg0)
{
  struct RandomUniformData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint8_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(457), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomUniformData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(457), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomUniformData_get__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint8_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomUniformData_get__dummy _cffi_d_RandomUniformData_get__dummy
#endif

static struct RandomUniformData_s * _cffi_d_RandomUniformData_getp(struct RandomUniformData_s * x0)
{
  return RandomUniformData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomUniformData_getp(PyObject *self, PyObject *arg0)
{
  struct RandomUniformData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RandomUniformData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(457), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomUniformData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(457), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomUniformData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(457));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomUniformData_getp _cffi_d_RandomUniformData_getp
#endif

static uint8_t * _cffi_d_RandomUniformData_getp__dummy(struct RandomUniformData_s * x0)
{
  return RandomUniformData_getp__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomUniformData_getp__dummy(PyObject *self, PyObject *arg0)
{
  struct RandomUniformData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint8_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(457), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomUniformData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(457), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RandomUniformData_getp__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(853));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RandomUniformData_getp__dummy _cffi_d_RandomUniformData_getp__dummy
#endif

static void _cffi_d_RandomUniformData_set__dummy(struct RandomUniformData_s * x0, uint8_t x1)
{
  RandomUniformData_set__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RandomUniformData_set__dummy(PyObject *self, PyObject *args)
{
  struct RandomUniformData_s * x0;
  uint8_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RandomUniformData_set__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(457), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RandomUniformData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(457), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint8_t);
  if (x1 == (uint8_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RandomUniformData_set__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RandomUniformData_set__dummy _cffi_d_RandomUniformData_set__dummy
#endif

static int64_t _cffi_d_RecordIdentifier_get_buffer_id(struct RecordIdentifier_s * x0)
{
  return RecordIdentifier_get_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_get_buffer_id(PyObject *self, PyObject *arg0)
{
  struct RecordIdentifier_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIdentifier_get_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIdentifier_get_buffer_id _cffi_d_RecordIdentifier_get_buffer_id
#endif

static int64_t _cffi_d_RecordIdentifier_get_offset(struct RecordIdentifier_s * x0)
{
  return RecordIdentifier_get_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_get_offset(PyObject *self, PyObject *arg0)
{
  struct RecordIdentifier_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIdentifier_get_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIdentifier_get_offset _cffi_d_RecordIdentifier_get_offset
#endif

static struct RecordIdentifier_s * _cffi_d_RecordIdentifier_getp(struct RecordIdentifier_s * x0)
{
  return RecordIdentifier_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_getp(PyObject *self, PyObject *arg0)
{
  struct RecordIdentifier_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIdentifier_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIdentifier_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(201));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIdentifier_getp _cffi_d_RecordIdentifier_getp
#endif

static int64_t * _cffi_d_RecordIdentifier_getp_buffer_id(struct RecordIdentifier_s * x0)
{
  return RecordIdentifier_getp_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_getp_buffer_id(PyObject *self, PyObject *arg0)
{
  struct RecordIdentifier_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIdentifier_getp_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIdentifier_getp_buffer_id _cffi_d_RecordIdentifier_getp_buffer_id
#endif

static int64_t * _cffi_d_RecordIdentifier_getp_offset(struct RecordIdentifier_s * x0)
{
  return RecordIdentifier_getp_offset(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_getp_offset(PyObject *self, PyObject *arg0)
{
  struct RecordIdentifier_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIdentifier_getp_offset(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIdentifier_getp_offset _cffi_d_RecordIdentifier_getp_offset
#endif

static void _cffi_d_RecordIdentifier_set_buffer_id(struct RecordIdentifier_s * x0, int64_t x1)
{
  RecordIdentifier_set_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_set_buffer_id(PyObject *self, PyObject *args)
{
  struct RecordIdentifier_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIdentifier_set_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIdentifier_set_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIdentifier_set_buffer_id _cffi_d_RecordIdentifier_set_buffer_id
#endif

static void _cffi_d_RecordIdentifier_set_offset(struct RecordIdentifier_s * x0, int64_t x1)
{
  RecordIdentifier_set_offset(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIdentifier_set_offset(PyObject *self, PyObject *args)
{
  struct RecordIdentifier_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIdentifier_set_offset", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(201), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIdentifier_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(201), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIdentifier_set_offset(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIdentifier_set_offset _cffi_d_RecordIdentifier_set_offset
#endif

static uint32_t _cffi_d_RecordIndex_get__dummy(struct RecordIndex_s * x0)
{
  return RecordIndex_get__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_get__dummy(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_get__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_get__dummy _cffi_d_RecordIndex_get__dummy
#endif

static int64_t _cffi_d_RecordIndex_get_buffer_id(struct RecordIndex_s * x0)
{
  return RecordIndex_get_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_get_buffer_id(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_get_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_get_buffer_id _cffi_d_RecordIndex_get_buffer_id
#endif

static int64_t _cffi_d_RecordIndex_get_capacity(struct RecordIndex_s * x0)
{
  return RecordIndex_get_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_get_capacity(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_get_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_get_capacity _cffi_d_RecordIndex_get_capacity
#endif

static uint32_t _cffi_d_RecordIndex_get_num_recorded(struct RecordIndex_s * x0)
{
  return RecordIndex_get_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_get_num_recorded(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_get_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_get_num_recorded _cffi_d_RecordIndex_get_num_recorded
#endif

static struct RecordIndex_s * _cffi_d_RecordIndex_getp(struct RecordIndex_s * x0)
{
  return RecordIndex_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_getp(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_getp _cffi_d_RecordIndex_getp
#endif

static uint32_t * _cffi_d_RecordIndex_getp__dummy(struct RecordIndex_s * x0)
{
  return RecordIndex_getp__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_getp__dummy(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_getp__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_getp__dummy _cffi_d_RecordIndex_getp__dummy
#endif

static int64_t * _cffi_d_RecordIndex_getp_buffer_id(struct RecordIndex_s * x0)
{
  return RecordIndex_getp_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_getp_buffer_id(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_getp_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_getp_buffer_id _cffi_d_RecordIndex_getp_buffer_id
#endif

static int64_t * _cffi_d_RecordIndex_getp_capacity(struct RecordIndex_s * x0)
{
  return RecordIndex_getp_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_getp_capacity(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_getp_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_getp_capacity _cffi_d_RecordIndex_getp_capacity
#endif

static uint32_t * _cffi_d_RecordIndex_getp_num_recorded(struct RecordIndex_s * x0)
{
  return RecordIndex_getp_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_getp_num_recorded(PyObject *self, PyObject *arg0)
{
  struct RecordIndex_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = RecordIndex_getp_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_RecordIndex_getp_num_recorded _cffi_d_RecordIndex_getp_num_recorded
#endif

static void _cffi_d_RecordIndex_set__dummy(struct RecordIndex_s * x0, uint32_t x1)
{
  RecordIndex_set__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_set__dummy(PyObject *self, PyObject *args)
{
  struct RecordIndex_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIndex_set__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIndex_set__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIndex_set__dummy _cffi_d_RecordIndex_set__dummy
#endif

static void _cffi_d_RecordIndex_set_buffer_id(struct RecordIndex_s * x0, int64_t x1)
{
  RecordIndex_set_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_set_buffer_id(PyObject *self, PyObject *args)
{
  struct RecordIndex_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIndex_set_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIndex_set_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIndex_set_buffer_id _cffi_d_RecordIndex_set_buffer_id
#endif

static void _cffi_d_RecordIndex_set_capacity(struct RecordIndex_s * x0, int64_t x1)
{
  RecordIndex_set_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_set_capacity(PyObject *self, PyObject *args)
{
  struct RecordIndex_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIndex_set_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIndex_set_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIndex_set_capacity _cffi_d_RecordIndex_set_capacity
#endif

static void _cffi_d_RecordIndex_set_num_recorded(struct RecordIndex_s * x0, uint32_t x1)
{
  RecordIndex_set_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_RecordIndex_set_num_recorded(PyObject *self, PyObject *args)
{
  struct RecordIndex_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "RecordIndex_set_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(204), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct RecordIndex_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(204), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { RecordIndex_set_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_RecordIndex_set_num_recorded _cffi_d_RecordIndex_set_num_recorded
#endif

static double _cffi_d_SRotationData_get_cos_z(struct SRotationData_s * x0)
{
  return SRotationData_get_cos_z(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_get_cos_z(PyObject *self, PyObject *arg0)
{
  struct SRotationData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SRotationData_get_cos_z(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SRotationData_get_cos_z _cffi_d_SRotationData_get_cos_z
#endif

static double _cffi_d_SRotationData_get_sin_z(struct SRotationData_s * x0)
{
  return SRotationData_get_sin_z(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_get_sin_z(PyObject *self, PyObject *arg0)
{
  struct SRotationData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SRotationData_get_sin_z(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SRotationData_get_sin_z _cffi_d_SRotationData_get_sin_z
#endif

static struct SRotationData_s * _cffi_d_SRotationData_getp(struct SRotationData_s * x0)
{
  return SRotationData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_getp(PyObject *self, PyObject *arg0)
{
  struct SRotationData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct SRotationData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SRotationData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(69));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SRotationData_getp _cffi_d_SRotationData_getp
#endif

static double * _cffi_d_SRotationData_getp_cos_z(struct SRotationData_s * x0)
{
  return SRotationData_getp_cos_z(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_getp_cos_z(PyObject *self, PyObject *arg0)
{
  struct SRotationData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SRotationData_getp_cos_z(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SRotationData_getp_cos_z _cffi_d_SRotationData_getp_cos_z
#endif

static double * _cffi_d_SRotationData_getp_sin_z(struct SRotationData_s * x0)
{
  return SRotationData_getp_sin_z(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_getp_sin_z(PyObject *self, PyObject *arg0)
{
  struct SRotationData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SRotationData_getp_sin_z(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SRotationData_getp_sin_z _cffi_d_SRotationData_getp_sin_z
#endif

static void _cffi_d_SRotationData_set_cos_z(struct SRotationData_s * x0, double x1)
{
  SRotationData_set_cos_z(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_set_cos_z(PyObject *self, PyObject *args)
{
  struct SRotationData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SRotationData_set_cos_z", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SRotationData_set_cos_z(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SRotationData_set_cos_z _cffi_d_SRotationData_set_cos_z
#endif

static void _cffi_d_SRotationData_set_sin_z(struct SRotationData_s * x0, double x1)
{
  SRotationData_set_sin_z(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SRotationData_set_sin_z(PyObject *self, PyObject *args)
{
  struct SRotationData_s * x0;
  double x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SRotationData_set_sin_z", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(69), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SRotationData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(69), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SRotationData_set_sin_z(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SRotationData_set_sin_z _cffi_d_SRotationData_set_sin_z
#endif

static uint32_t _cffi_d_SynchrotronRadiationRecordData_get__index__dummy(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_get__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get__index__dummy(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get__index__dummy _cffi_d_SynchrotronRadiationRecordData_get__index__dummy
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_get__index_buffer_id(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_get__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get__index_buffer_id _cffi_d_SynchrotronRadiationRecordData_get__index_buffer_id
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_get__index_capacity(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_get__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get__index_capacity(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get__index_capacity _cffi_d_SynchrotronRadiationRecordData_get__index_capacity
#endif

static uint32_t _cffi_d_SynchrotronRadiationRecordData_get__index_num_recorded(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_get__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, uint32_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get__index_num_recorded _cffi_d_SynchrotronRadiationRecordData_get__index_num_recorded
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_get_at_element(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_get_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get_at_element(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_get_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get_at_element _cffi_d_SynchrotronRadiationRecordData_get_at_element
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_get_at_turn(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_get_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get_at_turn(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_get_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get_at_turn _cffi_d_SynchrotronRadiationRecordData_get_at_turn
#endif

static double _cffi_d_SynchrotronRadiationRecordData_get_particle_delta(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_get_particle_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get_particle_delta(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_get_particle_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get_particle_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get_particle_delta _cffi_d_SynchrotronRadiationRecordData_get_particle_delta
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_get_particle_id(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_get_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get_particle_id(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_get_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get_particle_id _cffi_d_SynchrotronRadiationRecordData_get_particle_id
#endif

static double _cffi_d_SynchrotronRadiationRecordData_get_photon_energy(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_get_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_get_photon_energy(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_get_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_get_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_double(result);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_get_photon_energy _cffi_d_SynchrotronRadiationRecordData_get_photon_energy
#endif

static struct SynchrotronRadiationRecordData_s * _cffi_d_SynchrotronRadiationRecordData_getp(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct SynchrotronRadiationRecordData_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(72));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp _cffi_d_SynchrotronRadiationRecordData_getp
#endif

static int64_t * _cffi_d_SynchrotronRadiationRecordData_getp1_at_element(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_getp1_at_element(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp1_at_element(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_getp1_at_element", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp1_at_element(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp1_at_element _cffi_d_SynchrotronRadiationRecordData_getp1_at_element
#endif

static int64_t * _cffi_d_SynchrotronRadiationRecordData_getp1_at_turn(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_getp1_at_turn(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp1_at_turn(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_getp1_at_turn", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp1_at_turn(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp1_at_turn _cffi_d_SynchrotronRadiationRecordData_getp1_at_turn
#endif

static double * _cffi_d_SynchrotronRadiationRecordData_getp1_particle_delta(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_getp1_particle_delta(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp1_particle_delta(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_getp1_particle_delta", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp1_particle_delta(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp1_particle_delta _cffi_d_SynchrotronRadiationRecordData_getp1_particle_delta
#endif

static int64_t * _cffi_d_SynchrotronRadiationRecordData_getp1_particle_id(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_getp1_particle_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp1_particle_id(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_getp1_particle_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp1_particle_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp1_particle_id _cffi_d_SynchrotronRadiationRecordData_getp1_particle_id
#endif

static double * _cffi_d_SynchrotronRadiationRecordData_getp1_photon_energy(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  return SynchrotronRadiationRecordData_getp1_photon_energy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp1_photon_energy(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  double * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_getp1_photon_energy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp1_photon_energy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(823));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp1_photon_energy _cffi_d_SynchrotronRadiationRecordData_getp1_photon_energy
#endif

static struct RecordIndex_s * _cffi_d_SynchrotronRadiationRecordData_getp__index(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp__index(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp__index(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct RecordIndex_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp__index(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(204));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp__index _cffi_d_SynchrotronRadiationRecordData_getp__index
#endif

static uint32_t * _cffi_d_SynchrotronRadiationRecordData_getp__index__dummy(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp__index__dummy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp__index__dummy(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp__index__dummy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp__index__dummy _cffi_d_SynchrotronRadiationRecordData_getp__index__dummy
#endif

static int64_t * _cffi_d_SynchrotronRadiationRecordData_getp__index_buffer_id(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp__index_buffer_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp__index_buffer_id(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp__index_buffer_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp__index_buffer_id _cffi_d_SynchrotronRadiationRecordData_getp__index_buffer_id
#endif

static int64_t * _cffi_d_SynchrotronRadiationRecordData_getp__index_capacity(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp__index_capacity(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp__index_capacity(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp__index_capacity(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(825));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp__index_capacity _cffi_d_SynchrotronRadiationRecordData_getp__index_capacity
#endif

static uint32_t * _cffi_d_SynchrotronRadiationRecordData_getp__index_num_recorded(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp__index_num_recorded(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp__index_num_recorded(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  uint32_t * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp__index_num_recorded(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(753));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp__index_num_recorded _cffi_d_SynchrotronRadiationRecordData_getp__index_num_recorded
#endif

static struct ArrNInt64_s * _cffi_d_SynchrotronRadiationRecordData_getp_at_element(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp_at_element(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp_at_element _cffi_d_SynchrotronRadiationRecordData_getp_at_element
#endif

static struct ArrNInt64_s * _cffi_d_SynchrotronRadiationRecordData_getp_at_turn(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp_at_turn(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp_at_turn _cffi_d_SynchrotronRadiationRecordData_getp_at_turn
#endif

static struct ArrNFloat64_s * _cffi_d_SynchrotronRadiationRecordData_getp_particle_delta(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp_particle_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp_particle_delta(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp_particle_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp_particle_delta _cffi_d_SynchrotronRadiationRecordData_getp_particle_delta
#endif

static struct ArrNInt64_s * _cffi_d_SynchrotronRadiationRecordData_getp_particle_id(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp_particle_id(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNInt64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(143));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp_particle_id _cffi_d_SynchrotronRadiationRecordData_getp_particle_id
#endif

static struct ArrNFloat64_s * _cffi_d_SynchrotronRadiationRecordData_getp_photon_energy(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_getp_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_getp_photon_energy(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  struct ArrNFloat64_s * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_getp_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(9));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_getp_photon_energy _cffi_d_SynchrotronRadiationRecordData_getp_photon_energy
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_len_at_element(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_len_at_element(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_len_at_element(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_len_at_element(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_len_at_element _cffi_d_SynchrotronRadiationRecordData_len_at_element
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_len_at_turn(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_len_at_turn(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_len_at_turn(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_len_at_turn(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_len_at_turn _cffi_d_SynchrotronRadiationRecordData_len_at_turn
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_len_particle_delta(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_len_particle_delta(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_len_particle_delta(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_len_particle_delta(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_len_particle_delta _cffi_d_SynchrotronRadiationRecordData_len_particle_delta
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_len_particle_id(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_len_particle_id(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_len_particle_id(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_len_particle_id(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_len_particle_id _cffi_d_SynchrotronRadiationRecordData_len_particle_id
#endif

static int64_t _cffi_d_SynchrotronRadiationRecordData_len_photon_energy(struct SynchrotronRadiationRecordData_s * x0)
{
  return SynchrotronRadiationRecordData_len_photon_energy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_len_photon_energy(PyObject *self, PyObject *arg0)
{
  struct SynchrotronRadiationRecordData_s * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int64_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = SynchrotronRadiationRecordData_len_photon_energy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int64_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_len_photon_energy _cffi_d_SynchrotronRadiationRecordData_len_photon_energy
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set__index__dummy(struct SynchrotronRadiationRecordData_s * x0, uint32_t x1)
{
  SynchrotronRadiationRecordData_set__index__dummy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set__index__dummy(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set__index__dummy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set__index__dummy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set__index__dummy _cffi_d_SynchrotronRadiationRecordData_set__index__dummy
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set__index_buffer_id(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  SynchrotronRadiationRecordData_set__index_buffer_id(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set__index_buffer_id(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set__index_buffer_id", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set__index_buffer_id(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set__index_buffer_id _cffi_d_SynchrotronRadiationRecordData_set__index_buffer_id
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set__index_capacity(struct SynchrotronRadiationRecordData_s * x0, int64_t x1)
{
  SynchrotronRadiationRecordData_set__index_capacity(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set__index_capacity(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set__index_capacity", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set__index_capacity(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set__index_capacity _cffi_d_SynchrotronRadiationRecordData_set__index_capacity
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set__index_num_recorded(struct SynchrotronRadiationRecordData_s * x0, uint32_t x1)
{
  SynchrotronRadiationRecordData_set__index_num_recorded(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set__index_num_recorded(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  uint32_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set__index_num_recorded", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint32_t);
  if (x1 == (uint32_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set__index_num_recorded(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set__index_num_recorded _cffi_d_SynchrotronRadiationRecordData_set__index_num_recorded
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set_at_element(struct SynchrotronRadiationRecordData_s * x0, int64_t x1, int64_t x2)
{
  SynchrotronRadiationRecordData_set_at_element(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set_at_element(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set_at_element", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set_at_element(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set_at_element _cffi_d_SynchrotronRadiationRecordData_set_at_element
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set_at_turn(struct SynchrotronRadiationRecordData_s * x0, int64_t x1, int64_t x2)
{
  SynchrotronRadiationRecordData_set_at_turn(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set_at_turn(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set_at_turn", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set_at_turn(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set_at_turn _cffi_d_SynchrotronRadiationRecordData_set_at_turn
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set_particle_delta(struct SynchrotronRadiationRecordData_s * x0, int64_t x1, double x2)
{
  SynchrotronRadiationRecordData_set_particle_delta(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set_particle_delta(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set_particle_delta", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set_particle_delta(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set_particle_delta _cffi_d_SynchrotronRadiationRecordData_set_particle_delta
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set_particle_id(struct SynchrotronRadiationRecordData_s * x0, int64_t x1, int64_t x2)
{
  SynchrotronRadiationRecordData_set_particle_id(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set_particle_id(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  int64_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set_particle_id", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int64_t);
  if (x2 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set_particle_id(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set_particle_id _cffi_d_SynchrotronRadiationRecordData_set_particle_id
#endif

static void _cffi_d_SynchrotronRadiationRecordData_set_photon_energy(struct SynchrotronRadiationRecordData_s * x0, int64_t x1, double x2)
{
  SynchrotronRadiationRecordData_set_photon_energy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_SynchrotronRadiationRecordData_set_photon_energy(PyObject *self, PyObject *args)
{
  struct SynchrotronRadiationRecordData_s * x0;
  int64_t x1;
  double x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "SynchrotronRadiationRecordData_set_photon_energy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(72), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (struct SynchrotronRadiationRecordData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(72), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int64_t);
  if (x1 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { SynchrotronRadiationRecordData_set_photon_energy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_SynchrotronRadiationRecordData_set_photon_energy _cffi_d_SynchrotronRadiationRecordData_set_photon_energy
#endif

static void _cffi_d_track_line(int8_t * x0, struct ElementRefData_s * x1, struct ParticlesData_s * x2, int32_t x3, int32_t x4, int32_t x5, int32_t x6, int32_t x7, int32_t x8, int32_t x9, double x10, int8_t * x11, int64_t x12, int8_t * x13)
{
  track_line(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_track_line(PyObject *self, PyObject *args)
{
  int8_t * x0;
  struct ElementRefData_s * x1;
  struct ParticlesData_s * x2;
  int32_t x3;
  int32_t x4;
  int32_t x5;
  int32_t x6;
  int32_t x7;
  int32_t x8;
  int32_t x9;
  double x10;
  int8_t * x11;
  int64_t x12;
  int8_t * x13;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;
  PyObject *arg12;
  PyObject *arg13;

  if (!PyArg_UnpackTuple(args, "track_line", 14, 14, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(576), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(576), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (struct ElementRefData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(5), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(55), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (struct ParticlesData_s *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(55), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int32_t);
  if (x3 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int32_t);
  if (x4 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int32_t);
  if (x5 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int32_t);
  if (x6 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x7 = _cffi_to_c_int(arg7, int32_t);
  if (x7 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x8 = _cffi_to_c_int(arg8, int32_t);
  if (x8 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x9 = _cffi_to_c_int(arg9, int32_t);
  if (x9 == (int32_t)-1 && PyErr_Occurred())
    return NULL;

  x10 = (double)_cffi_to_c_double(arg10);
  if (x10 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(576), arg11, (char **)&x11);
  if (datasize != 0) {
    x11 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(576), arg11, (char **)&x11,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x12 = _cffi_to_c_int(arg12, int64_t);
  if (x12 == (int64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(576), arg13, (char **)&x13);
  if (datasize != 0) {
    x13 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(576), arg13, (char **)&x13,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { track_line(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_track_line _cffi_d_track_line
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "ArrNElementRefClass_getp", (void *)_cffi_f_ArrNElementRefClass_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 313), (void *)_cffi_d_ArrNElementRefClass_getp },
  { "ArrNElementRefClass_getp1", (void *)_cffi_f_ArrNElementRefClass_getp1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 418), (void *)_cffi_d_ArrNElementRefClass_getp1 },
  { "ArrNElementRefClass_len", (void *)_cffi_f_ArrNElementRefClass_len, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 213), (void *)_cffi_d_ArrNElementRefClass_len },
  { "ArrNElementRefClass_member", (void *)_cffi_f_ArrNElementRefClass_member, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 564), (void *)_cffi_d_ArrNElementRefClass_member },
  { "ArrNElementRefClass_typeid", (void *)_cffi_f_ArrNElementRefClass_typeid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 216), (void *)_cffi_d_ArrNElementRefClass_typeid },
  { "ArrNFloat64_get", (void *)_cffi_f_ArrNFloat64_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 75), (void *)_cffi_d_ArrNFloat64_get },
  { "ArrNFloat64_getp", (void *)_cffi_f_ArrNFloat64_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 319), (void *)_cffi_d_ArrNFloat64_getp },
  { "ArrNFloat64_getp1", (void *)_cffi_f_ArrNFloat64_getp1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 8), (void *)_cffi_d_ArrNFloat64_getp1 },
  { "ArrNFloat64_len", (void *)_cffi_f_ArrNFloat64_len, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 220), (void *)_cffi_d_ArrNFloat64_len },
  { "ArrNFloat64_set", (void *)_cffi_f_ArrNFloat64_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 591), (void *)_cffi_d_ArrNFloat64_set },
  { "ArrNInt64_get", (void *)_cffi_f_ArrNInt64_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 226), (void *)_cffi_d_ArrNInt64_get },
  { "ArrNInt64_getp", (void *)_cffi_f_ArrNInt64_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 349), (void *)_cffi_d_ArrNInt64_getp },
  { "ArrNInt64_getp1", (void *)_cffi_f_ArrNInt64_getp1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 142), (void *)_cffi_d_ArrNInt64_getp1 },
  { "ArrNInt64_len", (void *)_cffi_f_ArrNInt64_len, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 223), (void *)_cffi_d_ArrNInt64_len },
  { "ArrNInt64_set", (void *)_cffi_f_ArrNInt64_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 596), (void *)_cffi_d_ArrNInt64_set },
  { "ArrNString_getp", (void *)_cffi_f_ArrNString_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 373), (void *)_cffi_d_ArrNString_getp },
  { "ArrNString_getp1", (void *)_cffi_f_ArrNString_getp1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_ArrNString_getp1 },
  { "ArrNString_len", (void *)_cffi_f_ArrNString_len, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 230), (void *)_cffi_d_ArrNString_len },
  { "ArrNUint32_get", (void *)_cffi_f_ArrNUint32_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 522), (void *)_cffi_d_ArrNUint32_get },
  { "ArrNUint32_getp", (void *)_cffi_f_ArrNUint32_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 379), (void *)_cffi_d_ArrNUint32_getp },
  { "ArrNUint32_getp1", (void *)_cffi_f_ArrNUint32_getp1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 492), (void *)_cffi_d_ArrNUint32_getp1 },
  { "ArrNUint32_len", (void *)_cffi_f_ArrNUint32_len, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 233), (void *)_cffi_d_ArrNUint32_len },
  { "ArrNUint32_set", (void *)_cffi_f_ArrNUint32_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 601), (void *)_cffi_d_ArrNUint32_set },
  { "BeamBeamBiGaussian2DData_get_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_min_sigma_diff },
  { "BeamBeamBiGaussian2DData_get_other_beam_Sigma_11", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_11 },
  { "BeamBeamBiGaussian2DData_get_other_beam_Sigma_13", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_13 },
  { "BeamBeamBiGaussian2DData_get_other_beam_Sigma_33", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_Sigma_33 },
  { "BeamBeamBiGaussian2DData_get_other_beam_beta0", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_beta0 },
  { "BeamBeamBiGaussian2DData_get_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_num_particles },
  { "BeamBeamBiGaussian2DData_get_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_q0 },
  { "BeamBeamBiGaussian2DData_get_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_x },
  { "BeamBeamBiGaussian2DData_get_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_other_beam_shift_y },
  { "BeamBeamBiGaussian2DData_get_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_px },
  { "BeamBeamBiGaussian2DData_get_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_post_subtract_py },
  { "BeamBeamBiGaussian2DData_get_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_x },
  { "BeamBeamBiGaussian2DData_get_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_ref_shift_y },
  { "BeamBeamBiGaussian2DData_get_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian2DData_get_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 79), (void *)_cffi_d_BeamBeamBiGaussian2DData_get_scale_strength },
  { "BeamBeamBiGaussian2DData_getp", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 388), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp },
  { "BeamBeamBiGaussian2DData_getp_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_min_sigma_diff },
  { "BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_11 },
  { "BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_13 },
  { "BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_Sigma_33 },
  { "BeamBeamBiGaussian2DData_getp_other_beam_beta0", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_beta0 },
  { "BeamBeamBiGaussian2DData_getp_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_num_particles },
  { "BeamBeamBiGaussian2DData_getp_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_q0 },
  { "BeamBeamBiGaussian2DData_getp_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_x },
  { "BeamBeamBiGaussian2DData_getp_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_other_beam_shift_y },
  { "BeamBeamBiGaussian2DData_getp_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_px },
  { "BeamBeamBiGaussian2DData_getp_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_post_subtract_py },
  { "BeamBeamBiGaussian2DData_getp_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_x },
  { "BeamBeamBiGaussian2DData_getp_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_ref_shift_y },
  { "BeamBeamBiGaussian2DData_getp_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian2DData_getp_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_BeamBeamBiGaussian2DData_getp_scale_strength },
  { "BeamBeamBiGaussian2DData_set_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_min_sigma_diff },
  { "BeamBeamBiGaussian2DData_set_other_beam_Sigma_11", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_11 },
  { "BeamBeamBiGaussian2DData_set_other_beam_Sigma_13", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_13 },
  { "BeamBeamBiGaussian2DData_set_other_beam_Sigma_33", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_Sigma_33 },
  { "BeamBeamBiGaussian2DData_set_other_beam_beta0", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_beta0 },
  { "BeamBeamBiGaussian2DData_set_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_num_particles },
  { "BeamBeamBiGaussian2DData_set_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_q0 },
  { "BeamBeamBiGaussian2DData_set_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_x },
  { "BeamBeamBiGaussian2DData_set_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_other_beam_shift_y },
  { "BeamBeamBiGaussian2DData_set_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_px },
  { "BeamBeamBiGaussian2DData_set_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_post_subtract_py },
  { "BeamBeamBiGaussian2DData_set_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_x },
  { "BeamBeamBiGaussian2DData_set_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_ref_shift_y },
  { "BeamBeamBiGaussian2DData_set_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian2DData_set_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 606), (void *)_cffi_d_BeamBeamBiGaussian2DData_set_scale_strength },
  { "BeamBeamBiGaussian3DData_get__cos_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__cos_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__cos_alpha },
  { "BeamBeamBiGaussian3DData_get__cos_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__cos_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__cos_phi },
  { "BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_buffer_id },
  { "BeamBeamBiGaussian3DData_get__internal_record_id_offset", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__internal_record_id_offset },
  { "BeamBeamBiGaussian3DData_get__sin_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__sin_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__sin_alpha },
  { "BeamBeamBiGaussian3DData_get__sin_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__sin_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__sin_phi },
  { "BeamBeamBiGaussian3DData_get__tan_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_get__tan_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get__tan_phi },
  { "BeamBeamBiGaussian3DData_get_compt_x_min", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_compt_x_min, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_compt_x_min },
  { "BeamBeamBiGaussian3DData_get_flag_beamsize_effect", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_flag_beamsize_effect, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_flag_beamsize_effect },
  { "BeamBeamBiGaussian3DData_get_flag_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_flag_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_flag_beamstrahlung },
  { "BeamBeamBiGaussian3DData_get_flag_bhabha", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_flag_bhabha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_flag_bhabha },
  { "BeamBeamBiGaussian3DData_get_flag_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_flag_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_flag_luminosity },
  { "BeamBeamBiGaussian3DData_get_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_min_sigma_diff },
  { "BeamBeamBiGaussian3DData_get_num_slices_other_beam", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_num_slices_other_beam, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_num_slices_other_beam },
  { "BeamBeamBiGaussian3DData_get_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_q0 },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_px },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_py },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_pzeta },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_x },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_y },
  { "BeamBeamBiGaussian3DData_get_other_beam_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_other_beam_shift_zeta },
  { "BeamBeamBiGaussian3DData_get_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_px },
  { "BeamBeamBiGaussian3DData_get_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_py },
  { "BeamBeamBiGaussian3DData_get_post_subtract_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_pzeta },
  { "BeamBeamBiGaussian3DData_get_post_subtract_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_x },
  { "BeamBeamBiGaussian3DData_get_post_subtract_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_y },
  { "BeamBeamBiGaussian3DData_get_post_subtract_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_post_subtract_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_post_subtract_zeta },
  { "BeamBeamBiGaussian3DData_get_ref_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_px },
  { "BeamBeamBiGaussian3DData_get_ref_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_py },
  { "BeamBeamBiGaussian3DData_get_ref_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_pzeta },
  { "BeamBeamBiGaussian3DData_get_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_x },
  { "BeamBeamBiGaussian3DData_get_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_y },
  { "BeamBeamBiGaussian3DData_get_ref_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_ref_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_ref_shift_zeta },
  { "BeamBeamBiGaussian3DData_get_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_scale_strength },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_11_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_12_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_13_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_14_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_22_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_23_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_24_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_33_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_34_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_Sigma_44_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_num_particles },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_px_center_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_py_center_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_pzeta_center_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_11_beamstrahlung },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_33_beamstrahlung },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_sqrtSigma_55_beamstrahlung },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_x_center_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_y_center_star },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_bin_width_star_beamstrahlung },
  { "BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_slices_other_beam_zeta_center_star },
  { "BeamBeamBiGaussian3DData_get_threshold_singular", (void *)_cffi_f_BeamBeamBiGaussian3DData_get_threshold_singular, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 82), (void *)_cffi_d_BeamBeamBiGaussian3DData_get_threshold_singular },
  { "BeamBeamBiGaussian3DData_getp", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 391), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_11_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_12_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_13_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_14_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_22_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_23_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_24_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_33_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_34_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_Sigma_44_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_num_particles },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_px_center_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_py_center_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_pzeta_center_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_11_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_33_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_sqrtSigma_55_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_x_center_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_y_center_star },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_bin_width_star_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp1_slices_other_beam_zeta_center_star },
  { "BeamBeamBiGaussian3DData_getp__cos_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__cos_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__cos_alpha },
  { "BeamBeamBiGaussian3DData_getp__cos_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__cos_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__cos_phi },
  { "BeamBeamBiGaussian3DData_getp__internal_record_id", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 459), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id },
  { "BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_buffer_id },
  { "BeamBeamBiGaussian3DData_getp__internal_record_id_offset", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__internal_record_id_offset },
  { "BeamBeamBiGaussian3DData_getp__sin_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__sin_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__sin_alpha },
  { "BeamBeamBiGaussian3DData_getp__sin_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__sin_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__sin_phi },
  { "BeamBeamBiGaussian3DData_getp__tan_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp__tan_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp__tan_phi },
  { "BeamBeamBiGaussian3DData_getp_compt_x_min", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_compt_x_min, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_compt_x_min },
  { "BeamBeamBiGaussian3DData_getp_flag_beamsize_effect", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamsize_effect },
  { "BeamBeamBiGaussian3DData_getp_flag_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_flag_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp_flag_bhabha", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_flag_bhabha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_flag_bhabha },
  { "BeamBeamBiGaussian3DData_getp_flag_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_flag_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_flag_luminosity },
  { "BeamBeamBiGaussian3DData_getp_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_min_sigma_diff },
  { "BeamBeamBiGaussian3DData_getp_num_slices_other_beam", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_num_slices_other_beam, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 146), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_num_slices_other_beam },
  { "BeamBeamBiGaussian3DData_getp_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_q0 },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_px },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_py },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_pzeta },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_x },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_y },
  { "BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_other_beam_shift_zeta },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_px },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_py },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_pzeta },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_x },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_y },
  { "BeamBeamBiGaussian3DData_getp_post_subtract_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_post_subtract_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_post_subtract_zeta },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_px },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_py },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_pzeta },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_x },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_y },
  { "BeamBeamBiGaussian3DData_getp_ref_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_ref_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_ref_shift_zeta },
  { "BeamBeamBiGaussian3DData_getp_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_scale_strength },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_11_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_12_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_13_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_14_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_22_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_23_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_24_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_33_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_34_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_Sigma_44_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_num_particles },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_px_center_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_py_center_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_pzeta_center_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_11_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_33_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_sqrtSigma_55_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_x_center_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_y_center_star },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_bin_width_star_beamstrahlung },
  { "BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 322), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_slices_other_beam_zeta_center_star },
  { "BeamBeamBiGaussian3DData_getp_threshold_singular", (void *)_cffi_f_BeamBeamBiGaussian3DData_getp_threshold_singular, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_BeamBeamBiGaussian3DData_getp_threshold_singular },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_11_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_12_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_13_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_14_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_22_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_23_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_24_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_33_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_34_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_Sigma_44_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_num_particles },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_px_center_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_py_center_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_pzeta_center_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_11_beamstrahlung },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_33_beamstrahlung },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_sqrtSigma_55_beamstrahlung },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_x_center_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_y_center_star },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_bin_width_star_beamstrahlung },
  { "BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 236), (void *)_cffi_d_BeamBeamBiGaussian3DData_len_slices_other_beam_zeta_center_star },
  { "BeamBeamBiGaussian3DData_set__cos_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__cos_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__cos_alpha },
  { "BeamBeamBiGaussian3DData_set__cos_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__cos_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__cos_phi },
  { "BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_buffer_id },
  { "BeamBeamBiGaussian3DData_set__internal_record_id_offset", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__internal_record_id_offset },
  { "BeamBeamBiGaussian3DData_set__sin_alpha", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__sin_alpha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__sin_alpha },
  { "BeamBeamBiGaussian3DData_set__sin_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__sin_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__sin_phi },
  { "BeamBeamBiGaussian3DData_set__tan_phi", (void *)_cffi_f_BeamBeamBiGaussian3DData_set__tan_phi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set__tan_phi },
  { "BeamBeamBiGaussian3DData_set_compt_x_min", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_compt_x_min, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_compt_x_min },
  { "BeamBeamBiGaussian3DData_set_flag_beamsize_effect", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_flag_beamsize_effect, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_flag_beamsize_effect },
  { "BeamBeamBiGaussian3DData_set_flag_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_flag_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_flag_beamstrahlung },
  { "BeamBeamBiGaussian3DData_set_flag_bhabha", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_flag_bhabha, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_flag_bhabha },
  { "BeamBeamBiGaussian3DData_set_flag_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_flag_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_flag_luminosity },
  { "BeamBeamBiGaussian3DData_set_min_sigma_diff", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_min_sigma_diff, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_min_sigma_diff },
  { "BeamBeamBiGaussian3DData_set_num_slices_other_beam", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_num_slices_other_beam, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 614), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_num_slices_other_beam },
  { "BeamBeamBiGaussian3DData_set_other_beam_q0", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_q0 },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_px },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_py },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_pzeta },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_x },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_y },
  { "BeamBeamBiGaussian3DData_set_other_beam_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_other_beam_shift_zeta },
  { "BeamBeamBiGaussian3DData_set_post_subtract_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_px },
  { "BeamBeamBiGaussian3DData_set_post_subtract_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_py },
  { "BeamBeamBiGaussian3DData_set_post_subtract_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_pzeta },
  { "BeamBeamBiGaussian3DData_set_post_subtract_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_x },
  { "BeamBeamBiGaussian3DData_set_post_subtract_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_y },
  { "BeamBeamBiGaussian3DData_set_post_subtract_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_post_subtract_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_post_subtract_zeta },
  { "BeamBeamBiGaussian3DData_set_ref_shift_px", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_px },
  { "BeamBeamBiGaussian3DData_set_ref_shift_py", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_py },
  { "BeamBeamBiGaussian3DData_set_ref_shift_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_pzeta },
  { "BeamBeamBiGaussian3DData_set_ref_shift_x", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_x },
  { "BeamBeamBiGaussian3DData_set_ref_shift_y", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_y },
  { "BeamBeamBiGaussian3DData_set_ref_shift_zeta", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_ref_shift_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_ref_shift_zeta },
  { "BeamBeamBiGaussian3DData_set_scale_strength", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_scale_strength, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_scale_strength },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_11_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_12_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_13_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_14_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_22_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_23_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_24_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_33_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_34_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_Sigma_44_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_num_particles },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_px_center_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_py_center_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_pzeta_center_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_11_beamstrahlung },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_33_beamstrahlung },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_sqrtSigma_55_beamstrahlung },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_x_center_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_y_center_star },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_bin_width_star_beamstrahlung },
  { "BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 618), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_slices_other_beam_zeta_center_star },
  { "BeamBeamBiGaussian3DData_set_threshold_singular", (void *)_cffi_f_BeamBeamBiGaussian3DData_set_threshold_singular, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 610), (void *)_cffi_d_BeamBeamBiGaussian3DData_set_threshold_singular },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_element },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_delta_avg },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_n_avg },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_critical_energy },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_beamstrahlungtable_rho_inv },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_element },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_px },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_py },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_photon_pzeta },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_e },
  { "BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_bhabhatable_theta_g },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 526), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_element },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_luminosity },
  { "BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_get_lumitable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 394), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_delta_avg },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_n_avg },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_critical_energy },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_beamstrahlungtable_rho_inv },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_px },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_py },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_photon_pzeta },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_e },
  { "BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_bhabhatable_theta_g },
  { "BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_luminosity },
  { "BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp1_lumitable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 397), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 468), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_delta_avg },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_n_avg },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_critical_energy },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_beamstrahlungtable_rho_inv },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 403), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 468), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_px },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_py },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_photon_pzeta },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_e },
  { "BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_bhabhatable_theta_g },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 432), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable__index", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 468), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 496), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_element },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 325), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_luminosity },
  { "BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 352), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_getp_lumitable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_element },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_delta_avg },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_n_avg },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_critical_energy },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_beamstrahlungtable_rho_inv },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_element },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_px },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_py },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_photon_pzeta },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_e },
  { "BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_bhabhatable_theta_g },
  { "BeamBeamBiGaussian3DRecordData_len_lumitable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_element },
  { "BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_luminosity },
  { "BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_len_lumitable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_element },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_delta_avg },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_n_avg },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_critical_energy },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_beamstrahlungtable_rho_inv },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_element },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_particle_id },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_energy },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_id },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_px },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_py },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_photon_pzeta },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_primary_energy },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_e },
  { "BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_bhabhatable_theta_g },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index__dummy },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_buffer_id },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 623), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_capacity },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 637), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable__index_num_recorded },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable_at_element", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_element },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_at_turn },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 627), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_luminosity },
  { "BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id", (void *)_cffi_f_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 632), (void *)_cffi_d_BeamBeamBiGaussian3DRecordData_set_lumitable_particle_id },
  { "BeamstrahlungTableData_get__index__dummy", (void *)_cffi_f_BeamstrahlungTableData_get__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 529), (void *)_cffi_d_BeamstrahlungTableData_get__index__dummy },
  { "BeamstrahlungTableData_get__index_buffer_id", (void *)_cffi_f_BeamstrahlungTableData_get__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_get__index_buffer_id },
  { "BeamstrahlungTableData_get__index_capacity", (void *)_cffi_f_BeamstrahlungTableData_get__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_get__index_capacity },
  { "BeamstrahlungTableData_get__index_num_recorded", (void *)_cffi_f_BeamstrahlungTableData_get__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 529), (void *)_cffi_d_BeamstrahlungTableData_get__index_num_recorded },
  { "BeamstrahlungTableData_get_at_element", (void *)_cffi_f_BeamstrahlungTableData_get_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 249), (void *)_cffi_d_BeamstrahlungTableData_get_at_element },
  { "BeamstrahlungTableData_get_at_turn", (void *)_cffi_f_BeamstrahlungTableData_get_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 249), (void *)_cffi_d_BeamstrahlungTableData_get_at_turn },
  { "BeamstrahlungTableData_get_delta_avg", (void *)_cffi_f_BeamstrahlungTableData_get_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_delta_avg },
  { "BeamstrahlungTableData_get_n_avg", (void *)_cffi_f_BeamstrahlungTableData_get_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_n_avg },
  { "BeamstrahlungTableData_get_particle_id", (void *)_cffi_f_BeamstrahlungTableData_get_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 249), (void *)_cffi_d_BeamstrahlungTableData_get_particle_id },
  { "BeamstrahlungTableData_get_photon_critical_energy", (void *)_cffi_f_BeamstrahlungTableData_get_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_photon_critical_energy },
  { "BeamstrahlungTableData_get_photon_energy", (void *)_cffi_f_BeamstrahlungTableData_get_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_photon_energy },
  { "BeamstrahlungTableData_get_photon_id", (void *)_cffi_f_BeamstrahlungTableData_get_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_photon_id },
  { "BeamstrahlungTableData_get_primary_energy", (void *)_cffi_f_BeamstrahlungTableData_get_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_primary_energy },
  { "BeamstrahlungTableData_get_rho_inv", (void *)_cffi_f_BeamstrahlungTableData_get_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 93), (void *)_cffi_d_BeamstrahlungTableData_get_rho_inv },
  { "BeamstrahlungTableData_getp", (void *)_cffi_f_BeamstrahlungTableData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 400), (void *)_cffi_d_BeamstrahlungTableData_getp },
  { "BeamstrahlungTableData_getp1_at_element", (void *)_cffi_f_BeamstrahlungTableData_getp1_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 159), (void *)_cffi_d_BeamstrahlungTableData_getp1_at_element },
  { "BeamstrahlungTableData_getp1_at_turn", (void *)_cffi_f_BeamstrahlungTableData_getp1_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 159), (void *)_cffi_d_BeamstrahlungTableData_getp1_at_turn },
  { "BeamstrahlungTableData_getp1_delta_avg", (void *)_cffi_f_BeamstrahlungTableData_getp1_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_delta_avg },
  { "BeamstrahlungTableData_getp1_n_avg", (void *)_cffi_f_BeamstrahlungTableData_getp1_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_n_avg },
  { "BeamstrahlungTableData_getp1_particle_id", (void *)_cffi_f_BeamstrahlungTableData_getp1_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 159), (void *)_cffi_d_BeamstrahlungTableData_getp1_particle_id },
  { "BeamstrahlungTableData_getp1_photon_critical_energy", (void *)_cffi_f_BeamstrahlungTableData_getp1_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_photon_critical_energy },
  { "BeamstrahlungTableData_getp1_photon_energy", (void *)_cffi_f_BeamstrahlungTableData_getp1_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_photon_energy },
  { "BeamstrahlungTableData_getp1_photon_id", (void *)_cffi_f_BeamstrahlungTableData_getp1_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_photon_id },
  { "BeamstrahlungTableData_getp1_primary_energy", (void *)_cffi_f_BeamstrahlungTableData_getp1_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_primary_energy },
  { "BeamstrahlungTableData_getp1_rho_inv", (void *)_cffi_f_BeamstrahlungTableData_getp1_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 26), (void *)_cffi_d_BeamstrahlungTableData_getp1_rho_inv },
  { "BeamstrahlungTableData_getp__index", (void *)_cffi_f_BeamstrahlungTableData_getp__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 471), (void *)_cffi_d_BeamstrahlungTableData_getp__index },
  { "BeamstrahlungTableData_getp__index__dummy", (void *)_cffi_f_BeamstrahlungTableData_getp__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 499), (void *)_cffi_d_BeamstrahlungTableData_getp__index__dummy },
  { "BeamstrahlungTableData_getp__index_buffer_id", (void *)_cffi_f_BeamstrahlungTableData_getp__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 156), (void *)_cffi_d_BeamstrahlungTableData_getp__index_buffer_id },
  { "BeamstrahlungTableData_getp__index_capacity", (void *)_cffi_f_BeamstrahlungTableData_getp__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 156), (void *)_cffi_d_BeamstrahlungTableData_getp__index_capacity },
  { "BeamstrahlungTableData_getp__index_num_recorded", (void *)_cffi_f_BeamstrahlungTableData_getp__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 499), (void *)_cffi_d_BeamstrahlungTableData_getp__index_num_recorded },
  { "BeamstrahlungTableData_getp_at_element", (void *)_cffi_f_BeamstrahlungTableData_getp_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 355), (void *)_cffi_d_BeamstrahlungTableData_getp_at_element },
  { "BeamstrahlungTableData_getp_at_turn", (void *)_cffi_f_BeamstrahlungTableData_getp_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 355), (void *)_cffi_d_BeamstrahlungTableData_getp_at_turn },
  { "BeamstrahlungTableData_getp_delta_avg", (void *)_cffi_f_BeamstrahlungTableData_getp_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_delta_avg },
  { "BeamstrahlungTableData_getp_n_avg", (void *)_cffi_f_BeamstrahlungTableData_getp_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_n_avg },
  { "BeamstrahlungTableData_getp_particle_id", (void *)_cffi_f_BeamstrahlungTableData_getp_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 355), (void *)_cffi_d_BeamstrahlungTableData_getp_particle_id },
  { "BeamstrahlungTableData_getp_photon_critical_energy", (void *)_cffi_f_BeamstrahlungTableData_getp_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_photon_critical_energy },
  { "BeamstrahlungTableData_getp_photon_energy", (void *)_cffi_f_BeamstrahlungTableData_getp_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_photon_energy },
  { "BeamstrahlungTableData_getp_photon_id", (void *)_cffi_f_BeamstrahlungTableData_getp_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_photon_id },
  { "BeamstrahlungTableData_getp_primary_energy", (void *)_cffi_f_BeamstrahlungTableData_getp_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_primary_energy },
  { "BeamstrahlungTableData_getp_rho_inv", (void *)_cffi_f_BeamstrahlungTableData_getp_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 328), (void *)_cffi_d_BeamstrahlungTableData_getp_rho_inv },
  { "BeamstrahlungTableData_len_at_element", (void *)_cffi_f_BeamstrahlungTableData_len_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_at_element },
  { "BeamstrahlungTableData_len_at_turn", (void *)_cffi_f_BeamstrahlungTableData_len_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_at_turn },
  { "BeamstrahlungTableData_len_delta_avg", (void *)_cffi_f_BeamstrahlungTableData_len_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_delta_avg },
  { "BeamstrahlungTableData_len_n_avg", (void *)_cffi_f_BeamstrahlungTableData_len_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_n_avg },
  { "BeamstrahlungTableData_len_particle_id", (void *)_cffi_f_BeamstrahlungTableData_len_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_particle_id },
  { "BeamstrahlungTableData_len_photon_critical_energy", (void *)_cffi_f_BeamstrahlungTableData_len_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_photon_critical_energy },
  { "BeamstrahlungTableData_len_photon_energy", (void *)_cffi_f_BeamstrahlungTableData_len_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_photon_energy },
  { "BeamstrahlungTableData_len_photon_id", (void *)_cffi_f_BeamstrahlungTableData_len_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_photon_id },
  { "BeamstrahlungTableData_len_primary_energy", (void *)_cffi_f_BeamstrahlungTableData_len_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_primary_energy },
  { "BeamstrahlungTableData_len_rho_inv", (void *)_cffi_f_BeamstrahlungTableData_len_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 246), (void *)_cffi_d_BeamstrahlungTableData_len_rho_inv },
  { "BeamstrahlungTableData_set__index__dummy", (void *)_cffi_f_BeamstrahlungTableData_set__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 655), (void *)_cffi_d_BeamstrahlungTableData_set__index__dummy },
  { "BeamstrahlungTableData_set__index_buffer_id", (void *)_cffi_f_BeamstrahlungTableData_set__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 641), (void *)_cffi_d_BeamstrahlungTableData_set__index_buffer_id },
  { "BeamstrahlungTableData_set__index_capacity", (void *)_cffi_f_BeamstrahlungTableData_set__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 641), (void *)_cffi_d_BeamstrahlungTableData_set__index_capacity },
  { "BeamstrahlungTableData_set__index_num_recorded", (void *)_cffi_f_BeamstrahlungTableData_set__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 655), (void *)_cffi_d_BeamstrahlungTableData_set__index_num_recorded },
  { "BeamstrahlungTableData_set_at_element", (void *)_cffi_f_BeamstrahlungTableData_set_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 650), (void *)_cffi_d_BeamstrahlungTableData_set_at_element },
  { "BeamstrahlungTableData_set_at_turn", (void *)_cffi_f_BeamstrahlungTableData_set_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 650), (void *)_cffi_d_BeamstrahlungTableData_set_at_turn },
  { "BeamstrahlungTableData_set_delta_avg", (void *)_cffi_f_BeamstrahlungTableData_set_delta_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_delta_avg },
  { "BeamstrahlungTableData_set_n_avg", (void *)_cffi_f_BeamstrahlungTableData_set_n_avg, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_n_avg },
  { "BeamstrahlungTableData_set_particle_id", (void *)_cffi_f_BeamstrahlungTableData_set_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 650), (void *)_cffi_d_BeamstrahlungTableData_set_particle_id },
  { "BeamstrahlungTableData_set_photon_critical_energy", (void *)_cffi_f_BeamstrahlungTableData_set_photon_critical_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_photon_critical_energy },
  { "BeamstrahlungTableData_set_photon_energy", (void *)_cffi_f_BeamstrahlungTableData_set_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_photon_energy },
  { "BeamstrahlungTableData_set_photon_id", (void *)_cffi_f_BeamstrahlungTableData_set_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_photon_id },
  { "BeamstrahlungTableData_set_primary_energy", (void *)_cffi_f_BeamstrahlungTableData_set_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_primary_energy },
  { "BeamstrahlungTableData_set_rho_inv", (void *)_cffi_f_BeamstrahlungTableData_set_rho_inv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 645), (void *)_cffi_d_BeamstrahlungTableData_set_rho_inv },
  { "BhabhaTableData_get__index__dummy", (void *)_cffi_f_BhabhaTableData_get__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 532), (void *)_cffi_d_BhabhaTableData_get__index__dummy },
  { "BhabhaTableData_get__index_buffer_id", (void *)_cffi_f_BhabhaTableData_get__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_get__index_buffer_id },
  { "BhabhaTableData_get__index_capacity", (void *)_cffi_f_BhabhaTableData_get__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_get__index_capacity },
  { "BhabhaTableData_get__index_num_recorded", (void *)_cffi_f_BhabhaTableData_get__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 532), (void *)_cffi_d_BhabhaTableData_get__index_num_recorded },
  { "BhabhaTableData_get_at_element", (void *)_cffi_f_BhabhaTableData_get_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 256), (void *)_cffi_d_BhabhaTableData_get_at_element },
  { "BhabhaTableData_get_at_turn", (void *)_cffi_f_BhabhaTableData_get_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 256), (void *)_cffi_d_BhabhaTableData_get_at_turn },
  { "BhabhaTableData_get_particle_id", (void *)_cffi_f_BhabhaTableData_get_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 256), (void *)_cffi_d_BhabhaTableData_get_particle_id },
  { "BhabhaTableData_get_photon_energy", (void *)_cffi_f_BhabhaTableData_get_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_photon_energy },
  { "BhabhaTableData_get_photon_id", (void *)_cffi_f_BhabhaTableData_get_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 256), (void *)_cffi_d_BhabhaTableData_get_photon_id },
  { "BhabhaTableData_get_photon_px", (void *)_cffi_f_BhabhaTableData_get_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_photon_px },
  { "BhabhaTableData_get_photon_py", (void *)_cffi_f_BhabhaTableData_get_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_photon_py },
  { "BhabhaTableData_get_photon_pzeta", (void *)_cffi_f_BhabhaTableData_get_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_photon_pzeta },
  { "BhabhaTableData_get_primary_energy", (void *)_cffi_f_BhabhaTableData_get_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_primary_energy },
  { "BhabhaTableData_get_theta_e", (void *)_cffi_f_BhabhaTableData_get_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_theta_e },
  { "BhabhaTableData_get_theta_g", (void *)_cffi_f_BhabhaTableData_get_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_BhabhaTableData_get_theta_g },
  { "BhabhaTableData_getp", (void *)_cffi_f_BhabhaTableData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 406), (void *)_cffi_d_BhabhaTableData_getp },
  { "BhabhaTableData_getp1_at_element", (void *)_cffi_f_BhabhaTableData_getp1_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 166), (void *)_cffi_d_BhabhaTableData_getp1_at_element },
  { "BhabhaTableData_getp1_at_turn", (void *)_cffi_f_BhabhaTableData_getp1_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 166), (void *)_cffi_d_BhabhaTableData_getp1_at_turn },
  { "BhabhaTableData_getp1_particle_id", (void *)_cffi_f_BhabhaTableData_getp1_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 166), (void *)_cffi_d_BhabhaTableData_getp1_particle_id },
  { "BhabhaTableData_getp1_photon_energy", (void *)_cffi_f_BhabhaTableData_getp1_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_photon_energy },
  { "BhabhaTableData_getp1_photon_id", (void *)_cffi_f_BhabhaTableData_getp1_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 166), (void *)_cffi_d_BhabhaTableData_getp1_photon_id },
  { "BhabhaTableData_getp1_photon_px", (void *)_cffi_f_BhabhaTableData_getp1_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_photon_px },
  { "BhabhaTableData_getp1_photon_py", (void *)_cffi_f_BhabhaTableData_getp1_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_photon_py },
  { "BhabhaTableData_getp1_photon_pzeta", (void *)_cffi_f_BhabhaTableData_getp1_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_photon_pzeta },
  { "BhabhaTableData_getp1_primary_energy", (void *)_cffi_f_BhabhaTableData_getp1_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_primary_energy },
  { "BhabhaTableData_getp1_theta_e", (void *)_cffi_f_BhabhaTableData_getp1_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_theta_e },
  { "BhabhaTableData_getp1_theta_g", (void *)_cffi_f_BhabhaTableData_getp1_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_BhabhaTableData_getp1_theta_g },
  { "BhabhaTableData_getp__index", (void *)_cffi_f_BhabhaTableData_getp__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 474), (void *)_cffi_d_BhabhaTableData_getp__index },
  { "BhabhaTableData_getp__index__dummy", (void *)_cffi_f_BhabhaTableData_getp__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 502), (void *)_cffi_d_BhabhaTableData_getp__index__dummy },
  { "BhabhaTableData_getp__index_buffer_id", (void *)_cffi_f_BhabhaTableData_getp__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 163), (void *)_cffi_d_BhabhaTableData_getp__index_buffer_id },
  { "BhabhaTableData_getp__index_capacity", (void *)_cffi_f_BhabhaTableData_getp__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 163), (void *)_cffi_d_BhabhaTableData_getp__index_capacity },
  { "BhabhaTableData_getp__index_num_recorded", (void *)_cffi_f_BhabhaTableData_getp__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 502), (void *)_cffi_d_BhabhaTableData_getp__index_num_recorded },
  { "BhabhaTableData_getp_at_element", (void *)_cffi_f_BhabhaTableData_getp_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 358), (void *)_cffi_d_BhabhaTableData_getp_at_element },
  { "BhabhaTableData_getp_at_turn", (void *)_cffi_f_BhabhaTableData_getp_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 358), (void *)_cffi_d_BhabhaTableData_getp_at_turn },
  { "BhabhaTableData_getp_particle_id", (void *)_cffi_f_BhabhaTableData_getp_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 358), (void *)_cffi_d_BhabhaTableData_getp_particle_id },
  { "BhabhaTableData_getp_photon_energy", (void *)_cffi_f_BhabhaTableData_getp_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_photon_energy },
  { "BhabhaTableData_getp_photon_id", (void *)_cffi_f_BhabhaTableData_getp_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 358), (void *)_cffi_d_BhabhaTableData_getp_photon_id },
  { "BhabhaTableData_getp_photon_px", (void *)_cffi_f_BhabhaTableData_getp_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_photon_px },
  { "BhabhaTableData_getp_photon_py", (void *)_cffi_f_BhabhaTableData_getp_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_photon_py },
  { "BhabhaTableData_getp_photon_pzeta", (void *)_cffi_f_BhabhaTableData_getp_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_photon_pzeta },
  { "BhabhaTableData_getp_primary_energy", (void *)_cffi_f_BhabhaTableData_getp_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_primary_energy },
  { "BhabhaTableData_getp_theta_e", (void *)_cffi_f_BhabhaTableData_getp_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_theta_e },
  { "BhabhaTableData_getp_theta_g", (void *)_cffi_f_BhabhaTableData_getp_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 331), (void *)_cffi_d_BhabhaTableData_getp_theta_g },
  { "BhabhaTableData_len_at_element", (void *)_cffi_f_BhabhaTableData_len_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_at_element },
  { "BhabhaTableData_len_at_turn", (void *)_cffi_f_BhabhaTableData_len_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_at_turn },
  { "BhabhaTableData_len_particle_id", (void *)_cffi_f_BhabhaTableData_len_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_particle_id },
  { "BhabhaTableData_len_photon_energy", (void *)_cffi_f_BhabhaTableData_len_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_photon_energy },
  { "BhabhaTableData_len_photon_id", (void *)_cffi_f_BhabhaTableData_len_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_photon_id },
  { "BhabhaTableData_len_photon_px", (void *)_cffi_f_BhabhaTableData_len_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_photon_px },
  { "BhabhaTableData_len_photon_py", (void *)_cffi_f_BhabhaTableData_len_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_photon_py },
  { "BhabhaTableData_len_photon_pzeta", (void *)_cffi_f_BhabhaTableData_len_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_photon_pzeta },
  { "BhabhaTableData_len_primary_energy", (void *)_cffi_f_BhabhaTableData_len_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_primary_energy },
  { "BhabhaTableData_len_theta_e", (void *)_cffi_f_BhabhaTableData_len_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_theta_e },
  { "BhabhaTableData_len_theta_g", (void *)_cffi_f_BhabhaTableData_len_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 253), (void *)_cffi_d_BhabhaTableData_len_theta_g },
  { "BhabhaTableData_set__index__dummy", (void *)_cffi_f_BhabhaTableData_set__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 673), (void *)_cffi_d_BhabhaTableData_set__index__dummy },
  { "BhabhaTableData_set__index_buffer_id", (void *)_cffi_f_BhabhaTableData_set__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 659), (void *)_cffi_d_BhabhaTableData_set__index_buffer_id },
  { "BhabhaTableData_set__index_capacity", (void *)_cffi_f_BhabhaTableData_set__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 659), (void *)_cffi_d_BhabhaTableData_set__index_capacity },
  { "BhabhaTableData_set__index_num_recorded", (void *)_cffi_f_BhabhaTableData_set__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 673), (void *)_cffi_d_BhabhaTableData_set__index_num_recorded },
  { "BhabhaTableData_set_at_element", (void *)_cffi_f_BhabhaTableData_set_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 668), (void *)_cffi_d_BhabhaTableData_set_at_element },
  { "BhabhaTableData_set_at_turn", (void *)_cffi_f_BhabhaTableData_set_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 668), (void *)_cffi_d_BhabhaTableData_set_at_turn },
  { "BhabhaTableData_set_particle_id", (void *)_cffi_f_BhabhaTableData_set_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 668), (void *)_cffi_d_BhabhaTableData_set_particle_id },
  { "BhabhaTableData_set_photon_energy", (void *)_cffi_f_BhabhaTableData_set_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_photon_energy },
  { "BhabhaTableData_set_photon_id", (void *)_cffi_f_BhabhaTableData_set_photon_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 668), (void *)_cffi_d_BhabhaTableData_set_photon_id },
  { "BhabhaTableData_set_photon_px", (void *)_cffi_f_BhabhaTableData_set_photon_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_photon_px },
  { "BhabhaTableData_set_photon_py", (void *)_cffi_f_BhabhaTableData_set_photon_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_photon_py },
  { "BhabhaTableData_set_photon_pzeta", (void *)_cffi_f_BhabhaTableData_set_photon_pzeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_photon_pzeta },
  { "BhabhaTableData_set_primary_energy", (void *)_cffi_f_BhabhaTableData_set_primary_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_primary_energy },
  { "BhabhaTableData_set_theta_e", (void *)_cffi_f_BhabhaTableData_set_theta_e, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_theta_e },
  { "BhabhaTableData_set_theta_g", (void *)_cffi_f_BhabhaTableData_set_theta_g, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 663), (void *)_cffi_d_BhabhaTableData_set_theta_g },
  { "CavityData_get_frequency", (void *)_cffi_f_CavityData_get_frequency, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 101), (void *)_cffi_d_CavityData_get_frequency },
  { "CavityData_get_lag", (void *)_cffi_f_CavityData_get_lag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 101), (void *)_cffi_d_CavityData_get_lag },
  { "CavityData_get_lag_taper", (void *)_cffi_f_CavityData_get_lag_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 101), (void *)_cffi_d_CavityData_get_lag_taper },
  { "CavityData_get_voltage", (void *)_cffi_f_CavityData_get_voltage, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 101), (void *)_cffi_d_CavityData_get_voltage },
  { "CavityData_getp", (void *)_cffi_f_CavityData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 409), (void *)_cffi_d_CavityData_getp },
  { "CavityData_getp_frequency", (void *)_cffi_f_CavityData_getp_frequency, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 34), (void *)_cffi_d_CavityData_getp_frequency },
  { "CavityData_getp_lag", (void *)_cffi_f_CavityData_getp_lag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 34), (void *)_cffi_d_CavityData_getp_lag },
  { "CavityData_getp_lag_taper", (void *)_cffi_f_CavityData_getp_lag_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 34), (void *)_cffi_d_CavityData_getp_lag_taper },
  { "CavityData_getp_voltage", (void *)_cffi_f_CavityData_getp_voltage, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 34), (void *)_cffi_d_CavityData_getp_voltage },
  { "CavityData_set_frequency", (void *)_cffi_f_CavityData_set_frequency, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 677), (void *)_cffi_d_CavityData_set_frequency },
  { "CavityData_set_lag", (void *)_cffi_f_CavityData_set_lag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 677), (void *)_cffi_d_CavityData_set_lag },
  { "CavityData_set_lag_taper", (void *)_cffi_f_CavityData_set_lag_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 677), (void *)_cffi_d_CavityData_set_lag_taper },
  { "CavityData_set_voltage", (void *)_cffi_f_CavityData_set_voltage, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 677), (void *)_cffi_d_CavityData_set_voltage },
  { "DipoleEdgeData_get_delta_taper", (void *)_cffi_f_DipoleEdgeData_get_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_delta_taper },
  { "DipoleEdgeData_get_e1", (void *)_cffi_f_DipoleEdgeData_get_e1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_e1 },
  { "DipoleEdgeData_get_e1_fd", (void *)_cffi_f_DipoleEdgeData_get_e1_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_e1_fd },
  { "DipoleEdgeData_get_fint", (void *)_cffi_f_DipoleEdgeData_get_fint, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_fint },
  { "DipoleEdgeData_get_hgap", (void *)_cffi_f_DipoleEdgeData_get_hgap, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_hgap },
  { "DipoleEdgeData_get_k", (void *)_cffi_f_DipoleEdgeData_get_k, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_k },
  { "DipoleEdgeData_get_model", (void *)_cffi_f_DipoleEdgeData_get_model, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 260), (void *)_cffi_d_DipoleEdgeData_get_model },
  { "DipoleEdgeData_get_r21", (void *)_cffi_f_DipoleEdgeData_get_r21, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_r21 },
  { "DipoleEdgeData_get_r43", (void *)_cffi_f_DipoleEdgeData_get_r43, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 104), (void *)_cffi_d_DipoleEdgeData_get_r43 },
  { "DipoleEdgeData_get_side", (void *)_cffi_f_DipoleEdgeData_get_side, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 260), (void *)_cffi_d_DipoleEdgeData_get_side },
  { "DipoleEdgeData_getp", (void *)_cffi_f_DipoleEdgeData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 412), (void *)_cffi_d_DipoleEdgeData_getp },
  { "DipoleEdgeData_getp_delta_taper", (void *)_cffi_f_DipoleEdgeData_getp_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_delta_taper },
  { "DipoleEdgeData_getp_e1", (void *)_cffi_f_DipoleEdgeData_getp_e1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_e1 },
  { "DipoleEdgeData_getp_e1_fd", (void *)_cffi_f_DipoleEdgeData_getp_e1_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_e1_fd },
  { "DipoleEdgeData_getp_fint", (void *)_cffi_f_DipoleEdgeData_getp_fint, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_fint },
  { "DipoleEdgeData_getp_hgap", (void *)_cffi_f_DipoleEdgeData_getp_hgap, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_hgap },
  { "DipoleEdgeData_getp_k", (void *)_cffi_f_DipoleEdgeData_getp_k, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_k },
  { "DipoleEdgeData_getp_model", (void *)_cffi_f_DipoleEdgeData_getp_model, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 170), (void *)_cffi_d_DipoleEdgeData_getp_model },
  { "DipoleEdgeData_getp_r21", (void *)_cffi_f_DipoleEdgeData_getp_r21, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_r21 },
  { "DipoleEdgeData_getp_r43", (void *)_cffi_f_DipoleEdgeData_getp_r43, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 37), (void *)_cffi_d_DipoleEdgeData_getp_r43 },
  { "DipoleEdgeData_getp_side", (void *)_cffi_f_DipoleEdgeData_getp_side, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 170), (void *)_cffi_d_DipoleEdgeData_getp_side },
  { "DipoleEdgeData_set_delta_taper", (void *)_cffi_f_DipoleEdgeData_set_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_delta_taper },
  { "DipoleEdgeData_set_e1", (void *)_cffi_f_DipoleEdgeData_set_e1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_e1 },
  { "DipoleEdgeData_set_e1_fd", (void *)_cffi_f_DipoleEdgeData_set_e1_fd, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_e1_fd },
  { "DipoleEdgeData_set_fint", (void *)_cffi_f_DipoleEdgeData_set_fint, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_fint },
  { "DipoleEdgeData_set_hgap", (void *)_cffi_f_DipoleEdgeData_set_hgap, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_hgap },
  { "DipoleEdgeData_set_k", (void *)_cffi_f_DipoleEdgeData_set_k, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_k },
  { "DipoleEdgeData_set_model", (void *)_cffi_f_DipoleEdgeData_set_model, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 685), (void *)_cffi_d_DipoleEdgeData_set_model },
  { "DipoleEdgeData_set_r21", (void *)_cffi_f_DipoleEdgeData_set_r21, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_r21 },
  { "DipoleEdgeData_set_r43", (void *)_cffi_f_DipoleEdgeData_set_r43, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 681), (void *)_cffi_d_DipoleEdgeData_set_r43 },
  { "DipoleEdgeData_set_side", (void *)_cffi_f_DipoleEdgeData_set_side, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 685), (void *)_cffi_d_DipoleEdgeData_set_side },
  { "DriftData_get_length", (void *)_cffi_f_DriftData_get_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 107), (void *)_cffi_d_DriftData_get_length },
  { "DriftData_getp", (void *)_cffi_f_DriftData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 415), (void *)_cffi_d_DriftData_getp },
  { "DriftData_getp_length", (void *)_cffi_f_DriftData_getp_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 40), (void *)_cffi_d_DriftData_getp_length },
  { "DriftData_set_length", (void *)_cffi_f_DriftData_set_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 689), (void *)_cffi_d_DriftData_set_length },
  { "ElementRefClass_BeamBeamBiGaussian2DData_t", (void *)_cffi_const_ElementRefClass_BeamBeamBiGaussian2DData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_BeamBeamBiGaussian3DData_t", (void *)_cffi_const_ElementRefClass_BeamBeamBiGaussian3DData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_CavityData_t", (void *)_cffi_const_ElementRefClass_CavityData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_DipoleEdgeData_t", (void *)_cffi_const_ElementRefClass_DipoleEdgeData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_DriftData_t", (void *)_cffi_const_ElementRefClass_DriftData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_MarkerData_t", (void *)_cffi_const_ElementRefClass_MarkerData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_MultipoleData_t", (void *)_cffi_const_ElementRefClass_MultipoleData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_ParticlesMonitorData_t", (void *)_cffi_const_ElementRefClass_ParticlesMonitorData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_SRotationData_t", (void *)_cffi_const_ElementRefClass_SRotationData_t, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ElementRefClass_getp", (void *)_cffi_f_ElementRefClass_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 422), (void *)_cffi_d_ElementRefClass_getp },
  { "ElementRefClass_member", (void *)_cffi_f_ElementRefClass_member, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 568), (void *)_cffi_d_ElementRefClass_member },
  { "ElementRefClass_typeid", (void *)_cffi_f_ElementRefClass_typeid, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 263), (void *)_cffi_d_ElementRefClass_typeid },
  { "ElementRefData_getp", (void *)_cffi_f_ElementRefData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 429), (void *)_cffi_d_ElementRefData_getp },
  { "ElementRefData_getp1_elements", (void *)_cffi_f_ElementRefData_getp1_elements, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 425), (void *)_cffi_d_ElementRefData_getp1_elements },
  { "ElementRefData_getp1_names", (void *)_cffi_f_ElementRefData_getp1_names, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 4), (void *)_cffi_d_ElementRefData_getp1_names },
  { "ElementRefData_getp_elements", (void *)_cffi_f_ElementRefData_getp_elements, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 316), (void *)_cffi_d_ElementRefData_getp_elements },
  { "ElementRefData_getp_names", (void *)_cffi_f_ElementRefData_getp_names, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 376), (void *)_cffi_d_ElementRefData_getp_names },
  { "ElementRefData_len_elements", (void *)_cffi_f_ElementRefData_len_elements, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 266), (void *)_cffi_d_ElementRefData_len_elements },
  { "ElementRefData_len_names", (void *)_cffi_f_ElementRefData_len_names, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 266), (void *)_cffi_d_ElementRefData_len_names },
  { "ElementRefData_member_elements", (void *)_cffi_f_ElementRefData_member_elements, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 571), (void *)_cffi_d_ElementRefData_member_elements },
  { "ElementRefData_typeid_elements", (void *)_cffi_f_ElementRefData_typeid_elements, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 269), (void *)_cffi_d_ElementRefData_typeid_elements },
  { "LumiTableData_get__index__dummy", (void *)_cffi_f_LumiTableData_get__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 535), (void *)_cffi_d_LumiTableData_get__index__dummy },
  { "LumiTableData_get__index_buffer_id", (void *)_cffi_f_LumiTableData_get__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_get__index_buffer_id },
  { "LumiTableData_get__index_capacity", (void *)_cffi_f_LumiTableData_get__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_get__index_capacity },
  { "LumiTableData_get__index_num_recorded", (void *)_cffi_f_LumiTableData_get__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 535), (void *)_cffi_d_LumiTableData_get__index_num_recorded },
  { "LumiTableData_get_at_element", (void *)_cffi_f_LumiTableData_get_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LumiTableData_get_at_element },
  { "LumiTableData_get_at_turn", (void *)_cffi_f_LumiTableData_get_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LumiTableData_get_at_turn },
  { "LumiTableData_get_luminosity", (void *)_cffi_f_LumiTableData_get_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 110), (void *)_cffi_d_LumiTableData_get_luminosity },
  { "LumiTableData_get_particle_id", (void *)_cffi_f_LumiTableData_get_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_LumiTableData_get_particle_id },
  { "LumiTableData_getp", (void *)_cffi_f_LumiTableData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 435), (void *)_cffi_d_LumiTableData_getp },
  { "LumiTableData_getp1_at_element", (void *)_cffi_f_LumiTableData_getp1_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 176), (void *)_cffi_d_LumiTableData_getp1_at_element },
  { "LumiTableData_getp1_at_turn", (void *)_cffi_f_LumiTableData_getp1_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 176), (void *)_cffi_d_LumiTableData_getp1_at_turn },
  { "LumiTableData_getp1_luminosity", (void *)_cffi_f_LumiTableData_getp1_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 43), (void *)_cffi_d_LumiTableData_getp1_luminosity },
  { "LumiTableData_getp1_particle_id", (void *)_cffi_f_LumiTableData_getp1_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 176), (void *)_cffi_d_LumiTableData_getp1_particle_id },
  { "LumiTableData_getp__index", (void *)_cffi_f_LumiTableData_getp__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 477), (void *)_cffi_d_LumiTableData_getp__index },
  { "LumiTableData_getp__index__dummy", (void *)_cffi_f_LumiTableData_getp__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 505), (void *)_cffi_d_LumiTableData_getp__index__dummy },
  { "LumiTableData_getp__index_buffer_id", (void *)_cffi_f_LumiTableData_getp__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 173), (void *)_cffi_d_LumiTableData_getp__index_buffer_id },
  { "LumiTableData_getp__index_capacity", (void *)_cffi_f_LumiTableData_getp__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 173), (void *)_cffi_d_LumiTableData_getp__index_capacity },
  { "LumiTableData_getp__index_num_recorded", (void *)_cffi_f_LumiTableData_getp__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 505), (void *)_cffi_d_LumiTableData_getp__index_num_recorded },
  { "LumiTableData_getp_at_element", (void *)_cffi_f_LumiTableData_getp_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 361), (void *)_cffi_d_LumiTableData_getp_at_element },
  { "LumiTableData_getp_at_turn", (void *)_cffi_f_LumiTableData_getp_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 361), (void *)_cffi_d_LumiTableData_getp_at_turn },
  { "LumiTableData_getp_luminosity", (void *)_cffi_f_LumiTableData_getp_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 334), (void *)_cffi_d_LumiTableData_getp_luminosity },
  { "LumiTableData_getp_particle_id", (void *)_cffi_f_LumiTableData_getp_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 361), (void *)_cffi_d_LumiTableData_getp_particle_id },
  { "LumiTableData_len_at_element", (void *)_cffi_f_LumiTableData_len_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_len_at_element },
  { "LumiTableData_len_at_turn", (void *)_cffi_f_LumiTableData_len_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_len_at_turn },
  { "LumiTableData_len_luminosity", (void *)_cffi_f_LumiTableData_len_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_len_luminosity },
  { "LumiTableData_len_particle_id", (void *)_cffi_f_LumiTableData_len_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 273), (void *)_cffi_d_LumiTableData_len_particle_id },
  { "LumiTableData_set__index__dummy", (void *)_cffi_f_LumiTableData_set__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 707), (void *)_cffi_d_LumiTableData_set__index__dummy },
  { "LumiTableData_set__index_buffer_id", (void *)_cffi_f_LumiTableData_set__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 693), (void *)_cffi_d_LumiTableData_set__index_buffer_id },
  { "LumiTableData_set__index_capacity", (void *)_cffi_f_LumiTableData_set__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 693), (void *)_cffi_d_LumiTableData_set__index_capacity },
  { "LumiTableData_set__index_num_recorded", (void *)_cffi_f_LumiTableData_set__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 707), (void *)_cffi_d_LumiTableData_set__index_num_recorded },
  { "LumiTableData_set_at_element", (void *)_cffi_f_LumiTableData_set_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 702), (void *)_cffi_d_LumiTableData_set_at_element },
  { "LumiTableData_set_at_turn", (void *)_cffi_f_LumiTableData_set_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 702), (void *)_cffi_d_LumiTableData_set_at_turn },
  { "LumiTableData_set_luminosity", (void *)_cffi_f_LumiTableData_set_luminosity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 697), (void *)_cffi_d_LumiTableData_set_luminosity },
  { "LumiTableData_set_particle_id", (void *)_cffi_f_LumiTableData_set_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 702), (void *)_cffi_d_LumiTableData_set_particle_id },
  { "MarkerData_get__dummy", (void *)_cffi_f_MarkerData_get__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 280), (void *)_cffi_d_MarkerData_get__dummy },
  { "MarkerData_getp", (void *)_cffi_f_MarkerData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 438), (void *)_cffi_d_MarkerData_getp },
  { "MarkerData_getp__dummy", (void *)_cffi_f_MarkerData_getp__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 180), (void *)_cffi_d_MarkerData_getp__dummy },
  { "MarkerData_set__dummy", (void *)_cffi_f_MarkerData_set__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 711), (void *)_cffi_d_MarkerData_set__dummy },
  { "MultipoleData_get__internal_record_id_buffer_id", (void *)_cffi_f_MultipoleData_get__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_get__internal_record_id_buffer_id },
  { "MultipoleData_get__internal_record_id_offset", (void *)_cffi_f_MultipoleData_get__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_get__internal_record_id_offset },
  { "MultipoleData_get_delta_taper", (void *)_cffi_f_MultipoleData_get_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 114), (void *)_cffi_d_MultipoleData_get_delta_taper },
  { "MultipoleData_get_hxl", (void *)_cffi_f_MultipoleData_get_hxl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 114), (void *)_cffi_d_MultipoleData_get_hxl },
  { "MultipoleData_get_hyl", (void *)_cffi_f_MultipoleData_get_hyl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 114), (void *)_cffi_d_MultipoleData_get_hyl },
  { "MultipoleData_get_inv_factorial_order", (void *)_cffi_f_MultipoleData_get_inv_factorial_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 114), (void *)_cffi_d_MultipoleData_get_inv_factorial_order },
  { "MultipoleData_get_knl", (void *)_cffi_f_MultipoleData_get_knl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 117), (void *)_cffi_d_MultipoleData_get_knl },
  { "MultipoleData_get_ksl", (void *)_cffi_f_MultipoleData_get_ksl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 117), (void *)_cffi_d_MultipoleData_get_ksl },
  { "MultipoleData_get_length", (void *)_cffi_f_MultipoleData_get_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 114), (void *)_cffi_d_MultipoleData_get_length },
  { "MultipoleData_get_order", (void *)_cffi_f_MultipoleData_get_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_get_order },
  { "MultipoleData_get_radiation_flag", (void *)_cffi_f_MultipoleData_get_radiation_flag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_get_radiation_flag },
  { "MultipoleData_getp", (void *)_cffi_f_MultipoleData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 441), (void *)_cffi_d_MultipoleData_getp },
  { "MultipoleData_getp1_knl", (void *)_cffi_f_MultipoleData_getp1_knl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_MultipoleData_getp1_knl },
  { "MultipoleData_getp1_ksl", (void *)_cffi_f_MultipoleData_getp1_ksl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_MultipoleData_getp1_ksl },
  { "MultipoleData_getp__internal_record_id", (void *)_cffi_f_MultipoleData_getp__internal_record_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 462), (void *)_cffi_d_MultipoleData_getp__internal_record_id },
  { "MultipoleData_getp__internal_record_id_buffer_id", (void *)_cffi_f_MultipoleData_getp__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 183), (void *)_cffi_d_MultipoleData_getp__internal_record_id_buffer_id },
  { "MultipoleData_getp__internal_record_id_offset", (void *)_cffi_f_MultipoleData_getp__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 183), (void *)_cffi_d_MultipoleData_getp__internal_record_id_offset },
  { "MultipoleData_getp_delta_taper", (void *)_cffi_f_MultipoleData_getp_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 47), (void *)_cffi_d_MultipoleData_getp_delta_taper },
  { "MultipoleData_getp_hxl", (void *)_cffi_f_MultipoleData_getp_hxl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 47), (void *)_cffi_d_MultipoleData_getp_hxl },
  { "MultipoleData_getp_hyl", (void *)_cffi_f_MultipoleData_getp_hyl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 47), (void *)_cffi_d_MultipoleData_getp_hyl },
  { "MultipoleData_getp_inv_factorial_order", (void *)_cffi_f_MultipoleData_getp_inv_factorial_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 47), (void *)_cffi_d_MultipoleData_getp_inv_factorial_order },
  { "MultipoleData_getp_knl", (void *)_cffi_f_MultipoleData_getp_knl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 337), (void *)_cffi_d_MultipoleData_getp_knl },
  { "MultipoleData_getp_ksl", (void *)_cffi_f_MultipoleData_getp_ksl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 337), (void *)_cffi_d_MultipoleData_getp_ksl },
  { "MultipoleData_getp_length", (void *)_cffi_f_MultipoleData_getp_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 47), (void *)_cffi_d_MultipoleData_getp_length },
  { "MultipoleData_getp_order", (void *)_cffi_f_MultipoleData_getp_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 183), (void *)_cffi_d_MultipoleData_getp_order },
  { "MultipoleData_getp_radiation_flag", (void *)_cffi_f_MultipoleData_getp_radiation_flag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 183), (void *)_cffi_d_MultipoleData_getp_radiation_flag },
  { "MultipoleData_len_knl", (void *)_cffi_f_MultipoleData_len_knl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_len_knl },
  { "MultipoleData_len_ksl", (void *)_cffi_f_MultipoleData_len_ksl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 283), (void *)_cffi_d_MultipoleData_len_ksl },
  { "MultipoleData_set__internal_record_id_buffer_id", (void *)_cffi_f_MultipoleData_set__internal_record_id_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 719), (void *)_cffi_d_MultipoleData_set__internal_record_id_buffer_id },
  { "MultipoleData_set__internal_record_id_offset", (void *)_cffi_f_MultipoleData_set__internal_record_id_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 719), (void *)_cffi_d_MultipoleData_set__internal_record_id_offset },
  { "MultipoleData_set_delta_taper", (void *)_cffi_f_MultipoleData_set_delta_taper, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 715), (void *)_cffi_d_MultipoleData_set_delta_taper },
  { "MultipoleData_set_hxl", (void *)_cffi_f_MultipoleData_set_hxl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 715), (void *)_cffi_d_MultipoleData_set_hxl },
  { "MultipoleData_set_hyl", (void *)_cffi_f_MultipoleData_set_hyl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 715), (void *)_cffi_d_MultipoleData_set_hyl },
  { "MultipoleData_set_inv_factorial_order", (void *)_cffi_f_MultipoleData_set_inv_factorial_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 715), (void *)_cffi_d_MultipoleData_set_inv_factorial_order },
  { "MultipoleData_set_knl", (void *)_cffi_f_MultipoleData_set_knl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 723), (void *)_cffi_d_MultipoleData_set_knl },
  { "MultipoleData_set_ksl", (void *)_cffi_f_MultipoleData_set_ksl, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 723), (void *)_cffi_d_MultipoleData_set_ksl },
  { "MultipoleData_set_length", (void *)_cffi_f_MultipoleData_set_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 715), (void *)_cffi_d_MultipoleData_set_length },
  { "MultipoleData_set_order", (void *)_cffi_f_MultipoleData_set_order, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 719), (void *)_cffi_d_MultipoleData_set_order },
  { "MultipoleData_set_radiation_flag", (void *)_cffi_f_MultipoleData_set_radiation_flag, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 719), (void *)_cffi_d_MultipoleData_set_radiation_flag },
  { "ParticlesData_get__capacity", (void *)_cffi_f_ParticlesData_get__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_get__capacity },
  { "ParticlesData_get__num_active_particles", (void *)_cffi_f_ParticlesData_get__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_get__num_active_particles },
  { "ParticlesData_get__num_lost_particles", (void *)_cffi_f_ParticlesData_get__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_get__num_lost_particles },
  { "ParticlesData_get__rng_s1", (void *)_cffi_f_ParticlesData_get__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 538), (void *)_cffi_d_ParticlesData_get__rng_s1 },
  { "ParticlesData_get__rng_s2", (void *)_cffi_f_ParticlesData_get__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 538), (void *)_cffi_d_ParticlesData_get__rng_s2 },
  { "ParticlesData_get__rng_s3", (void *)_cffi_f_ParticlesData_get__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 538), (void *)_cffi_d_ParticlesData_get__rng_s3 },
  { "ParticlesData_get__rng_s4", (void *)_cffi_f_ParticlesData_get__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 538), (void *)_cffi_d_ParticlesData_get__rng_s4 },
  { "ParticlesData_get_at_element", (void *)_cffi_f_ParticlesData_get_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_at_element },
  { "ParticlesData_get_at_turn", (void *)_cffi_f_ParticlesData_get_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_at_turn },
  { "ParticlesData_get_beta0", (void *)_cffi_f_ParticlesData_get_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_beta0 },
  { "ParticlesData_get_charge_ratio", (void *)_cffi_f_ParticlesData_get_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_charge_ratio },
  { "ParticlesData_get_chi", (void *)_cffi_f_ParticlesData_get_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_chi },
  { "ParticlesData_get_delta", (void *)_cffi_f_ParticlesData_get_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_delta },
  { "ParticlesData_get_gamma0", (void *)_cffi_f_ParticlesData_get_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_gamma0 },
  { "ParticlesData_get_mass0", (void *)_cffi_f_ParticlesData_get_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 121), (void *)_cffi_d_ParticlesData_get_mass0 },
  { "ParticlesData_get_p0c", (void *)_cffi_f_ParticlesData_get_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_p0c },
  { "ParticlesData_get_parent_particle_id", (void *)_cffi_f_ParticlesData_get_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_parent_particle_id },
  { "ParticlesData_get_particle_id", (void *)_cffi_f_ParticlesData_get_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_particle_id },
  { "ParticlesData_get_pdg_id", (void *)_cffi_f_ParticlesData_get_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_pdg_id },
  { "ParticlesData_get_ptau", (void *)_cffi_f_ParticlesData_get_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_ptau },
  { "ParticlesData_get_px", (void *)_cffi_f_ParticlesData_get_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_px },
  { "ParticlesData_get_py", (void *)_cffi_f_ParticlesData_get_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_py },
  { "ParticlesData_get_q0", (void *)_cffi_f_ParticlesData_get_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 121), (void *)_cffi_d_ParticlesData_get_q0 },
  { "ParticlesData_get_rpp", (void *)_cffi_f_ParticlesData_get_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_rpp },
  { "ParticlesData_get_rvv", (void *)_cffi_f_ParticlesData_get_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_rvv },
  { "ParticlesData_get_s", (void *)_cffi_f_ParticlesData_get_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_s },
  { "ParticlesData_get_start_tracking_at_element", (void *)_cffi_f_ParticlesData_get_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_get_start_tracking_at_element },
  { "ParticlesData_get_state", (void *)_cffi_f_ParticlesData_get_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 289), (void *)_cffi_d_ParticlesData_get_state },
  { "ParticlesData_get_weight", (void *)_cffi_f_ParticlesData_get_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_weight },
  { "ParticlesData_get_x", (void *)_cffi_f_ParticlesData_get_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_x },
  { "ParticlesData_get_y", (void *)_cffi_f_ParticlesData_get_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_y },
  { "ParticlesData_get_zeta", (void *)_cffi_f_ParticlesData_get_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 124), (void *)_cffi_d_ParticlesData_get_zeta },
  { "ParticlesData_getp", (void *)_cffi_f_ParticlesData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 444), (void *)_cffi_d_ParticlesData_getp },
  { "ParticlesData_getp1__rng_s1", (void *)_cffi_f_ParticlesData_getp1__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 508), (void *)_cffi_d_ParticlesData_getp1__rng_s1 },
  { "ParticlesData_getp1__rng_s2", (void *)_cffi_f_ParticlesData_getp1__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 508), (void *)_cffi_d_ParticlesData_getp1__rng_s2 },
  { "ParticlesData_getp1__rng_s3", (void *)_cffi_f_ParticlesData_getp1__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 508), (void *)_cffi_d_ParticlesData_getp1__rng_s3 },
  { "ParticlesData_getp1__rng_s4", (void *)_cffi_f_ParticlesData_getp1__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 508), (void *)_cffi_d_ParticlesData_getp1__rng_s4 },
  { "ParticlesData_getp1_at_element", (void *)_cffi_f_ParticlesData_getp1_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_at_element },
  { "ParticlesData_getp1_at_turn", (void *)_cffi_f_ParticlesData_getp1_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_at_turn },
  { "ParticlesData_getp1_beta0", (void *)_cffi_f_ParticlesData_getp1_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_beta0 },
  { "ParticlesData_getp1_charge_ratio", (void *)_cffi_f_ParticlesData_getp1_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_charge_ratio },
  { "ParticlesData_getp1_chi", (void *)_cffi_f_ParticlesData_getp1_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_chi },
  { "ParticlesData_getp1_delta", (void *)_cffi_f_ParticlesData_getp1_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_delta },
  { "ParticlesData_getp1_gamma0", (void *)_cffi_f_ParticlesData_getp1_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_gamma0 },
  { "ParticlesData_getp1_p0c", (void *)_cffi_f_ParticlesData_getp1_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_p0c },
  { "ParticlesData_getp1_parent_particle_id", (void *)_cffi_f_ParticlesData_getp1_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_parent_particle_id },
  { "ParticlesData_getp1_particle_id", (void *)_cffi_f_ParticlesData_getp1_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_particle_id },
  { "ParticlesData_getp1_pdg_id", (void *)_cffi_f_ParticlesData_getp1_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_pdg_id },
  { "ParticlesData_getp1_ptau", (void *)_cffi_f_ParticlesData_getp1_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_ptau },
  { "ParticlesData_getp1_px", (void *)_cffi_f_ParticlesData_getp1_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_px },
  { "ParticlesData_getp1_py", (void *)_cffi_f_ParticlesData_getp1_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_py },
  { "ParticlesData_getp1_rpp", (void *)_cffi_f_ParticlesData_getp1_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_rpp },
  { "ParticlesData_getp1_rvv", (void *)_cffi_f_ParticlesData_getp1_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_rvv },
  { "ParticlesData_getp1_s", (void *)_cffi_f_ParticlesData_getp1_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_s },
  { "ParticlesData_getp1_state", (void *)_cffi_f_ParticlesData_getp1_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 189), (void *)_cffi_d_ParticlesData_getp1_state },
  { "ParticlesData_getp1_weight", (void *)_cffi_f_ParticlesData_getp1_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_weight },
  { "ParticlesData_getp1_x", (void *)_cffi_f_ParticlesData_getp1_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_x },
  { "ParticlesData_getp1_y", (void *)_cffi_f_ParticlesData_getp1_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_y },
  { "ParticlesData_getp1_zeta", (void *)_cffi_f_ParticlesData_getp1_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_ParticlesData_getp1_zeta },
  { "ParticlesData_getp__capacity", (void *)_cffi_f_ParticlesData_getp__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 186), (void *)_cffi_d_ParticlesData_getp__capacity },
  { "ParticlesData_getp__num_active_particles", (void *)_cffi_f_ParticlesData_getp__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 186), (void *)_cffi_d_ParticlesData_getp__num_active_particles },
  { "ParticlesData_getp__num_lost_particles", (void *)_cffi_f_ParticlesData_getp__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 186), (void *)_cffi_d_ParticlesData_getp__num_lost_particles },
  { "ParticlesData_getp__rng_s1", (void *)_cffi_f_ParticlesData_getp__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 382), (void *)_cffi_d_ParticlesData_getp__rng_s1 },
  { "ParticlesData_getp__rng_s2", (void *)_cffi_f_ParticlesData_getp__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 382), (void *)_cffi_d_ParticlesData_getp__rng_s2 },
  { "ParticlesData_getp__rng_s3", (void *)_cffi_f_ParticlesData_getp__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 382), (void *)_cffi_d_ParticlesData_getp__rng_s3 },
  { "ParticlesData_getp__rng_s4", (void *)_cffi_f_ParticlesData_getp__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 382), (void *)_cffi_d_ParticlesData_getp__rng_s4 },
  { "ParticlesData_getp_at_element", (void *)_cffi_f_ParticlesData_getp_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_at_element },
  { "ParticlesData_getp_at_turn", (void *)_cffi_f_ParticlesData_getp_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_at_turn },
  { "ParticlesData_getp_beta0", (void *)_cffi_f_ParticlesData_getp_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_beta0 },
  { "ParticlesData_getp_charge_ratio", (void *)_cffi_f_ParticlesData_getp_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_charge_ratio },
  { "ParticlesData_getp_chi", (void *)_cffi_f_ParticlesData_getp_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_chi },
  { "ParticlesData_getp_delta", (void *)_cffi_f_ParticlesData_getp_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_delta },
  { "ParticlesData_getp_gamma0", (void *)_cffi_f_ParticlesData_getp_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_gamma0 },
  { "ParticlesData_getp_mass0", (void *)_cffi_f_ParticlesData_getp_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 54), (void *)_cffi_d_ParticlesData_getp_mass0 },
  { "ParticlesData_getp_p0c", (void *)_cffi_f_ParticlesData_getp_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_p0c },
  { "ParticlesData_getp_parent_particle_id", (void *)_cffi_f_ParticlesData_getp_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_parent_particle_id },
  { "ParticlesData_getp_particle_id", (void *)_cffi_f_ParticlesData_getp_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_particle_id },
  { "ParticlesData_getp_pdg_id", (void *)_cffi_f_ParticlesData_getp_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_pdg_id },
  { "ParticlesData_getp_ptau", (void *)_cffi_f_ParticlesData_getp_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_ptau },
  { "ParticlesData_getp_px", (void *)_cffi_f_ParticlesData_getp_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_px },
  { "ParticlesData_getp_py", (void *)_cffi_f_ParticlesData_getp_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_py },
  { "ParticlesData_getp_q0", (void *)_cffi_f_ParticlesData_getp_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 54), (void *)_cffi_d_ParticlesData_getp_q0 },
  { "ParticlesData_getp_rpp", (void *)_cffi_f_ParticlesData_getp_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_rpp },
  { "ParticlesData_getp_rvv", (void *)_cffi_f_ParticlesData_getp_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_rvv },
  { "ParticlesData_getp_s", (void *)_cffi_f_ParticlesData_getp_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_s },
  { "ParticlesData_getp_start_tracking_at_element", (void *)_cffi_f_ParticlesData_getp_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 186), (void *)_cffi_d_ParticlesData_getp_start_tracking_at_element },
  { "ParticlesData_getp_state", (void *)_cffi_f_ParticlesData_getp_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 364), (void *)_cffi_d_ParticlesData_getp_state },
  { "ParticlesData_getp_weight", (void *)_cffi_f_ParticlesData_getp_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_weight },
  { "ParticlesData_getp_x", (void *)_cffi_f_ParticlesData_getp_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_x },
  { "ParticlesData_getp_y", (void *)_cffi_f_ParticlesData_getp_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_y },
  { "ParticlesData_getp_zeta", (void *)_cffi_f_ParticlesData_getp_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 340), (void *)_cffi_d_ParticlesData_getp_zeta },
  { "ParticlesData_len__rng_s1", (void *)_cffi_f_ParticlesData_len__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len__rng_s1 },
  { "ParticlesData_len__rng_s2", (void *)_cffi_f_ParticlesData_len__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len__rng_s2 },
  { "ParticlesData_len__rng_s3", (void *)_cffi_f_ParticlesData_len__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len__rng_s3 },
  { "ParticlesData_len__rng_s4", (void *)_cffi_f_ParticlesData_len__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len__rng_s4 },
  { "ParticlesData_len_at_element", (void *)_cffi_f_ParticlesData_len_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_at_element },
  { "ParticlesData_len_at_turn", (void *)_cffi_f_ParticlesData_len_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_at_turn },
  { "ParticlesData_len_beta0", (void *)_cffi_f_ParticlesData_len_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_beta0 },
  { "ParticlesData_len_charge_ratio", (void *)_cffi_f_ParticlesData_len_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_charge_ratio },
  { "ParticlesData_len_chi", (void *)_cffi_f_ParticlesData_len_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_chi },
  { "ParticlesData_len_delta", (void *)_cffi_f_ParticlesData_len_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_delta },
  { "ParticlesData_len_gamma0", (void *)_cffi_f_ParticlesData_len_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_gamma0 },
  { "ParticlesData_len_p0c", (void *)_cffi_f_ParticlesData_len_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_p0c },
  { "ParticlesData_len_parent_particle_id", (void *)_cffi_f_ParticlesData_len_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_parent_particle_id },
  { "ParticlesData_len_particle_id", (void *)_cffi_f_ParticlesData_len_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_particle_id },
  { "ParticlesData_len_pdg_id", (void *)_cffi_f_ParticlesData_len_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_pdg_id },
  { "ParticlesData_len_ptau", (void *)_cffi_f_ParticlesData_len_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_ptau },
  { "ParticlesData_len_px", (void *)_cffi_f_ParticlesData_len_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_px },
  { "ParticlesData_len_py", (void *)_cffi_f_ParticlesData_len_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_py },
  { "ParticlesData_len_rpp", (void *)_cffi_f_ParticlesData_len_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_rpp },
  { "ParticlesData_len_rvv", (void *)_cffi_f_ParticlesData_len_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_rvv },
  { "ParticlesData_len_s", (void *)_cffi_f_ParticlesData_len_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_s },
  { "ParticlesData_len_state", (void *)_cffi_f_ParticlesData_len_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_state },
  { "ParticlesData_len_weight", (void *)_cffi_f_ParticlesData_len_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_weight },
  { "ParticlesData_len_x", (void *)_cffi_f_ParticlesData_len_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_x },
  { "ParticlesData_len_y", (void *)_cffi_f_ParticlesData_len_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_y },
  { "ParticlesData_len_zeta", (void *)_cffi_f_ParticlesData_len_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 286), (void *)_cffi_d_ParticlesData_len_zeta },
  { "ParticlesData_set__capacity", (void *)_cffi_f_ParticlesData_set__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 732), (void *)_cffi_d_ParticlesData_set__capacity },
  { "ParticlesData_set__num_active_particles", (void *)_cffi_f_ParticlesData_set__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 732), (void *)_cffi_d_ParticlesData_set__num_active_particles },
  { "ParticlesData_set__num_lost_particles", (void *)_cffi_f_ParticlesData_set__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 732), (void *)_cffi_d_ParticlesData_set__num_lost_particles },
  { "ParticlesData_set__rng_s1", (void *)_cffi_f_ParticlesData_set__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 746), (void *)_cffi_d_ParticlesData_set__rng_s1 },
  { "ParticlesData_set__rng_s2", (void *)_cffi_f_ParticlesData_set__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 746), (void *)_cffi_d_ParticlesData_set__rng_s2 },
  { "ParticlesData_set__rng_s3", (void *)_cffi_f_ParticlesData_set__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 746), (void *)_cffi_d_ParticlesData_set__rng_s3 },
  { "ParticlesData_set__rng_s4", (void *)_cffi_f_ParticlesData_set__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 746), (void *)_cffi_d_ParticlesData_set__rng_s4 },
  { "ParticlesData_set_at_element", (void *)_cffi_f_ParticlesData_set_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_at_element },
  { "ParticlesData_set_at_turn", (void *)_cffi_f_ParticlesData_set_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_at_turn },
  { "ParticlesData_set_beta0", (void *)_cffi_f_ParticlesData_set_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_beta0 },
  { "ParticlesData_set_charge_ratio", (void *)_cffi_f_ParticlesData_set_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_charge_ratio },
  { "ParticlesData_set_chi", (void *)_cffi_f_ParticlesData_set_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_chi },
  { "ParticlesData_set_delta", (void *)_cffi_f_ParticlesData_set_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_delta },
  { "ParticlesData_set_gamma0", (void *)_cffi_f_ParticlesData_set_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_gamma0 },
  { "ParticlesData_set_mass0", (void *)_cffi_f_ParticlesData_set_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 728), (void *)_cffi_d_ParticlesData_set_mass0 },
  { "ParticlesData_set_p0c", (void *)_cffi_f_ParticlesData_set_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_p0c },
  { "ParticlesData_set_parent_particle_id", (void *)_cffi_f_ParticlesData_set_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_parent_particle_id },
  { "ParticlesData_set_particle_id", (void *)_cffi_f_ParticlesData_set_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_particle_id },
  { "ParticlesData_set_pdg_id", (void *)_cffi_f_ParticlesData_set_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_pdg_id },
  { "ParticlesData_set_ptau", (void *)_cffi_f_ParticlesData_set_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_ptau },
  { "ParticlesData_set_px", (void *)_cffi_f_ParticlesData_set_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_px },
  { "ParticlesData_set_py", (void *)_cffi_f_ParticlesData_set_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_py },
  { "ParticlesData_set_q0", (void *)_cffi_f_ParticlesData_set_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 728), (void *)_cffi_d_ParticlesData_set_q0 },
  { "ParticlesData_set_rpp", (void *)_cffi_f_ParticlesData_set_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_rpp },
  { "ParticlesData_set_rvv", (void *)_cffi_f_ParticlesData_set_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_rvv },
  { "ParticlesData_set_s", (void *)_cffi_f_ParticlesData_set_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_s },
  { "ParticlesData_set_start_tracking_at_element", (void *)_cffi_f_ParticlesData_set_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 732), (void *)_cffi_d_ParticlesData_set_start_tracking_at_element },
  { "ParticlesData_set_state", (void *)_cffi_f_ParticlesData_set_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 741), (void *)_cffi_d_ParticlesData_set_state },
  { "ParticlesData_set_weight", (void *)_cffi_f_ParticlesData_set_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_weight },
  { "ParticlesData_set_x", (void *)_cffi_f_ParticlesData_set_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_x },
  { "ParticlesData_set_y", (void *)_cffi_f_ParticlesData_set_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_y },
  { "ParticlesData_set_zeta", (void *)_cffi_f_ParticlesData_set_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 736), (void *)_cffi_d_ParticlesData_set_zeta },
  { "ParticlesMonitorData_get_data__capacity", (void *)_cffi_f_ParticlesMonitorData_get_data__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_data__capacity },
  { "ParticlesMonitorData_get_data__num_active_particles", (void *)_cffi_f_ParticlesMonitorData_get_data__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_data__num_active_particles },
  { "ParticlesMonitorData_get_data__num_lost_particles", (void *)_cffi_f_ParticlesMonitorData_get_data__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_data__num_lost_particles },
  { "ParticlesMonitorData_get_data__rng_s1", (void *)_cffi_f_ParticlesMonitorData_get_data__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 542), (void *)_cffi_d_ParticlesMonitorData_get_data__rng_s1 },
  { "ParticlesMonitorData_get_data__rng_s2", (void *)_cffi_f_ParticlesMonitorData_get_data__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 542), (void *)_cffi_d_ParticlesMonitorData_get_data__rng_s2 },
  { "ParticlesMonitorData_get_data__rng_s3", (void *)_cffi_f_ParticlesMonitorData_get_data__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 542), (void *)_cffi_d_ParticlesMonitorData_get_data__rng_s3 },
  { "ParticlesMonitorData_get_data__rng_s4", (void *)_cffi_f_ParticlesMonitorData_get_data__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 542), (void *)_cffi_d_ParticlesMonitorData_get_data__rng_s4 },
  { "ParticlesMonitorData_get_data_at_element", (void *)_cffi_f_ParticlesMonitorData_get_data_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_at_element },
  { "ParticlesMonitorData_get_data_at_turn", (void *)_cffi_f_ParticlesMonitorData_get_data_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_at_turn },
  { "ParticlesMonitorData_get_data_beta0", (void *)_cffi_f_ParticlesMonitorData_get_data_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_beta0 },
  { "ParticlesMonitorData_get_data_charge_ratio", (void *)_cffi_f_ParticlesMonitorData_get_data_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_charge_ratio },
  { "ParticlesMonitorData_get_data_chi", (void *)_cffi_f_ParticlesMonitorData_get_data_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_chi },
  { "ParticlesMonitorData_get_data_delta", (void *)_cffi_f_ParticlesMonitorData_get_data_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_delta },
  { "ParticlesMonitorData_get_data_gamma0", (void *)_cffi_f_ParticlesMonitorData_get_data_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_gamma0 },
  { "ParticlesMonitorData_get_data_mass0", (void *)_cffi_f_ParticlesMonitorData_get_data_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 128), (void *)_cffi_d_ParticlesMonitorData_get_data_mass0 },
  { "ParticlesMonitorData_get_data_p0c", (void *)_cffi_f_ParticlesMonitorData_get_data_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_p0c },
  { "ParticlesMonitorData_get_data_parent_particle_id", (void *)_cffi_f_ParticlesMonitorData_get_data_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_parent_particle_id },
  { "ParticlesMonitorData_get_data_particle_id", (void *)_cffi_f_ParticlesMonitorData_get_data_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_particle_id },
  { "ParticlesMonitorData_get_data_pdg_id", (void *)_cffi_f_ParticlesMonitorData_get_data_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_pdg_id },
  { "ParticlesMonitorData_get_data_ptau", (void *)_cffi_f_ParticlesMonitorData_get_data_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_ptau },
  { "ParticlesMonitorData_get_data_px", (void *)_cffi_f_ParticlesMonitorData_get_data_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_px },
  { "ParticlesMonitorData_get_data_py", (void *)_cffi_f_ParticlesMonitorData_get_data_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_py },
  { "ParticlesMonitorData_get_data_q0", (void *)_cffi_f_ParticlesMonitorData_get_data_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 128), (void *)_cffi_d_ParticlesMonitorData_get_data_q0 },
  { "ParticlesMonitorData_get_data_rpp", (void *)_cffi_f_ParticlesMonitorData_get_data_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_rpp },
  { "ParticlesMonitorData_get_data_rvv", (void *)_cffi_f_ParticlesMonitorData_get_data_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_rvv },
  { "ParticlesMonitorData_get_data_s", (void *)_cffi_f_ParticlesMonitorData_get_data_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_s },
  { "ParticlesMonitorData_get_data_start_tracking_at_element", (void *)_cffi_f_ParticlesMonitorData_get_data_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_data_start_tracking_at_element },
  { "ParticlesMonitorData_get_data_state", (void *)_cffi_f_ParticlesMonitorData_get_data_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_ParticlesMonitorData_get_data_state },
  { "ParticlesMonitorData_get_data_weight", (void *)_cffi_f_ParticlesMonitorData_get_data_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_weight },
  { "ParticlesMonitorData_get_data_x", (void *)_cffi_f_ParticlesMonitorData_get_data_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_x },
  { "ParticlesMonitorData_get_data_y", (void *)_cffi_f_ParticlesMonitorData_get_data_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_y },
  { "ParticlesMonitorData_get_data_zeta", (void *)_cffi_f_ParticlesMonitorData_get_data_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 131), (void *)_cffi_d_ParticlesMonitorData_get_data_zeta },
  { "ParticlesMonitorData_get_ebe_mode", (void *)_cffi_f_ParticlesMonitorData_get_ebe_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_ebe_mode },
  { "ParticlesMonitorData_get_flag_auto_to_numpy", (void *)_cffi_f_ParticlesMonitorData_get_flag_auto_to_numpy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_flag_auto_to_numpy },
  { "ParticlesMonitorData_get_n_records", (void *)_cffi_f_ParticlesMonitorData_get_n_records, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_n_records },
  { "ParticlesMonitorData_get_n_repetitions", (void *)_cffi_f_ParticlesMonitorData_get_n_repetitions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_n_repetitions },
  { "ParticlesMonitorData_get_part_id_end", (void *)_cffi_f_ParticlesMonitorData_get_part_id_end, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_part_id_end },
  { "ParticlesMonitorData_get_part_id_start", (void *)_cffi_f_ParticlesMonitorData_get_part_id_start, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_part_id_start },
  { "ParticlesMonitorData_get_repetition_period", (void *)_cffi_f_ParticlesMonitorData_get_repetition_period, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_repetition_period },
  { "ParticlesMonitorData_get_start_at_turn", (void *)_cffi_f_ParticlesMonitorData_get_start_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_start_at_turn },
  { "ParticlesMonitorData_get_stop_at_turn", (void *)_cffi_f_ParticlesMonitorData_get_stop_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_get_stop_at_turn },
  { "ParticlesMonitorData_getp", (void *)_cffi_f_ParticlesMonitorData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 450), (void *)_cffi_d_ParticlesMonitorData_getp },
  { "ParticlesMonitorData_getp1_data__rng_s1", (void *)_cffi_f_ParticlesMonitorData_getp1_data__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 512), (void *)_cffi_d_ParticlesMonitorData_getp1_data__rng_s1 },
  { "ParticlesMonitorData_getp1_data__rng_s2", (void *)_cffi_f_ParticlesMonitorData_getp1_data__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 512), (void *)_cffi_d_ParticlesMonitorData_getp1_data__rng_s2 },
  { "ParticlesMonitorData_getp1_data__rng_s3", (void *)_cffi_f_ParticlesMonitorData_getp1_data__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 512), (void *)_cffi_d_ParticlesMonitorData_getp1_data__rng_s3 },
  { "ParticlesMonitorData_getp1_data__rng_s4", (void *)_cffi_f_ParticlesMonitorData_getp1_data__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 512), (void *)_cffi_d_ParticlesMonitorData_getp1_data__rng_s4 },
  { "ParticlesMonitorData_getp1_data_at_element", (void *)_cffi_f_ParticlesMonitorData_getp1_data_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_at_element },
  { "ParticlesMonitorData_getp1_data_at_turn", (void *)_cffi_f_ParticlesMonitorData_getp1_data_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_at_turn },
  { "ParticlesMonitorData_getp1_data_beta0", (void *)_cffi_f_ParticlesMonitorData_getp1_data_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_beta0 },
  { "ParticlesMonitorData_getp1_data_charge_ratio", (void *)_cffi_f_ParticlesMonitorData_getp1_data_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_charge_ratio },
  { "ParticlesMonitorData_getp1_data_chi", (void *)_cffi_f_ParticlesMonitorData_getp1_data_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_chi },
  { "ParticlesMonitorData_getp1_data_delta", (void *)_cffi_f_ParticlesMonitorData_getp1_data_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_delta },
  { "ParticlesMonitorData_getp1_data_gamma0", (void *)_cffi_f_ParticlesMonitorData_getp1_data_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_gamma0 },
  { "ParticlesMonitorData_getp1_data_p0c", (void *)_cffi_f_ParticlesMonitorData_getp1_data_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_p0c },
  { "ParticlesMonitorData_getp1_data_parent_particle_id", (void *)_cffi_f_ParticlesMonitorData_getp1_data_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_parent_particle_id },
  { "ParticlesMonitorData_getp1_data_particle_id", (void *)_cffi_f_ParticlesMonitorData_getp1_data_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_particle_id },
  { "ParticlesMonitorData_getp1_data_pdg_id", (void *)_cffi_f_ParticlesMonitorData_getp1_data_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_pdg_id },
  { "ParticlesMonitorData_getp1_data_ptau", (void *)_cffi_f_ParticlesMonitorData_getp1_data_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_ptau },
  { "ParticlesMonitorData_getp1_data_px", (void *)_cffi_f_ParticlesMonitorData_getp1_data_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_px },
  { "ParticlesMonitorData_getp1_data_py", (void *)_cffi_f_ParticlesMonitorData_getp1_data_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_py },
  { "ParticlesMonitorData_getp1_data_rpp", (void *)_cffi_f_ParticlesMonitorData_getp1_data_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_rpp },
  { "ParticlesMonitorData_getp1_data_rvv", (void *)_cffi_f_ParticlesMonitorData_getp1_data_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_rvv },
  { "ParticlesMonitorData_getp1_data_s", (void *)_cffi_f_ParticlesMonitorData_getp1_data_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_s },
  { "ParticlesMonitorData_getp1_data_state", (void *)_cffi_f_ParticlesMonitorData_getp1_data_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 196), (void *)_cffi_d_ParticlesMonitorData_getp1_data_state },
  { "ParticlesMonitorData_getp1_data_weight", (void *)_cffi_f_ParticlesMonitorData_getp1_data_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_weight },
  { "ParticlesMonitorData_getp1_data_x", (void *)_cffi_f_ParticlesMonitorData_getp1_data_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_x },
  { "ParticlesMonitorData_getp1_data_y", (void *)_cffi_f_ParticlesMonitorData_getp1_data_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_y },
  { "ParticlesMonitorData_getp1_data_zeta", (void *)_cffi_f_ParticlesMonitorData_getp1_data_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 64), (void *)_cffi_d_ParticlesMonitorData_getp1_data_zeta },
  { "ParticlesMonitorData_getp_data", (void *)_cffi_f_ParticlesMonitorData_getp_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 447), (void *)_cffi_d_ParticlesMonitorData_getp_data },
  { "ParticlesMonitorData_getp_data__capacity", (void *)_cffi_f_ParticlesMonitorData_getp_data__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_data__capacity },
  { "ParticlesMonitorData_getp_data__num_active_particles", (void *)_cffi_f_ParticlesMonitorData_getp_data__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_data__num_active_particles },
  { "ParticlesMonitorData_getp_data__num_lost_particles", (void *)_cffi_f_ParticlesMonitorData_getp_data__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_data__num_lost_particles },
  { "ParticlesMonitorData_getp_data__rng_s1", (void *)_cffi_f_ParticlesMonitorData_getp_data__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 385), (void *)_cffi_d_ParticlesMonitorData_getp_data__rng_s1 },
  { "ParticlesMonitorData_getp_data__rng_s2", (void *)_cffi_f_ParticlesMonitorData_getp_data__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 385), (void *)_cffi_d_ParticlesMonitorData_getp_data__rng_s2 },
  { "ParticlesMonitorData_getp_data__rng_s3", (void *)_cffi_f_ParticlesMonitorData_getp_data__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 385), (void *)_cffi_d_ParticlesMonitorData_getp_data__rng_s3 },
  { "ParticlesMonitorData_getp_data__rng_s4", (void *)_cffi_f_ParticlesMonitorData_getp_data__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 385), (void *)_cffi_d_ParticlesMonitorData_getp_data__rng_s4 },
  { "ParticlesMonitorData_getp_data_at_element", (void *)_cffi_f_ParticlesMonitorData_getp_data_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_at_element },
  { "ParticlesMonitorData_getp_data_at_turn", (void *)_cffi_f_ParticlesMonitorData_getp_data_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_at_turn },
  { "ParticlesMonitorData_getp_data_beta0", (void *)_cffi_f_ParticlesMonitorData_getp_data_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_beta0 },
  { "ParticlesMonitorData_getp_data_charge_ratio", (void *)_cffi_f_ParticlesMonitorData_getp_data_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_charge_ratio },
  { "ParticlesMonitorData_getp_data_chi", (void *)_cffi_f_ParticlesMonitorData_getp_data_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_chi },
  { "ParticlesMonitorData_getp_data_delta", (void *)_cffi_f_ParticlesMonitorData_getp_data_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_delta },
  { "ParticlesMonitorData_getp_data_gamma0", (void *)_cffi_f_ParticlesMonitorData_getp_data_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_gamma0 },
  { "ParticlesMonitorData_getp_data_mass0", (void *)_cffi_f_ParticlesMonitorData_getp_data_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 61), (void *)_cffi_d_ParticlesMonitorData_getp_data_mass0 },
  { "ParticlesMonitorData_getp_data_p0c", (void *)_cffi_f_ParticlesMonitorData_getp_data_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_p0c },
  { "ParticlesMonitorData_getp_data_parent_particle_id", (void *)_cffi_f_ParticlesMonitorData_getp_data_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_parent_particle_id },
  { "ParticlesMonitorData_getp_data_particle_id", (void *)_cffi_f_ParticlesMonitorData_getp_data_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_particle_id },
  { "ParticlesMonitorData_getp_data_pdg_id", (void *)_cffi_f_ParticlesMonitorData_getp_data_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_pdg_id },
  { "ParticlesMonitorData_getp_data_ptau", (void *)_cffi_f_ParticlesMonitorData_getp_data_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_ptau },
  { "ParticlesMonitorData_getp_data_px", (void *)_cffi_f_ParticlesMonitorData_getp_data_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_px },
  { "ParticlesMonitorData_getp_data_py", (void *)_cffi_f_ParticlesMonitorData_getp_data_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_py },
  { "ParticlesMonitorData_getp_data_q0", (void *)_cffi_f_ParticlesMonitorData_getp_data_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 61), (void *)_cffi_d_ParticlesMonitorData_getp_data_q0 },
  { "ParticlesMonitorData_getp_data_rpp", (void *)_cffi_f_ParticlesMonitorData_getp_data_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_rpp },
  { "ParticlesMonitorData_getp_data_rvv", (void *)_cffi_f_ParticlesMonitorData_getp_data_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_rvv },
  { "ParticlesMonitorData_getp_data_s", (void *)_cffi_f_ParticlesMonitorData_getp_data_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_s },
  { "ParticlesMonitorData_getp_data_start_tracking_at_element", (void *)_cffi_f_ParticlesMonitorData_getp_data_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_data_start_tracking_at_element },
  { "ParticlesMonitorData_getp_data_state", (void *)_cffi_f_ParticlesMonitorData_getp_data_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 367), (void *)_cffi_d_ParticlesMonitorData_getp_data_state },
  { "ParticlesMonitorData_getp_data_weight", (void *)_cffi_f_ParticlesMonitorData_getp_data_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_weight },
  { "ParticlesMonitorData_getp_data_x", (void *)_cffi_f_ParticlesMonitorData_getp_data_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_x },
  { "ParticlesMonitorData_getp_data_y", (void *)_cffi_f_ParticlesMonitorData_getp_data_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_y },
  { "ParticlesMonitorData_getp_data_zeta", (void *)_cffi_f_ParticlesMonitorData_getp_data_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 343), (void *)_cffi_d_ParticlesMonitorData_getp_data_zeta },
  { "ParticlesMonitorData_getp_ebe_mode", (void *)_cffi_f_ParticlesMonitorData_getp_ebe_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_ebe_mode },
  { "ParticlesMonitorData_getp_flag_auto_to_numpy", (void *)_cffi_f_ParticlesMonitorData_getp_flag_auto_to_numpy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_flag_auto_to_numpy },
  { "ParticlesMonitorData_getp_n_records", (void *)_cffi_f_ParticlesMonitorData_getp_n_records, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_n_records },
  { "ParticlesMonitorData_getp_n_repetitions", (void *)_cffi_f_ParticlesMonitorData_getp_n_repetitions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_n_repetitions },
  { "ParticlesMonitorData_getp_part_id_end", (void *)_cffi_f_ParticlesMonitorData_getp_part_id_end, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_part_id_end },
  { "ParticlesMonitorData_getp_part_id_start", (void *)_cffi_f_ParticlesMonitorData_getp_part_id_start, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_part_id_start },
  { "ParticlesMonitorData_getp_repetition_period", (void *)_cffi_f_ParticlesMonitorData_getp_repetition_period, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_repetition_period },
  { "ParticlesMonitorData_getp_start_at_turn", (void *)_cffi_f_ParticlesMonitorData_getp_start_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_start_at_turn },
  { "ParticlesMonitorData_getp_stop_at_turn", (void *)_cffi_f_ParticlesMonitorData_getp_stop_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 193), (void *)_cffi_d_ParticlesMonitorData_getp_stop_at_turn },
  { "ParticlesMonitorData_len_data__rng_s1", (void *)_cffi_f_ParticlesMonitorData_len_data__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data__rng_s1 },
  { "ParticlesMonitorData_len_data__rng_s2", (void *)_cffi_f_ParticlesMonitorData_len_data__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data__rng_s2 },
  { "ParticlesMonitorData_len_data__rng_s3", (void *)_cffi_f_ParticlesMonitorData_len_data__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data__rng_s3 },
  { "ParticlesMonitorData_len_data__rng_s4", (void *)_cffi_f_ParticlesMonitorData_len_data__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data__rng_s4 },
  { "ParticlesMonitorData_len_data_at_element", (void *)_cffi_f_ParticlesMonitorData_len_data_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_at_element },
  { "ParticlesMonitorData_len_data_at_turn", (void *)_cffi_f_ParticlesMonitorData_len_data_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_at_turn },
  { "ParticlesMonitorData_len_data_beta0", (void *)_cffi_f_ParticlesMonitorData_len_data_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_beta0 },
  { "ParticlesMonitorData_len_data_charge_ratio", (void *)_cffi_f_ParticlesMonitorData_len_data_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_charge_ratio },
  { "ParticlesMonitorData_len_data_chi", (void *)_cffi_f_ParticlesMonitorData_len_data_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_chi },
  { "ParticlesMonitorData_len_data_delta", (void *)_cffi_f_ParticlesMonitorData_len_data_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_delta },
  { "ParticlesMonitorData_len_data_gamma0", (void *)_cffi_f_ParticlesMonitorData_len_data_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_gamma0 },
  { "ParticlesMonitorData_len_data_p0c", (void *)_cffi_f_ParticlesMonitorData_len_data_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_p0c },
  { "ParticlesMonitorData_len_data_parent_particle_id", (void *)_cffi_f_ParticlesMonitorData_len_data_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_parent_particle_id },
  { "ParticlesMonitorData_len_data_particle_id", (void *)_cffi_f_ParticlesMonitorData_len_data_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_particle_id },
  { "ParticlesMonitorData_len_data_pdg_id", (void *)_cffi_f_ParticlesMonitorData_len_data_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_pdg_id },
  { "ParticlesMonitorData_len_data_ptau", (void *)_cffi_f_ParticlesMonitorData_len_data_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_ptau },
  { "ParticlesMonitorData_len_data_px", (void *)_cffi_f_ParticlesMonitorData_len_data_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_px },
  { "ParticlesMonitorData_len_data_py", (void *)_cffi_f_ParticlesMonitorData_len_data_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_py },
  { "ParticlesMonitorData_len_data_rpp", (void *)_cffi_f_ParticlesMonitorData_len_data_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_rpp },
  { "ParticlesMonitorData_len_data_rvv", (void *)_cffi_f_ParticlesMonitorData_len_data_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_rvv },
  { "ParticlesMonitorData_len_data_s", (void *)_cffi_f_ParticlesMonitorData_len_data_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_s },
  { "ParticlesMonitorData_len_data_state", (void *)_cffi_f_ParticlesMonitorData_len_data_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_state },
  { "ParticlesMonitorData_len_data_weight", (void *)_cffi_f_ParticlesMonitorData_len_data_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_weight },
  { "ParticlesMonitorData_len_data_x", (void *)_cffi_f_ParticlesMonitorData_len_data_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_x },
  { "ParticlesMonitorData_len_data_y", (void *)_cffi_f_ParticlesMonitorData_len_data_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_y },
  { "ParticlesMonitorData_len_data_zeta", (void *)_cffi_f_ParticlesMonitorData_len_data_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 293), (void *)_cffi_d_ParticlesMonitorData_len_data_zeta },
  { "ParticlesMonitorData_set_data__capacity", (void *)_cffi_f_ParticlesMonitorData_set_data__capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_data__capacity },
  { "ParticlesMonitorData_set_data__num_active_particles", (void *)_cffi_f_ParticlesMonitorData_set_data__num_active_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_data__num_active_particles },
  { "ParticlesMonitorData_set_data__num_lost_particles", (void *)_cffi_f_ParticlesMonitorData_set_data__num_lost_particles, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_data__num_lost_particles },
  { "ParticlesMonitorData_set_data__rng_s1", (void *)_cffi_f_ParticlesMonitorData_set_data__rng_s1, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 774), (void *)_cffi_d_ParticlesMonitorData_set_data__rng_s1 },
  { "ParticlesMonitorData_set_data__rng_s2", (void *)_cffi_f_ParticlesMonitorData_set_data__rng_s2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 774), (void *)_cffi_d_ParticlesMonitorData_set_data__rng_s2 },
  { "ParticlesMonitorData_set_data__rng_s3", (void *)_cffi_f_ParticlesMonitorData_set_data__rng_s3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 774), (void *)_cffi_d_ParticlesMonitorData_set_data__rng_s3 },
  { "ParticlesMonitorData_set_data__rng_s4", (void *)_cffi_f_ParticlesMonitorData_set_data__rng_s4, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 774), (void *)_cffi_d_ParticlesMonitorData_set_data__rng_s4 },
  { "ParticlesMonitorData_set_data_at_element", (void *)_cffi_f_ParticlesMonitorData_set_data_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_at_element },
  { "ParticlesMonitorData_set_data_at_turn", (void *)_cffi_f_ParticlesMonitorData_set_data_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_at_turn },
  { "ParticlesMonitorData_set_data_beta0", (void *)_cffi_f_ParticlesMonitorData_set_data_beta0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_beta0 },
  { "ParticlesMonitorData_set_data_charge_ratio", (void *)_cffi_f_ParticlesMonitorData_set_data_charge_ratio, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_charge_ratio },
  { "ParticlesMonitorData_set_data_chi", (void *)_cffi_f_ParticlesMonitorData_set_data_chi, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_chi },
  { "ParticlesMonitorData_set_data_delta", (void *)_cffi_f_ParticlesMonitorData_set_data_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_delta },
  { "ParticlesMonitorData_set_data_gamma0", (void *)_cffi_f_ParticlesMonitorData_set_data_gamma0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_gamma0 },
  { "ParticlesMonitorData_set_data_mass0", (void *)_cffi_f_ParticlesMonitorData_set_data_mass0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 756), (void *)_cffi_d_ParticlesMonitorData_set_data_mass0 },
  { "ParticlesMonitorData_set_data_p0c", (void *)_cffi_f_ParticlesMonitorData_set_data_p0c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_p0c },
  { "ParticlesMonitorData_set_data_parent_particle_id", (void *)_cffi_f_ParticlesMonitorData_set_data_parent_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_parent_particle_id },
  { "ParticlesMonitorData_set_data_particle_id", (void *)_cffi_f_ParticlesMonitorData_set_data_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_particle_id },
  { "ParticlesMonitorData_set_data_pdg_id", (void *)_cffi_f_ParticlesMonitorData_set_data_pdg_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_pdg_id },
  { "ParticlesMonitorData_set_data_ptau", (void *)_cffi_f_ParticlesMonitorData_set_data_ptau, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_ptau },
  { "ParticlesMonitorData_set_data_px", (void *)_cffi_f_ParticlesMonitorData_set_data_px, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_px },
  { "ParticlesMonitorData_set_data_py", (void *)_cffi_f_ParticlesMonitorData_set_data_py, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_py },
  { "ParticlesMonitorData_set_data_q0", (void *)_cffi_f_ParticlesMonitorData_set_data_q0, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 756), (void *)_cffi_d_ParticlesMonitorData_set_data_q0 },
  { "ParticlesMonitorData_set_data_rpp", (void *)_cffi_f_ParticlesMonitorData_set_data_rpp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_rpp },
  { "ParticlesMonitorData_set_data_rvv", (void *)_cffi_f_ParticlesMonitorData_set_data_rvv, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_rvv },
  { "ParticlesMonitorData_set_data_s", (void *)_cffi_f_ParticlesMonitorData_set_data_s, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_s },
  { "ParticlesMonitorData_set_data_start_tracking_at_element", (void *)_cffi_f_ParticlesMonitorData_set_data_start_tracking_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_data_start_tracking_at_element },
  { "ParticlesMonitorData_set_data_state", (void *)_cffi_f_ParticlesMonitorData_set_data_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 769), (void *)_cffi_d_ParticlesMonitorData_set_data_state },
  { "ParticlesMonitorData_set_data_weight", (void *)_cffi_f_ParticlesMonitorData_set_data_weight, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_weight },
  { "ParticlesMonitorData_set_data_x", (void *)_cffi_f_ParticlesMonitorData_set_data_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_x },
  { "ParticlesMonitorData_set_data_y", (void *)_cffi_f_ParticlesMonitorData_set_data_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_y },
  { "ParticlesMonitorData_set_data_zeta", (void *)_cffi_f_ParticlesMonitorData_set_data_zeta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 764), (void *)_cffi_d_ParticlesMonitorData_set_data_zeta },
  { "ParticlesMonitorData_set_ebe_mode", (void *)_cffi_f_ParticlesMonitorData_set_ebe_mode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_ebe_mode },
  { "ParticlesMonitorData_set_flag_auto_to_numpy", (void *)_cffi_f_ParticlesMonitorData_set_flag_auto_to_numpy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_flag_auto_to_numpy },
  { "ParticlesMonitorData_set_n_records", (void *)_cffi_f_ParticlesMonitorData_set_n_records, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_n_records },
  { "ParticlesMonitorData_set_n_repetitions", (void *)_cffi_f_ParticlesMonitorData_set_n_repetitions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_n_repetitions },
  { "ParticlesMonitorData_set_part_id_end", (void *)_cffi_f_ParticlesMonitorData_set_part_id_end, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_part_id_end },
  { "ParticlesMonitorData_set_part_id_start", (void *)_cffi_f_ParticlesMonitorData_set_part_id_start, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_part_id_start },
  { "ParticlesMonitorData_set_repetition_period", (void *)_cffi_f_ParticlesMonitorData_set_repetition_period, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_repetition_period },
  { "ParticlesMonitorData_set_start_at_turn", (void *)_cffi_f_ParticlesMonitorData_set_start_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_start_at_turn },
  { "ParticlesMonitorData_set_stop_at_turn", (void *)_cffi_f_ParticlesMonitorData_set_stop_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 760), (void *)_cffi_d_ParticlesMonitorData_set_stop_at_turn },
  { "Particles_initialize_rand_gen", (void *)_cffi_f_Particles_initialize_rand_gen, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 751), (void *)_cffi_d_Particles_initialize_rand_gen },
  { "RandomExponentialData_get__dummy", (void *)_cffi_f_RandomExponentialData_get__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 558), (void *)_cffi_d_RandomExponentialData_get__dummy },
  { "RandomExponentialData_getp", (void *)_cffi_f_RandomExponentialData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 453), (void *)_cffi_d_RandomExponentialData_getp },
  { "RandomExponentialData_getp__dummy", (void *)_cffi_f_RandomExponentialData_getp__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 552), (void *)_cffi_d_RandomExponentialData_getp__dummy },
  { "RandomExponentialData_set__dummy", (void *)_cffi_f_RandomExponentialData_set__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 779), (void *)_cffi_d_RandomExponentialData_set__dummy },
  { "RandomUniformData_get__dummy", (void *)_cffi_f_RandomUniformData_get__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 561), (void *)_cffi_d_RandomUniformData_get__dummy },
  { "RandomUniformData_getp", (void *)_cffi_f_RandomUniformData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 456), (void *)_cffi_d_RandomUniformData_getp },
  { "RandomUniformData_getp__dummy", (void *)_cffi_f_RandomUniformData_getp__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 555), (void *)_cffi_d_RandomUniformData_getp__dummy },
  { "RandomUniformData_set__dummy", (void *)_cffi_f_RandomUniformData_set__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 783), (void *)_cffi_d_RandomUniformData_set__dummy },
  { "RecordIdentifier_get_buffer_id", (void *)_cffi_f_RecordIdentifier_get_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 300), (void *)_cffi_d_RecordIdentifier_get_buffer_id },
  { "RecordIdentifier_get_offset", (void *)_cffi_f_RecordIdentifier_get_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 300), (void *)_cffi_d_RecordIdentifier_get_offset },
  { "RecordIdentifier_getp", (void *)_cffi_f_RecordIdentifier_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 465), (void *)_cffi_d_RecordIdentifier_getp },
  { "RecordIdentifier_getp_buffer_id", (void *)_cffi_f_RecordIdentifier_getp_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 200), (void *)_cffi_d_RecordIdentifier_getp_buffer_id },
  { "RecordIdentifier_getp_offset", (void *)_cffi_f_RecordIdentifier_getp_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 200), (void *)_cffi_d_RecordIdentifier_getp_offset },
  { "RecordIdentifier_set_buffer_id", (void *)_cffi_f_RecordIdentifier_set_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 787), (void *)_cffi_d_RecordIdentifier_set_buffer_id },
  { "RecordIdentifier_set_offset", (void *)_cffi_f_RecordIdentifier_set_offset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 787), (void *)_cffi_d_RecordIdentifier_set_offset },
  { "RecordIndex_get__dummy", (void *)_cffi_f_RecordIndex_get__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 546), (void *)_cffi_d_RecordIndex_get__dummy },
  { "RecordIndex_get_buffer_id", (void *)_cffi_f_RecordIndex_get_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 303), (void *)_cffi_d_RecordIndex_get_buffer_id },
  { "RecordIndex_get_capacity", (void *)_cffi_f_RecordIndex_get_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 303), (void *)_cffi_d_RecordIndex_get_capacity },
  { "RecordIndex_get_num_recorded", (void *)_cffi_f_RecordIndex_get_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 546), (void *)_cffi_d_RecordIndex_get_num_recorded },
  { "RecordIndex_getp", (void *)_cffi_f_RecordIndex_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 480), (void *)_cffi_d_RecordIndex_getp },
  { "RecordIndex_getp__dummy", (void *)_cffi_f_RecordIndex_getp__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 516), (void *)_cffi_d_RecordIndex_getp__dummy },
  { "RecordIndex_getp_buffer_id", (void *)_cffi_f_RecordIndex_getp_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 203), (void *)_cffi_d_RecordIndex_getp_buffer_id },
  { "RecordIndex_getp_capacity", (void *)_cffi_f_RecordIndex_getp_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 203), (void *)_cffi_d_RecordIndex_getp_capacity },
  { "RecordIndex_getp_num_recorded", (void *)_cffi_f_RecordIndex_getp_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 516), (void *)_cffi_d_RecordIndex_getp_num_recorded },
  { "RecordIndex_set__dummy", (void *)_cffi_f_RecordIndex_set__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 795), (void *)_cffi_d_RecordIndex_set__dummy },
  { "RecordIndex_set_buffer_id", (void *)_cffi_f_RecordIndex_set_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 791), (void *)_cffi_d_RecordIndex_set_buffer_id },
  { "RecordIndex_set_capacity", (void *)_cffi_f_RecordIndex_set_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 791), (void *)_cffi_d_RecordIndex_set_capacity },
  { "RecordIndex_set_num_recorded", (void *)_cffi_f_RecordIndex_set_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 795), (void *)_cffi_d_RecordIndex_set_num_recorded },
  { "SRotationData_get_cos_z", (void *)_cffi_f_SRotationData_get_cos_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 135), (void *)_cffi_d_SRotationData_get_cos_z },
  { "SRotationData_get_sin_z", (void *)_cffi_f_SRotationData_get_sin_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 135), (void *)_cffi_d_SRotationData_get_sin_z },
  { "SRotationData_getp", (void *)_cffi_f_SRotationData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 486), (void *)_cffi_d_SRotationData_getp },
  { "SRotationData_getp_cos_z", (void *)_cffi_f_SRotationData_getp_cos_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 68), (void *)_cffi_d_SRotationData_getp_cos_z },
  { "SRotationData_getp_sin_z", (void *)_cffi_f_SRotationData_getp_sin_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 68), (void *)_cffi_d_SRotationData_getp_sin_z },
  { "SRotationData_set_cos_z", (void *)_cffi_f_SRotationData_set_cos_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 799), (void *)_cffi_d_SRotationData_set_cos_z },
  { "SRotationData_set_sin_z", (void *)_cffi_f_SRotationData_set_sin_z, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 799), (void *)_cffi_d_SRotationData_set_sin_z },
  { "SynchrotronRadiationRecordData_get__index__dummy", (void *)_cffi_f_SynchrotronRadiationRecordData_get__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 549), (void *)_cffi_d_SynchrotronRadiationRecordData_get__index__dummy },
  { "SynchrotronRadiationRecordData_get__index_buffer_id", (void *)_cffi_f_SynchrotronRadiationRecordData_get__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_get__index_buffer_id },
  { "SynchrotronRadiationRecordData_get__index_capacity", (void *)_cffi_f_SynchrotronRadiationRecordData_get__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_get__index_capacity },
  { "SynchrotronRadiationRecordData_get__index_num_recorded", (void *)_cffi_f_SynchrotronRadiationRecordData_get__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 549), (void *)_cffi_d_SynchrotronRadiationRecordData_get__index_num_recorded },
  { "SynchrotronRadiationRecordData_get_at_element", (void *)_cffi_f_SynchrotronRadiationRecordData_get_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 309), (void *)_cffi_d_SynchrotronRadiationRecordData_get_at_element },
  { "SynchrotronRadiationRecordData_get_at_turn", (void *)_cffi_f_SynchrotronRadiationRecordData_get_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 309), (void *)_cffi_d_SynchrotronRadiationRecordData_get_at_turn },
  { "SynchrotronRadiationRecordData_get_particle_delta", (void *)_cffi_f_SynchrotronRadiationRecordData_get_particle_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 138), (void *)_cffi_d_SynchrotronRadiationRecordData_get_particle_delta },
  { "SynchrotronRadiationRecordData_get_particle_id", (void *)_cffi_f_SynchrotronRadiationRecordData_get_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 309), (void *)_cffi_d_SynchrotronRadiationRecordData_get_particle_id },
  { "SynchrotronRadiationRecordData_get_photon_energy", (void *)_cffi_f_SynchrotronRadiationRecordData_get_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 138), (void *)_cffi_d_SynchrotronRadiationRecordData_get_photon_energy },
  { "SynchrotronRadiationRecordData_getp", (void *)_cffi_f_SynchrotronRadiationRecordData_getp, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 489), (void *)_cffi_d_SynchrotronRadiationRecordData_getp },
  { "SynchrotronRadiationRecordData_getp1_at_element", (void *)_cffi_f_SynchrotronRadiationRecordData_getp1_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_SynchrotronRadiationRecordData_getp1_at_element },
  { "SynchrotronRadiationRecordData_getp1_at_turn", (void *)_cffi_f_SynchrotronRadiationRecordData_getp1_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_SynchrotronRadiationRecordData_getp1_at_turn },
  { "SynchrotronRadiationRecordData_getp1_particle_delta", (void *)_cffi_f_SynchrotronRadiationRecordData_getp1_particle_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 71), (void *)_cffi_d_SynchrotronRadiationRecordData_getp1_particle_delta },
  { "SynchrotronRadiationRecordData_getp1_particle_id", (void *)_cffi_f_SynchrotronRadiationRecordData_getp1_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_SynchrotronRadiationRecordData_getp1_particle_id },
  { "SynchrotronRadiationRecordData_getp1_photon_energy", (void *)_cffi_f_SynchrotronRadiationRecordData_getp1_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 71), (void *)_cffi_d_SynchrotronRadiationRecordData_getp1_photon_energy },
  { "SynchrotronRadiationRecordData_getp__index", (void *)_cffi_f_SynchrotronRadiationRecordData_getp__index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 483), (void *)_cffi_d_SynchrotronRadiationRecordData_getp__index },
  { "SynchrotronRadiationRecordData_getp__index__dummy", (void *)_cffi_f_SynchrotronRadiationRecordData_getp__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 519), (void *)_cffi_d_SynchrotronRadiationRecordData_getp__index__dummy },
  { "SynchrotronRadiationRecordData_getp__index_buffer_id", (void *)_cffi_f_SynchrotronRadiationRecordData_getp__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 206), (void *)_cffi_d_SynchrotronRadiationRecordData_getp__index_buffer_id },
  { "SynchrotronRadiationRecordData_getp__index_capacity", (void *)_cffi_f_SynchrotronRadiationRecordData_getp__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 206), (void *)_cffi_d_SynchrotronRadiationRecordData_getp__index_capacity },
  { "SynchrotronRadiationRecordData_getp__index_num_recorded", (void *)_cffi_f_SynchrotronRadiationRecordData_getp__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 519), (void *)_cffi_d_SynchrotronRadiationRecordData_getp__index_num_recorded },
  { "SynchrotronRadiationRecordData_getp_at_element", (void *)_cffi_f_SynchrotronRadiationRecordData_getp_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 370), (void *)_cffi_d_SynchrotronRadiationRecordData_getp_at_element },
  { "SynchrotronRadiationRecordData_getp_at_turn", (void *)_cffi_f_SynchrotronRadiationRecordData_getp_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 370), (void *)_cffi_d_SynchrotronRadiationRecordData_getp_at_turn },
  { "SynchrotronRadiationRecordData_getp_particle_delta", (void *)_cffi_f_SynchrotronRadiationRecordData_getp_particle_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 346), (void *)_cffi_d_SynchrotronRadiationRecordData_getp_particle_delta },
  { "SynchrotronRadiationRecordData_getp_particle_id", (void *)_cffi_f_SynchrotronRadiationRecordData_getp_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 370), (void *)_cffi_d_SynchrotronRadiationRecordData_getp_particle_id },
  { "SynchrotronRadiationRecordData_getp_photon_energy", (void *)_cffi_f_SynchrotronRadiationRecordData_getp_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 346), (void *)_cffi_d_SynchrotronRadiationRecordData_getp_photon_energy },
  { "SynchrotronRadiationRecordData_len_at_element", (void *)_cffi_f_SynchrotronRadiationRecordData_len_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_len_at_element },
  { "SynchrotronRadiationRecordData_len_at_turn", (void *)_cffi_f_SynchrotronRadiationRecordData_len_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_len_at_turn },
  { "SynchrotronRadiationRecordData_len_particle_delta", (void *)_cffi_f_SynchrotronRadiationRecordData_len_particle_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_len_particle_delta },
  { "SynchrotronRadiationRecordData_len_particle_id", (void *)_cffi_f_SynchrotronRadiationRecordData_len_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_len_particle_id },
  { "SynchrotronRadiationRecordData_len_photon_energy", (void *)_cffi_f_SynchrotronRadiationRecordData_len_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 306), (void *)_cffi_d_SynchrotronRadiationRecordData_len_photon_energy },
  { "SynchrotronRadiationRecordData_set__index__dummy", (void *)_cffi_f_SynchrotronRadiationRecordData_set__index__dummy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 817), (void *)_cffi_d_SynchrotronRadiationRecordData_set__index__dummy },
  { "SynchrotronRadiationRecordData_set__index_buffer_id", (void *)_cffi_f_SynchrotronRadiationRecordData_set__index_buffer_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 803), (void *)_cffi_d_SynchrotronRadiationRecordData_set__index_buffer_id },
  { "SynchrotronRadiationRecordData_set__index_capacity", (void *)_cffi_f_SynchrotronRadiationRecordData_set__index_capacity, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 803), (void *)_cffi_d_SynchrotronRadiationRecordData_set__index_capacity },
  { "SynchrotronRadiationRecordData_set__index_num_recorded", (void *)_cffi_f_SynchrotronRadiationRecordData_set__index_num_recorded, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 817), (void *)_cffi_d_SynchrotronRadiationRecordData_set__index_num_recorded },
  { "SynchrotronRadiationRecordData_set_at_element", (void *)_cffi_f_SynchrotronRadiationRecordData_set_at_element, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 812), (void *)_cffi_d_SynchrotronRadiationRecordData_set_at_element },
  { "SynchrotronRadiationRecordData_set_at_turn", (void *)_cffi_f_SynchrotronRadiationRecordData_set_at_turn, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 812), (void *)_cffi_d_SynchrotronRadiationRecordData_set_at_turn },
  { "SynchrotronRadiationRecordData_set_particle_delta", (void *)_cffi_f_SynchrotronRadiationRecordData_set_particle_delta, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 807), (void *)_cffi_d_SynchrotronRadiationRecordData_set_particle_delta },
  { "SynchrotronRadiationRecordData_set_particle_id", (void *)_cffi_f_SynchrotronRadiationRecordData_set_particle_id, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 812), (void *)_cffi_d_SynchrotronRadiationRecordData_set_particle_id },
  { "SynchrotronRadiationRecordData_set_photon_energy", (void *)_cffi_f_SynchrotronRadiationRecordData_set_photon_energy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 807), (void *)_cffi_d_SynchrotronRadiationRecordData_set_photon_energy },
  { "track_line", (void *)_cffi_f_track_line, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 575), (void *)_cffi_d_track_line },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "ArrNElementRefClass_s", 827, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ArrNFloat64_s", 828, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ArrNInt64_s", 829, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ArrNString_s", 830, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ArrNUint32_s", 831, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "BeamBeamBiGaussian2DData_s", 832, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "BeamBeamBiGaussian3DData_s", 833, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "BeamBeamBiGaussian3DRecordData_s", 834, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "BeamstrahlungTableData_s", 835, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "BhabhaTableData_s", 836, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "CavityData_s", 837, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "DipoleEdgeData_s", 838, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "DriftData_s", 839, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ElementRefClass_s", 840, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ElementRefData_s", 841, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "LumiTableData_s", 842, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "MarkerData_s", 843, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "MultipoleData_s", 844, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ParticlesData_s", 845, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "ParticlesMonitorData_s", 846, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "RandomExponentialData_s", 847, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "RandomUniformData_s", 848, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "RecordIdentifier_s", 849, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "RecordIndex_s", 850, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "SRotationData_s", 851, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "SynchrotronRadiationRecordData_s", 852, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "ElementRefClass_e", 824, _cffi_prim_int(sizeof(enum ElementRefClass_e), ((enum ElementRefClass_e)-1) <= 0),
    "ElementRefClass_BeamBeamBiGaussian2DData_t,ElementRefClass_BeamBeamBiGaussian3DData_t,ElementRefClass_CavityData_t,ElementRefClass_DipoleEdgeData_t,ElementRefClass_DriftData_t,ElementRefClass_MarkerData_t,ElementRefClass_MultipoleData_t,ElementRefClass_ParticlesMonitorData_t,ElementRefClass_SRotationData_t" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "ArrNElementRefClass", 214 },
  { "ArrNFloat64", 9 },
  { "ArrNInt64", 143 },
  { "ArrNString", 1 },
  { "ArrNUint32", 234 },
  { "BeamBeamBiGaussian2DData", 13 },
  { "BeamBeamBiGaussian3DData", 16 },
  { "BeamBeamBiGaussian3DRecordData", 23 },
  { "BeamstrahlungTableData", 27 },
  { "BhabhaTableData", 31 },
  { "CavityData", 35 },
  { "DipoleEdgeData", 38 },
  { "DriftData", 41 },
  { "ElementRefClass", 264 },
  { "ElementRefData", 5 },
  { "LumiTableData", 44 },
  { "MarkerData", 181 },
  { "MultipoleData", 48 },
  { "ParticlesData", 55 },
  { "ParticlesMonitorData", 62 },
  { "RandomExponentialData", 454 },
  { "RandomUniformData", 457 },
  { "RecordIdentifier", 201 },
  { "RecordIndex", 204 },
  { "SRotationData", 69 },
  { "SynchrotronRadiationRecordData", 72 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  NULL,  /* no fields */
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  1127,  /* num_globals */
  26,  /* num_struct_unions */
  1,  /* num_enums */
  26,  /* num_typenames */
  NULL,  /* no includes */
  856,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit_40d92fb41f2247a79650c3e9c506bbf7(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit_40d92fb41f2247a79650c3e9c506bbf7(void) { return NULL; }
#  else
     init40d92fb41f2247a79650c3e9c506bbf7(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit_40d92fb41f2247a79650c3e9c506bbf7(void)
{
  return _cffi_init("40d92fb41f2247a79650c3e9c506bbf7", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init40d92fb41f2247a79650c3e9c506bbf7(void)
{
  _cffi_init("40d92fb41f2247a79650c3e9c506bbf7", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
